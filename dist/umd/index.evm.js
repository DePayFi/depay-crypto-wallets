(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@depay/web3-blockchains'), require('ethers'), require('@depay/web3-client-evm'), require('@depay/walletconnect-v1'), require('@depay/coinbase-wallet-sdk')) :
  typeof define === 'function' && define.amd ? define(['exports', '@depay/web3-blockchains', 'ethers', '@depay/web3-client-evm', '@depay/walletconnect-v1', '@depay/coinbase-wallet-sdk'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Web3Wallets = {}, global.Web3Blockchains, global.ethers, global.Web3Client, global.WalletConnect, global.CoinbaseWalletSdk));
}(this, (function (exports, Blockchains, ethers, web3ClientEvm, walletconnectV1, coinbaseWalletSdk) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var Blockchains__default = /*#__PURE__*/_interopDefaultLegacy(Blockchains);

  let supported$2 = ['ethereum', 'bsc', 'polygon', 'fantom', 'velas'];
  supported$2.evm = ['ethereum', 'bsc', 'polygon', 'fantom', 'velas'];
  supported$2.solana = [];

  var _global$1 = (typeof global !== "undefined" ? global :
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window : {});
  if(_global$1.XMLHttpRequest == undefined) { _global$1.XMLHttpRequest = class XMLHttpRequest { open() {} }; }
  if(_global$1.location == undefined) { _global$1.location = {}; }
  if(_global$1.crypto == undefined) { _global$1.crypto = {}; }
  if(_global$1.crypto.getRandomValues == undefined) { _global$1.crypto.getRandomValues = function(abv) { var l = abv.length; while (l--) { abv[l] = parseInt(Math.random().toString().replace('0.', ''), 10); } return abv }; }
  if(_global$1.fetch == undefined) { throw('Please polyfill .fetch | See: https://github.com/DePayFi/solana-web3.js#polyfill-fetch') }
        
  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function getAugmentedNamespace(n) {
    var f = n.default;
  	if (typeof f == "function") {
  		var a = function () {
  			return f.apply(this, arguments);
  		};
  		a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, '__esModule', {value: true});
  	Object.keys(n).forEach(function (k) {
  		var d = Object.getOwnPropertyDescriptor(n, k);
  		Object.defineProperty(a, k, d.get ? d : {
  			enumerable: true,
  			get: function () {
  				return n[k];
  			}
  		});
  	});
  	return a;
  }

  var global$1 = (typeof global !== "undefined" ? global :
    typeof self !== "undefined" ? self :
    typeof window !== "undefined" ? window : {});

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;
  function init () {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray (b64) {
    if (!inited) {
      init();
    }
    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4')
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(len * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? len - 4 : len;

    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = (tmp >> 16) & 0xFF;
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
      arr[L++] = (tmp >> 8) & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr
  }

  function tripletToBase64 (num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
  }

  function encodeChunk (uint8, start, end) {
    var tmp;
    var output = [];
    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
      output.push(tripletToBase64(tmp));
    }
    return output.join('')
  }

  function fromByteArray (uint8) {
    if (!inited) {
      init();
    }
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[(tmp << 4) & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
      output += lookup[tmp >> 10];
      output += lookup[(tmp >> 4) & 0x3F];
      output += lookup[(tmp << 2) & 0x3F];
      output += '=';
    }

    parts.push(output);

    return parts.join('')
  }

  function read (buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? (nBytes - 1) : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];

    i += d;

    e = s & ((1 << (-nBits)) - 1);
    s >>= (-nBits);
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & ((1 << (-nBits)) - 1);
    e >>= (-nBits);
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : ((s ? -1 : 1) * Infinity)
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
  }

  function write (buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
    var i = isLE ? 0 : (nBytes - 1);
    var d = isLE ? 1 : -1;
    var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = (e << mLen) | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;

  var isArray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */

  var INSPECT_MAX_BYTES = 50;

  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  Buffer$1.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
    ? global$1.TYPED_ARRAY_SUPPORT
    : true;

  /*
   * Export kMaxLength after typed array support is determined.
   */
  var _kMaxLength = kMaxLength();

  function kMaxLength () {
    return Buffer$1.TYPED_ARRAY_SUPPORT
      ? 0x7fffffff
      : 0x3fffffff
  }

  function createBuffer (that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length')
    }
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer$1.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer$1(length);
      }
      that.length = length;
    }

    return that
  }

  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */

  function Buffer$1 (arg, encodingOrOffset, length) {
    if (!Buffer$1.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer$1)) {
      return new Buffer$1(arg, encodingOrOffset, length)
    }

    // Common case.
    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error(
          'If encoding is specified then the first argument must be a string'
        )
      }
      return allocUnsafe(this, arg)
    }
    return from(this, arg, encodingOrOffset, length)
  }

  Buffer$1.poolSize = 8192; // not used by this implementation

  // TODO: Legacy, not needed anymore. Remove in next major version.
  Buffer$1._augment = function (arr) {
    arr.__proto__ = Buffer$1.prototype;
    return arr
  };

  function from (that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number')
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length)
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset)
    }

    return fromObject(that, value)
  }

  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  Buffer$1.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length)
  };

  if (Buffer$1.TYPED_ARRAY_SUPPORT) {
    Buffer$1.prototype.__proto__ = Uint8Array.prototype;
    Buffer$1.__proto__ = Uint8Array;
  }

  function assertSize (size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number')
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative')
    }
  }

  function alloc (that, size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(that, size)
    }
    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string'
        ? createBuffer(that, size).fill(fill, encoding)
        : createBuffer(that, size).fill(fill)
    }
    return createBuffer(that, size)
  }

  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  Buffer$1.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding)
  };

  function allocUnsafe (that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }
    return that
  }

  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  Buffer$1.allocUnsafe = function (size) {
    return allocUnsafe(null, size)
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  Buffer$1.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size)
  };

  function fromString (that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer$1.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding')
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);

    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that
  }

  function fromArrayLike (that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }
    return that
  }

  function fromArrayBuffer (that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds')
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds')
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer$1.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }
    return that
  }

  function fromObject (that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that
      }

      obj.copy(that, 0, 0, len);
      return that
    }

    if (obj) {
      if ((typeof ArrayBuffer !== 'undefined' &&
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0)
        }
        return fromArrayLike(that, obj)
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data)
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
  }

  function checked (length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')
    }
    return length | 0
  }

  function SlowBuffer (length) {
    if (+length != length) { // eslint-disable-line eqeqeq
      length = 0;
    }
    return Buffer$1.alloc(+length)
  }
  Buffer$1.isBuffer = isBuffer;
  function internalIsBuffer (b) {
    return !!(b != null && b._isBuffer)
  }

  Buffer$1.compare = function compare (a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers')
    }

    if (a === b) return 0

    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  Buffer$1.isEncoding = function isEncoding (encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true
      default:
        return false
    }
  };

  Buffer$1.concat = function concat (list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }

    if (list.length === 0) {
      return Buffer$1.alloc(0)
    }

    var i;
    if (length === undefined) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer$1.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
      buf.copy(buffer, pos);
      pos += buf.length;
    }
    return buffer
  };

  function byteLength (string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length
    }
    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength
    }
    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0

    // Use a for loop to avoid recursion
    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len
        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes$1(string).length
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2
        case 'hex':
          return len >>> 1
        case 'base64':
          return base64ToBytes(string).length
        default:
          if (loweredCase) return utf8ToBytes$1(string).length // assume utf8
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer$1.byteLength = byteLength;

  function slowToString (encoding, start, end) {
    var loweredCase = false;

    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.

    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
      start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
      return ''
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return ''
    }

    // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return ''
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end)

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end)

        case 'ascii':
          return asciiSlice(this, start, end)

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end)

        case 'base64':
          return base64Slice(this, start, end)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  }

  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  Buffer$1.prototype._isBuffer = true;

  function swap (b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer$1.prototype.swap16 = function swap16 () {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits')
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this
  };

  Buffer$1.prototype.swap32 = function swap32 () {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits')
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this
  };

  Buffer$1.prototype.swap64 = function swap64 () {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits')
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this
  };

  Buffer$1.prototype.toString = function toString () {
    var length = this.length | 0;
    if (length === 0) return ''
    if (arguments.length === 0) return utf8Slice(this, 0, length)
    return slowToString.apply(this, arguments)
  };

  Buffer$1.prototype.equals = function equals (b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
    if (this === b) return true
    return Buffer$1.compare(this, b) === 0
  };

  Buffer$1.prototype.inspect = function inspect () {
    var str = '';
    var max = INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }
    return '<Buffer ' + str + '>'
  };

  Buffer$1.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer')
    }

    if (start === undefined) {
      start = 0;
    }
    if (end === undefined) {
      end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
      thisStart = 0;
    }
    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index')
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0
    }
    if (thisStart >= thisEnd) {
      return -1
    }
    if (start >= end) {
      return 1
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;

    if (this === target) return 0

    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);

    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break
      }
    }

    if (x < y) return -1
    if (y < x) return 1
    return 0
  };

  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1

    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset;  // Coerce to Number.
    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : (buffer.length - 1);
    }

    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir) return -1
      else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1
    }

    // Normalize val
    if (typeof val === 'string') {
      val = Buffer$1.from(val, encoding);
    }

    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]
      if (Buffer$1.TYPED_ARRAY_SUPPORT &&
          typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
        }
      }
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
    }

    throw new TypeError('val must be string, number or Buffer')
  }

  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||
          encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read (buf, i) {
      if (indexSize === 1) {
        return buf[i]
      } else {
        return buf.readUInt16BE(i * indexSize)
      }
    }

    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break
          }
        }
        if (found) return i
      }
    }

    return -1
  }

  Buffer$1.prototype.includes = function includes (val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1
  };

  Buffer$1.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
  };

  Buffer$1.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
  };

  function hexWrite (buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }

    // must be an even number of digits
    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i
      buf[offset + i] = parsed;
    }
    return i
  }

  function utf8Write (buf, string, offset, length) {
    return blitBuffer(utf8ToBytes$1(string, buf.length - offset), buf, offset, length)
  }

  function asciiWrite (buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length)
  }

  function latin1Write (buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length)
  }

  function base64Write (buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length)
  }

  function ucs2Write (buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
  }

  Buffer$1.prototype.write = function write (string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      }
    // legacy write(string, encoding, offset, length) - remove in v0.13
    } else {
      throw new Error(
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'
      )
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds')
    }

    if (!encoding) encoding = 'utf8';

    var loweredCase = false;
    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length)

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length)

        case 'ascii':
          return asciiWrite(this, string, offset, length)

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length)

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length)

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length)

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer$1.prototype.toJSON = function toJSON () {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    }
  };

  function base64Slice (buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf)
    } else {
      return fromByteArray(buf.slice(start, end))
    }
  }

  function utf8Slice (buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];

    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = (firstByte > 0xEF) ? 4
        : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
        : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }
            break
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }
            break
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }
        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res)
  }

  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray (codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
    }

    // Decode in chunks to avoid "call stack size exceeded".
    var res = '';
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res
  }

  function asciiSlice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret
  }

  function latin1Slice (buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret
  }

  function hexSlice (buf, start, end) {
    var len = buf.length;

    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;

    var out = '';
    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }
    return out
  }

  function utf16leSlice (buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';
    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res
  }

  Buffer$1.prototype.slice = function slice (start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;

    var newBuf;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer$1.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer$1(sliceLen, undefined);
      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf
  };

  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function checkOffset (offset, ext, length) {
    if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
  }

  Buffer$1.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val
  };

  Buffer$1.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;
    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val
  };

  Buffer$1.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset]
  };

  Buffer$1.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | (this[offset + 1] << 8)
  };

  Buffer$1.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return (this[offset] << 8) | this[offset + 1]
  };

  Buffer$1.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return ((this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16)) +
        (this[offset + 3] * 0x1000000)
  };

  Buffer$1.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
  };

  Buffer$1.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer$1.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);

    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }
    mul *= 0x80;

    if (val >= mul) val -= Math.pow(2, 8 * byteLength);

    return val
  };

  Buffer$1.prototype.readInt8 = function readInt8 (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return (this[offset])
    return ((0xff - this[offset] + 1) * -1)
  };

  Buffer$1.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | (this[offset + 1] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer$1.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | (this[offset] << 8);
    return (val & 0x8000) ? val | 0xFFFF0000 : val
  };

  Buffer$1.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
  };

  Buffer$1.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);

    return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
  };

  Buffer$1.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4)
  };

  Buffer$1.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4)
  };

  Buffer$1.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8)
  };

  Buffer$1.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8)
  };

  function checkInt (buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
  }

  Buffer$1.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = (value / mul) & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = (value & 0xff);
    return offset + 1
  };

  function objectWriteUInt16 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
        (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer$1.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer$1.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  function objectWriteUInt32 (buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
    }
  }

  Buffer$1.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = (value >>> 24);
      this[offset + 2] = (value >>> 16);
      this[offset + 1] = (value >>> 8);
      this[offset] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer$1.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  Buffer$1.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;
    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);

      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;
    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
    }

    return offset + byteLength
  };

  Buffer$1.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer$1.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = (value & 0xff);
    return offset + 1
  };

  Buffer$1.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2
  };

  Buffer$1.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 8);
      this[offset + 1] = (value & 0xff);
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2
  };

  Buffer$1.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value & 0xff);
      this[offset + 1] = (value >>> 8);
      this[offset + 2] = (value >>> 16);
      this[offset + 3] = (value >>> 24);
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4
  };

  Buffer$1.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    if (Buffer$1.TYPED_ARRAY_SUPPORT) {
      this[offset] = (value >>> 24);
      this[offset + 1] = (value >>> 16);
      this[offset + 2] = (value >>> 8);
      this[offset + 3] = (value & 0xff);
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4
  };

  function checkIEEE754 (buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range')
    if (offset < 0) throw new RangeError('Index out of range')
  }

  function writeFloat (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4
  }

  Buffer$1.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert)
  };

  Buffer$1.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert)
  };

  function writeDouble (buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8
  }

  Buffer$1.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert)
  };

  Buffer$1.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert)
  };

  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  Buffer$1.prototype.copy = function copy (target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;

    // Copy 0 bytes; we're done
    if (end === start) return 0
    if (target.length === 0 || this.length === 0) return 0

    // Fatal error conditions
    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds')
    }
    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
    if (end < 0) throw new RangeError('sourceEnd out of bounds')

    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer$1.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }

    return len
  };

  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  Buffer$1.prototype.fill = function fill (val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (code < 256) {
          val = code;
        }
      }
      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string')
      }
      if (typeof encoding === 'string' && !Buffer$1.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding)
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    }

    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index')
    }

    if (end <= start) {
      return this
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;

    if (!val) val = 0;

    var i;
    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val)
        ? val
        : utf8ToBytes$1(new Buffer$1(val, encoding).toString());
      var len = bytes.length;
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this
  };

  // HELPER FUNCTIONS
  // ================

  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean (str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return ''
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while (str.length % 4 !== 0) {
      str = str + '=';
    }
    return str
  }

  function stringtrim (str) {
    if (str.trim) return str.trim()
    return str.replace(/^\s+|\s+$/g, '')
  }

  function toHex (n) {
    if (n < 16) return '0' + n.toString(16)
    return n.toString(16)
  }

  function utf8ToBytes$1 (string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);

      // is surrogate component
      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue
          }

          // valid lead
          leadSurrogate = codePoint;

          continue
        }

        // 2 leads in a row
        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue
        }

        // valid surrogate pair
        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null;

      // encode utf8
      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break
        bytes.push(
          codePoint >> 0x6 | 0xC0,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break
        bytes.push(
          codePoint >> 0xC | 0xE0,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break
        bytes.push(
          codePoint >> 0x12 | 0xF0,
          codePoint >> 0xC & 0x3F | 0x80,
          codePoint >> 0x6 & 0x3F | 0x80,
          codePoint & 0x3F | 0x80
        );
      } else {
        throw new Error('Invalid code point')
      }
    }

    return bytes
  }

  function asciiToBytes (str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray
  }

  function utf16leToBytes (str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break

      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray
  }


  function base64ToBytes (str) {
    return toByteArray(base64clean(str))
  }

  function blitBuffer (src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if ((i + offset >= dst.length) || (i >= src.length)) break
      dst[i + offset] = src[i];
    }
    return i
  }

  function isnan (val) {
    return val !== val // eslint-disable-line no-self-compare
  }


  // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually
  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
  }

  function isFastBuffer (obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
  }

  // For Node v0.10 support. Remove this eventually.
  function isSlowBuffer (obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
  }

  var _polyfillNode_buffer = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	Buffer: Buffer$1,
  	INSPECT_MAX_BYTES: INSPECT_MAX_BYTES,
  	SlowBuffer: SlowBuffer,
  	isBuffer: isBuffer,
  	kMaxLength: _kMaxLength
  });

  var require$$0$1 = /*@__PURE__*/getAugmentedNamespace(_polyfillNode_buffer);

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  function _regeneratorRuntime() {
    /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

    _regeneratorRuntime = function () {
      return exports;
    };

    var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value: value,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }), obj[key];
    }

    try {
      define({}, "");
    } catch (err) {
      define = function (obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
          generator = Object.create(protoGenerator.prototype),
          context = new Context(tryLocsList || []);
      return generator._invoke = function (innerFn, self, context) {
        var state = "suspendedStart";
        return function (method, arg) {
          if ("executing" === state) throw new Error("Generator is already running");

          if ("completed" === state) {
            if ("throw" === method) throw arg;
            return doneResult();
          }

          for (context.method = method, context.arg = arg;;) {
            var delegate = context.delegate;

            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);

              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }

            if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
              if ("suspendedStart" === state) throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self, context);

            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
              return {
                value: record.arg,
                done: context.done
              };
            }

            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }(innerFn, self, context), generator;
    }

    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }

    exports.wrap = wrap;
    var ContinueSentinel = {};

    function Generator() {}

    function GeneratorFunction() {}

    function GeneratorFunctionPrototype() {}

    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function () {
      return this;
    });
    var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function (method) {
        define(prototype, method, function (arg) {
          return this._invoke(method, arg);
        });
      });
    }

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);

        if ("throw" !== record.type) {
          var result = record.arg,
              value = result.value;
          return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function (unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function (error) {
            return invoke("throw", error, resolve, reject);
          });
        }

        reject(record.arg);
      }

      var previousPromise;

      this._invoke = function (method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function (resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
      };
    }

    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];

      if (undefined === method) {
        if (context.delegate = null, "throw" === context.method) {
          if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
          context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);
      if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }

    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }

    function Context(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next) return iterable;

        if (!isNaN(iterable.length)) {
          var i = -1,
              next = function next() {
            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

            return next.value = undefined, next.done = !0, next;
          };

          return next.next = next;
        }
      }

      return {
        next: doneResult
      };
    }

    function doneResult() {
      return {
        value: undefined,
        done: !0
      };
    }

    return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function (genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function (arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
      return this;
    }), define(Gp, "toString", function () {
      return "[object Generator]";
    }), exports.keys = function (object) {
      var keys = [];

      for (var key in object) keys.push(key);

      return keys.reverse(), function next() {
        for (; keys.length;) {
          var key = keys.pop();
          if (key in object) return next.value = key, next.done = !1, next;
        }

        return next.done = !0, next;
      };
    }, exports.values = values, Context.prototype = {
      constructor: Context,
      reset: function (skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      },
      stop: function () {
        this.done = !0;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type) throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function (exception) {
        if (this.done) throw exception;
        var context = this;

        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i],
              record = entry.completion;
          if ("root" === entry.tryLoc) return handle("end");

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"),
                hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            } else {
              if (!hasFinally) throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function (type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function (record, afterLoc) {
        if ("throw" === record.type) throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function (finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      catch: function (tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];

          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;

            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }

            return thrown;
          }
        }

        throw new Error("illegal catch attempt");
      },
      delegateYield: function (iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
      }
    }, exports;
  }

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof$1(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;

    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }

    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};

    var target = _objectWithoutPropertiesLoose(source, excluded);

    var key, i;

    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }

    return target;
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }

    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();

    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
          result;

      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;

        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }

      return _possibleConstructorReturn(this, result);
    };
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get() {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get.bind();
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(arguments.length < 3 ? target : receiver);
        }

        return desc.value;
      };
    }

    return _get.apply(this, arguments);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;

    var _s, _e;

    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

    return arr2;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;

        var F = function () {};

        return {
          s: F,
          n: function () {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function (e) {
            throw e;
          },
          f: F
        };
      }

      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var normalCompletion = true,
        didErr = false,
        err;
    return {
      s: function () {
        it = it.call(o);
      },
      n: function () {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function (e) {
        didErr = true;
        err = e;
      },
      f: function () {
        try {
          if (!normalCompletion && it.return != null) it.return();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  var bn$1 = {exports: {}};

  (function (module) {
    (function (module, exports) {

      function assert(val, msg) {
        if (!val) throw new Error(msg || 'Assertion failed');
      } // Could use `inherits` module, but don't want to move from single file
      // architecture yet.


      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      } // BN


      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }

        this.negative = 0;
        this.words = null;
        this.length = 0; // Reduction context

        this.red = null;

        if (number !== null) {
          if (base === 'le' || base === 'be') {
            endian = base;
            base = 10;
          }

          this._init(number || 0, base || 10, endian || 'be');
        }
      }

      if (_typeof$1(module) === 'object') {
        module.exports = BN;
      } else {
        exports.BN = BN;
      }

      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer;

      try {
        if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
          Buffer = window.Buffer;
        } else {
          Buffer = require$$0$1.Buffer;
        }
      } catch (e) {}

      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }

        return num !== null && _typeof$1(num) === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };

      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };

      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };

      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === 'number') {
          return this._initNumber(number, base, endian);
        }

        if (_typeof$1(number) === 'object') {
          return this._initArray(number, base, endian);
        }

        if (base === 'hex') {
          base = 16;
        }

        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, '');
        var start = 0;

        if (number[0] === '-') {
          start++;
          this.negative = 1;
        }

        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);

            if (endian === 'le') {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };

      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }

        if (number < 0x4000000) {
          this.words = [number & 0x3ffffff];
          this.length = 1;
        } else if (number < 0x10000000000000) {
          this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
          this.length = 2;
        } else {
          assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)

          this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
          this.length = 3;
        }

        if (endian !== 'le') return; // Reverse the bytes

        this._initArray(this.toArray(), base, endian);
      };

      BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === 'number');

        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }

        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }

        var j, w;
        var off = 0;

        if (endian === 'be') {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;

            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === 'le') {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;

            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }

        return this._strip();
      };

      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index); // '0' - '9'

        if (c >= 48 && c <= 57) {
          return c - 48; // 'A' - 'F'
        } else if (c >= 65 && c <= 70) {
          return c - 55; // 'a' - 'f'
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, 'Invalid character in ' + string);
        }
      }

      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);

        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }

        return r;
      }

      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        } // 24-bits chunks


        var off = 0;
        var j = 0;
        var w;

        if (endian === 'be') {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;

            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;

          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;

            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }

        this._strip();
      };

      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);

        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul; // 'a'

          if (c >= 49) {
            b = c - 49 + 0xa; // 'A'
          } else if (c >= 17) {
            b = c - 17 + 0xa; // '0' - '9'
          } else {
            b = c;
          }

          assert(c >= 0 && b < mul, 'Invalid character');
          r += b;
        }

        return r;
      }

      BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [0];
        this.length = 1; // Find length of limb in base

        for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
          limbLen++;
        }

        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;

        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);

          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }

        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);

          for (i = 0; i < mod; i++) {
            pow *= base;
          }

          this.imuln(pow);

          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }

        this._strip();
      };

      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }

        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };

      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }

      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };

      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };

      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }

        return this;
      }; // Remove leading `0` from `this`


      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }

        return this._normSign();
      };

      BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }

        return this;
      }; // Check Symbol.for because not everywhere where Symbol defined
      // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility


      if (typeof Symbol !== 'undefined' && typeof Symbol["for"] === 'function') {
        try {
          BN.prototype[Symbol["for"]('nodejs.util.inspect.custom')] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }

      function inspect() {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
      }
      /*
       var zeros = [];
      var groupSizes = [];
      var groupBases = [];
       var s = '';
      var i = -1;
      while (++i < BN.wordSize) {
        zeros[i] = s;
        s += '0';
      }
      groupSizes[0] = 0;
      groupSizes[1] = 0;
      groupBases[0] = 0;
      groupBases[1] = 0;
      var base = 2 - 1;
      while (++base < 36 + 1) {
        var groupSize = 0;
        var groupBase = 1;
        while (groupBase < (1 << BN.wordSize) / base) {
          groupBase *= base;
          groupSize += 1;
        }
        groupSizes[base] = groupSize;
        groupBases[base] = groupBase;
      }
       */


      var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
      var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
      var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;

        if (base === 16 || base === 'hex') {
          out = '';
          var off = 0;
          var carry = 0;

          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;

            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }

            off += 2;

            if (off >= 26) {
              off -= 26;
              i--;
            }
          }

          if (carry !== 0) {
            out = carry.toString(16) + out;
          }

          while (out.length % padding !== 0) {
            out = '0' + out;
          }

          if (this.negative !== 0) {
            out = '-' + out;
          }

          return out;
        }

        if (base === (base | 0) && base >= 2 && base <= 36) {
          // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
          var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

          var groupBase = groupBases[base];
          out = '';
          var c = this.clone();
          c.negative = 0;

          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);

            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }

          if (this.isZero()) {
            out = '0' + out;
          }

          while (out.length % padding !== 0) {
            out = '0' + out;
          }

          if (this.negative !== 0) {
            out = '-' + out;
          }

          return out;
        }

        assert(false, 'Base should be between 2 and 36');
      };

      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];

        if (this.length === 2) {
          ret += this.words[1] * 0x4000000;
        } else if (this.length === 3 && this.words[2] === 0x01) {
          // NOTE: at this stage it is known that the top bit is set
          ret += 0x10000000000000 + this.words[1] * 0x4000000;
        } else if (this.length > 2) {
          assert(false, 'Number can only safely store up to 53 bits');
        }

        return this.negative !== 0 ? -ret : ret;
      };

      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };

      if (Buffer) {
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer, endian, length);
        };
      }

      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };

      var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }

        return new ArrayType(size);
      };

      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();

        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, 'byte array longer than desired length');
        assert(reqLength > 0, 'Requested array length <= 0');
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === 'le' ? 'LE' : 'BE';
        this['_toArrayLike' + postfix](res, byteLength);
        return res;
      };

      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;

        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 0xff;

          if (position < res.length) {
            res[position++] = word >> 8 & 0xff;
          }

          if (position < res.length) {
            res[position++] = word >> 16 & 0xff;
          }

          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 0xff;
            }

            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }

        if (position < res.length) {
          res[position++] = carry;

          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };

      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;

        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 0xff;

          if (position >= 0) {
            res[position--] = word >> 8 & 0xff;
          }

          if (position >= 0) {
            res[position--] = word >> 16 & 0xff;
          }

          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 0xff;
            }

            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }

        if (position >= 0) {
          res[position--] = carry;

          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };

      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;

          if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
          }

          if (t >= 0x40) {
            r += 7;
            t >>>= 7;
          }

          if (t >= 0x8) {
            r += 4;
            t >>>= 4;
          }

          if (t >= 0x02) {
            r += 2;
            t >>>= 2;
          }

          return r + t;
        };
      }

      BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;

        if ((t & 0x1fff) === 0) {
          r += 13;
          t >>>= 13;
        }

        if ((t & 0x7f) === 0) {
          r += 7;
          t >>>= 7;
        }

        if ((t & 0xf) === 0) {
          r += 4;
          t >>>= 4;
        }

        if ((t & 0x3) === 0) {
          r += 2;
          t >>>= 2;
        }

        if ((t & 0x1) === 0) {
          r++;
        }

        return r;
      }; // Return number of used bits in a BN


      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];

        var hi = this._countBits(w);

        return (this.length - 1) * 26 + hi;
      };

      function toBitArray(num) {
        var w = new Array(num.bitLength());

        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 0x01;
        }

        return w;
      } // Number of trailing zero bits


      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;

        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);

          r += b;
          if (b !== 26) break;
        }

        return r;
      };

      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };

      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }

        return this.clone();
      };

      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }

        return this.clone();
      };

      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }; // Return negative clone of `this`


      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };

      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }

        return this;
      }; // Or `num` with `this` in-place


      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }

        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }

        return this._strip();
      };

      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      }; // Or `num` with `this`


      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };

      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      }; // And `num` with `this` in-place


      BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;

        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }

        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }

        this.length = b.length;
        return this._strip();
      };

      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      }; // And `num` with `this`


      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };

      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      }; // Xor `num` with `this` in-place


      BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;

        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }

        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        this.length = a.length;
        return this._strip();
      };

      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      }; // Xor `num` with `this`


      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };

      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }; // Not ``this`` with ``width`` bitwidth


      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === 'number' && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26; // Extend the buffer with leading zeroes

        this._expand(bytesNeeded);

        if (bitsLeft > 0) {
          bytesNeeded--;
        } // Handle complete words


        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 0x3ffffff;
        } // Handle the residue


        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        } // And remove leading zeroes


        return this._strip();
      };

      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }; // Set `bit` of `this`


      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === 'number' && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;

        this._expand(off + 1);

        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }

        return this._strip();
      }; // Add `num` to `this` in-place


      BN.prototype.iadd = function iadd(num) {
        var r; // negative + positive

        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign(); // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        } // a.length > b.length


        var a, b;

        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        var carry = 0;

        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }

        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }

        this.length = a.length;

        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++; // Copy the rest of the words
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        return this;
      }; // Add `num` to `this`


      BN.prototype.add = function add(num) {
        var res;

        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }

        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      }; // Subtract `num` from `this` in-place


      BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign(); // -this - num = -(this + num)
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        } // At this point both numbers are positive


        var cmp = this.cmp(num); // Optimization - zeroify

        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        } // a > b


        var a, b;

        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        var carry = 0;

        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }

        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        } // Copy rest of the words


        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        this.length = Math.max(this.length, i);

        if (a !== this) {
          this.negative = 1;
        }

        return this._strip();
      }; // Subtract `num` from `this`


      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };

      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;

        for (var k = 1; k < len; k++) {
          // Sum all words with the same `i + j = k` and accumulate `ncarry`,
          // note that ncarry could be >= 0x3ffffff
          var ncarry = carry >>> 26;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);

          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 0x4000000 | 0;
            rword = r & 0x3ffffff;
          }

          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }

        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }

        return out._strip();
      } // TODO(indutny): it may be reasonable to omit it for users who don't need
      // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
      // multiplication (like elliptic secp256k1).


      var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */

        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */

        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */

        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */

        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */

        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */

        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */

        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */

        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */

        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */

        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */

        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */

        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */

        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */

        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */

        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */

        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */

        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */

        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */

        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;

        if (c !== 0) {
          o[19] = c;
          out.length++;
        }

        return out;
      }; // Polyfill comb


      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }

      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;

        for (var k = 0; k < out.length - 1; k++) {
          // Sum all words with the same `i + j = k` and accumulate `ncarry`,
          // note that ncarry could be >= 0x3ffffff
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);

          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 0x3ffffff;
            ncarry = ncarry + (r / 0x4000000 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 0x3ffffff;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
          }

          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }

        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }

        return out._strip();
      }

      function jumboMulTo(self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
      }

      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;

        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }

        return res;
      }; // Cooley-Tukey algorithm for FFT


      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      }; // Multiply employing FFT


      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      }; // In-place Multiplication


      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };

      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === 'number');
        assert(num < 0x4000000); // Carry

        var carry = 0;

        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
          carry >>= 26;
          carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum

          carry += lo >>> 26;
          this.words[i] = lo & 0x3ffffff;
        }

        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }

        return isNegNum ? this.ineg() : this;
      };

      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }; // `this` * `this`


      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }; // `this` * `this` in-place


      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }; // Math.pow(`this`, `num`)


      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1); // Skip leading zeroes

        var res = this;

        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }

        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }

        return res;
      }; // Shift-left in-place


      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;

        if (r !== 0) {
          var carry = 0;

          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }

          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }

        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }

          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }

          this.length += s;
        }

        return this._strip();
      };

      BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
      }; // Shift-right in-place
      // NOTE: `hint` is a lowest bit before trailing zeroes
      // NOTE: if `extended` is present - it will be filled with destroyed bits


      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        var h;

        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }

        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h); // Extended mode, copy masked part

        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }

          maskedWords.length = s;
        }

        if (s === 0) ; else if (this.length > s) {
          this.length -= s;

          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }

        var carry = 0;

        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        } // Push carried bits as a mask


        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }

        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }

        return this._strip();
      };

      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      }; // Shift-left


      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };

      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }; // Shift-right


      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };

      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }; // Test if n bit is set


      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r; // Fast case: bit is much higher than all existing words

        if (this.length <= s) return false; // Check bit and return

        var w = this.words[s];
        return !!(w & q);
      }; // Return only lowers bits of number (in-place)


      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, 'imaskn works only with positive numbers');

        if (this.length <= s) {
          return this;
        }

        if (r !== 0) {
          s++;
        }

        this.length = Math.min(s, this.length);

        if (r !== 0) {
          var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
          this.words[this.length - 1] &= mask;
        }

        return this._strip();
      }; // Return only lowers bits of number


      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }; // Add plain number `num` to `this`


      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num); // Possible sign change

        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }

          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        } // Add without checks


        return this._iaddn(num);
      };

      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num; // Carry

        for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
          this.words[i] -= 0x4000000;

          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }

        this.length = Math.max(this.length, i + 1);
        return this;
      }; // Subtract plain number `num` from `this`


      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);

        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }

        this.words[0] -= num;

        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          // Carry
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
          }
        }

        return this._strip();
      };

      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };

      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };

      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };

      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };

      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;

        this._expand(len);

        var w;
        var carry = 0;

        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 0x3ffffff;
          carry = (w >> 26) - (right / 0x4000000 | 0);
          this.words[i + shift] = w & 0x3ffffff;
        }

        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 0x3ffffff;
        }

        if (carry === 0) return this._strip(); // Subtraction overflow

        assert(carry === -1);
        carry = 0;

        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 0x3ffffff;
        }

        this.negative = 1;
        return this._strip();
      };

      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num; // Normalize

        var bhi = b.words[b.length - 1] | 0;

        var bhiBits = this._countBits(bhi);

        shift = 26 - bhiBits;

        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        } // Initialize quotient


        var m = a.length - b.length;
        var q;

        if (mode !== 'mod') {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);

          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }

        var diff = a.clone()._ishlnsubmul(b, 1, m);

        if (diff.negative === 0) {
          a = diff;

          if (q) {
            q.words[m] = 1;
          }
        }

        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
          // (0x7ffffff)

          qj = Math.min(qj / bhi | 0, 0x3ffffff);

          a._ishlnsubmul(b, qj, j);

          while (a.negative !== 0) {
            qj--;
            a.negative = 0;

            a._ishlnsubmul(b, 1, j);

            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }

          if (q) {
            q.words[j] = qj;
          }
        }

        if (q) {
          q._strip();
        }

        a._strip(); // Denormalize


        if (mode !== 'div' && shift !== 0) {
          a.iushrn(shift);
        }

        return {
          div: q || null,
          mod: a
        };
      }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
      //       to `div` to request div only, or be absent to
      //       request both div & mod
      //       2) `positive` is true if unsigned mod is requested


      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());

        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }

        var div, mod, res;

        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);

          if (mode !== 'mod') {
            div = res.div.neg();
          }

          if (mode !== 'div') {
            mod = res.mod.neg();

            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }

          return {
            div: div,
            mod: mod
          };
        }

        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);

          if (mode !== 'mod') {
            div = res.div.neg();
          }

          return {
            div: div,
            mod: res.mod
          };
        }

        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);

          if (mode !== 'div') {
            mod = res.mod.neg();

            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }

          return {
            div: res.div,
            mod: mod
          };
        } // Both numbers are positive at this point
        // Strip both numbers to approximate shift value


        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        } // Very short reduction


        if (num.length === 1) {
          if (mode === 'div') {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }

          if (mode === 'mod') {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }

          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }

        return this._wordDiv(num, mode);
      }; // Find `this` / `num`


      BN.prototype.div = function div(num) {
        return this.divmod(num, 'div', false).div;
      }; // Find `this` % `num`


      BN.prototype.mod = function mod(num) {
        return this.divmod(num, 'mod', false).mod;
      };

      BN.prototype.umod = function umod(num) {
        return this.divmod(num, 'mod', true).mod;
      }; // Find Round(`this` / `num`)


      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num); // Fast case - exact division

        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half); // Round down

        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };

      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var p = (1 << 26) % num;
        var acc = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }

        return isNegNum ? -acc : acc;
      }; // WARNING: DEPRECATED


      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      }; // In-place division by number


      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var carry = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 0x4000000;
          this.words[i] = w / num | 0;
          carry = w % num;
        }

        this._strip();

        return isNegNum ? this.ineg() : this;
      };

      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };

      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();

        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        } // A * x + B * y = x


        var A = new BN(1);
        var B = new BN(0); // C * x + D * y = y

        var C = new BN(0);
        var D = new BN(1);
        var g = 0;

        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }

        var yp = y.clone();
        var xp = x.clone();

        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

          if (i > 0) {
            x.iushrn(i);

            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }

              A.iushrn(1);
              B.iushrn(1);
            }
          }

          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

          if (j > 0) {
            y.iushrn(j);

            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }

              C.iushrn(1);
              D.iushrn(1);
            }
          }

          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }

        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      }; // This is reduced incarnation of the binary EEA
      // above, designated to invert members of the
      // _prime_ fields F(p) at a maximal speed


      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();

        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }

        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();

        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

          if (i > 0) {
            a.iushrn(i);

            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }

              x1.iushrn(1);
            }
          }

          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

          if (j > 0) {
            b.iushrn(j);

            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }

              x2.iushrn(1);
            }
          }

          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }

        var res;

        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }

        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }

        return res;
      };

      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0; // Remove common factor of two

        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }

        do {
          while (a.isEven()) {
            a.iushrn(1);
          }

          while (b.isEven()) {
            b.iushrn(1);
          }

          var r = a.cmp(b);

          if (r < 0) {
            // Swap `a` and `b` to make `a` always bigger than `b`
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }

          a.isub(b);
        } while (true);

        return b.iushln(shift);
      }; // Invert number in the field F(num)


      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };

      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };

      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }; // And first word and num


      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }; // Increment at the bit position in-line


      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r; // Fast case: bit is much higher than all existing words

        if (this.length <= s) {
          this._expand(s + 1);

          this.words[s] |= q;
          return this;
        } // Add bit and propagate, if needed


        var carry = q;

        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 0x3ffffff;
          this.words[i] = w;
        }

        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }

        return this;
      };

      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };

      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;

        this._strip();

        var res;

        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }

          assert(num <= 0x3ffffff, 'Number is too big');
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }

        if (this.negative !== 0) return -res | 0;
        return res;
      }; // Compare two numbers and return:
      // 1 - if `this` > `num`
      // 0 - if `this` == `num`
      // -1 - if `this` < `num`


      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      }; // Unsigned comparison


      BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;

          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }

          break;
        }

        return res;
      };

      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };

      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };

      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };

      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };

      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };

      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };

      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };

      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };

      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };

      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }; //
      // A reduce context, could be using montgomery or something better, depending
      // on the `m` itself.
      //


      BN.red = function red(num) {
        return new Red(num);
      };

      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(this.negative === 0, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
      };

      BN.prototype.fromRed = function fromRed() {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
      };

      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };

      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
      };

      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
      };

      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
      };

      BN.prototype.redSub = function redSub(num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
      };

      BN.prototype.redISub = function redISub(num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
      };

      BN.prototype.redShl = function redShl(num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
      };

      BN.prototype.redMul = function redMul(num) {
        assert(this.red, 'redMul works only with red numbers');

        this.red._verify2(this, num);

        return this.red.mul(this, num);
      };

      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, 'redMul works only with red numbers');

        this.red._verify2(this, num);

        return this.red.imul(this, num);
      };

      BN.prototype.redSqr = function redSqr() {
        assert(this.red, 'redSqr works only with red numbers');

        this.red._verify1(this);

        return this.red.sqr(this);
      };

      BN.prototype.redISqr = function redISqr() {
        assert(this.red, 'redISqr works only with red numbers');

        this.red._verify1(this);

        return this.red.isqr(this);
      }; // Square root over p


      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, 'redSqrt works only with red numbers');

        this.red._verify1(this);

        return this.red.sqrt(this);
      };

      BN.prototype.redInvm = function redInvm() {
        assert(this.red, 'redInvm works only with red numbers');

        this.red._verify1(this);

        return this.red.invm(this);
      }; // Return negative clone of `this` % `red modulo`


      BN.prototype.redNeg = function redNeg() {
        assert(this.red, 'redNeg works only with red numbers');

        this.red._verify1(this);

        return this.red.neg(this);
      };

      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, 'redPow(normalNum)');

        this.red._verify1(this);

        return this.red.pow(this, num);
      }; // Prime numbers with efficient reduction


      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      }; // Pseudo-Mersenne prime

      function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }

      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };

      MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;

        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);

        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);

        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== undefined) {
            // r is a BN v4 instance
            r.strip();
          } else {
            // r is a BN v5 instance
            r._strip();
          }
        }

        return r;
      };

      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };

      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };

      function K256() {
        MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
      }

      inherits(K256, MPrime);

      K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);

        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }

        output.length = outLen;

        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        } // Shift by 9 limbs


        var prev = input.words[9];
        output.words[output.length++] = prev & mask;

        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }

        prev >>>= 22;
        input.words[i - 10] = prev;

        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };

      K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

        var lo = 0;

        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 0x3d1;
          num.words[i] = lo & 0x3ffffff;
          lo = w * 0x40 + (lo / 0x4000000 | 0);
        } // Fast length reduction


        if (num.words[num.length - 1] === 0) {
          num.length--;

          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }

        return num;
      };

      function P224() {
        MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
      }

      inherits(P224, MPrime);

      function P192() {
        MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
      }

      inherits(P192, MPrime);

      function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
      }

      inherits(P25519, MPrime);

      P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;

        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 0x13 + carry;
          var lo = hi & 0x3ffffff;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }

        if (carry !== 0) {
          num.words[num.length++] = carry;
        }

        return num;
      }; // Exported mostly for testing purposes, use plain name instead


      BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;

        if (name === 'k256') {
          prime = new K256();
        } else if (name === 'p224') {
          prime = new P224();
        } else if (name === 'p192') {
          prime = new P192();
        } else if (name === 'p25519') {
          prime = new P25519();
        } else {
          throw new Error('Unknown prime ' + name);
        }

        primes[name] = prime;
        return prime;
      }; //
      // Base reduction engine
      //


      function Red(m) {
        if (typeof m === 'string') {
          var prime = BN._prime(m);

          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), 'modulus must be greater than 1');
          this.m = m;
          this.prime = null;
        }
      }

      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
      };

      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, 'red works only with positives');
        assert(a.red && a.red === b.red, 'red works only with red numbers');
      };

      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };

      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }

        return this.m.sub(a)._forceRed(this);
      };

      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);

        var res = a.add(b);

        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }

        return res._forceRed(this);
      };

      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);

        var res = a.iadd(b);

        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }

        return res;
      };

      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);

        var res = a.sub(b);

        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);

        var res = a.isub(b);

        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }

        return res;
      };

      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);

        return this.imod(a.ushln(num));
      };

      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);

        return this.imod(a.imul(b));
      };

      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);

        return this.imod(a.mul(b));
      };

      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };

      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };

      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1); // Fast case

        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)


        var q = this.m.subn(1);
        var s = 0;

        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }

        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg(); // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.

        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);

        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }

        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;

        while (t.cmp(one) !== 0) {
          var tmp = t;

          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }

          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }

        return r;
      };

      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);

        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };

      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;

        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }

        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;

        if (start === 0) {
          start = 26;
        }

        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];

          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;

            if (res !== wnd[0]) {
              res = this.sqr(res);
            }

            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }

            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }

          start = 26;
        }

        return res;
      };

      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };

      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      }; //
      // Montgomery method engine
      //


      BN.mont = function mont(num) {
        return new Mont(num);
      };

      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();

        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }

        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }

      inherits(Mont, Red);

      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };

      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };

      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }

        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;

        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;

        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, commonjsGlobal);
  })(bn$1);

  var BN$1 = bn$1.exports;

  function number$1(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error("Wrong positive integer: ".concat(n));
  }
  function bool(b) {
    if (typeof b !== 'boolean') throw new Error("Expected boolean, not ".concat(b));
  }
  function bytes(b) {
    if (!(b instanceof Uint8Array)) throw new TypeError('Expected Uint8Array');

    for (var _len = arguments.length, lengths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      lengths[_key - 1] = arguments[_key];
    }

    if (lengths.length > 0 && !lengths.includes(b.length)) throw new TypeError("Expected Uint8Array of length ".concat(lengths, ", not of length=").concat(b.length));
  }
  function hash(hash) {
    if (typeof hash !== 'function' || typeof hash.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
    number$1(hash.outputLen);
    number$1(hash.blockLen);
  }
  function exists(instance) {
    var checkFinished = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
  }
  function output(out, instance) {
    bytes(out);
    var min = instance.outputLen;

    if (out.length < min) {
      throw new Error("digestInto() expects output buffer of length at least ".concat(min));
    }
  }
  var assert$1 = {
    number: number$1,
    bool: bool,
    bytes: bytes,
    hash: hash,
    exists: exists,
    output: output
  };
  var assert$2 = assert$1;

  var u32$1 = function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  }; // Cast array to view

  var createView = function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  }; // The rotate right (circular right shift) operation for uint32

  var rotr = function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
  }; // big-endian hardware is rare. Just in case someone still decides to run hashes:
  // early-throw an error because we don't support BE yet.

  var isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;
  if (!isLE) throw new Error('Non little-endian hardware is not supported');
  Array.from({
    length: 256
  }, function (v, i) {
    return i.toString(16).padStart(2, '0');
  });

  function utf8ToBytes(str) {
    if (typeof str !== 'string') {
      throw new TypeError("utf8ToBytes expected string, got ".concat(_typeof$1(str)));
    }

    return new TextEncoder().encode(str);
  }
  function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array)) throw new TypeError("Expected input type is Uint8Array (got ".concat(_typeof$1(data), ")"));
    return data;
  }

  var Hash = /*#__PURE__*/function () {
    function Hash() {
      _classCallCheck(this, Hash);
    }

    _createClass(Hash, [{
      key: "clone",
      value: // Safe version that clones internal state
      function clone() {
        return this._cloneInto();
      }
    }]);

    return Hash;
  }(); // Check if object doens't have custom constructor (like Uint8Array/Array)
  function wrapConstructor(hashConstructor) {
    var hashC = function hashC(message) {
      return hashConstructor().update(toBytes(message)).digest();
    };

    var tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;

    hashC.create = function () {
      return hashConstructor();
    };

    return hashC;
  }
  function wrapConstructorWithOpts(hashCons) {
    var hashC = function hashC(msg, opts) {
      return hashCons(opts).update(toBytes(msg)).digest();
    };

    var tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;

    hashC.create = function (opts) {
      return hashCons(opts);
    };

    return hashC;
  }

  function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);

    var _32n = BigInt(32);

    var _u32_max = BigInt(0xffffffff);

    var wh = Number(value >> _32n & _u32_max);
    var wl = Number(value & _u32_max);
    var h = isLE ? 4 : 0;
    var l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
  } // Base SHA2 class (RFC 6234)


  var SHA2 = /*#__PURE__*/function (_Hash) {
    _inherits(SHA2, _Hash);

    var _super = _createSuper(SHA2);

    function SHA2(blockLen, outputLen, padOffset, isLE) {
      var _this;

      _classCallCheck(this, SHA2);

      _this = _super.call(this);
      _this.blockLen = blockLen;
      _this.outputLen = outputLen;
      _this.padOffset = padOffset;
      _this.isLE = isLE;
      _this.finished = false;
      _this.length = 0;
      _this.pos = 0;
      _this.destroyed = false;
      _this.buffer = new Uint8Array(blockLen);
      _this.view = createView(_this.buffer);
      return _this;
    }

    _createClass(SHA2, [{
      key: "update",
      value: function update(data) {
        assert$2.exists(this);
        var view = this.view,
            buffer = this.buffer,
            blockLen = this.blockLen;
        data = toBytes(data);
        var len = data.length;

        for (var pos = 0; pos < len;) {
          var take = Math.min(blockLen - this.pos, len - pos); // Fast path: we have at least one block in input, cast it to view and process

          if (take === blockLen) {
            var dataView = createView(data);

            for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);

            continue;
          }

          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;

          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }

        this.length += data.length;
        this.roundClean();
        return this;
      }
    }, {
      key: "digestInto",
      value: function digestInto(out) {
        assert$2.exists(this);
        assert$2.output(out, this);
        this.finished = true; // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.

        var buffer = this.buffer,
            view = this.view,
            blockLen = this.blockLen,
            isLE = this.isLE;
        var pos = this.pos; // append the bit '1' to the message

        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0); // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again

        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        } // Pad until full block byte with zeros


        for (var i = pos; i < blockLen; i++) buffer[i] = 0; // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.


        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        var oview = createView(out);
        var len = this.outputLen; // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT

        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        var outLen = len / 4;
        var state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');

        for (var _i2 = 0; _i2 < outLen; _i2++) oview.setUint32(4 * _i2, state[_i2], isLE);
      }
    }, {
      key: "digest",
      value: function digest() {
        var buffer = this.buffer,
            outputLen = this.outputLen;
        this.digestInto(buffer);
        var res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
    }, {
      key: "_cloneInto",
      value: function _cloneInto(to) {
        var _to;

        to || (to = new this.constructor());

        (_to = to).set.apply(_to, _toConsumableArray(this.get()));

        var blockLen = this.blockLen,
            buffer = this.buffer,
            length = this.length,
            finished = this.finished,
            destroyed = this.destroyed,
            pos = this.pos;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
      }
    }]);

    return SHA2;
  }(Hash);

  var U32_MASK64 = BigInt(Math.pow(2, 32) - 1);

  var _32n = BigInt(32); // We are not using BigUint64Array, because they are extremely slow as per 2022


  function fromBig(n) {
    var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (le) return {
      h: Number(n & U32_MASK64),
      l: Number(n >> _32n & U32_MASK64)
    };
    return {
      h: Number(n >> _32n & U32_MASK64) | 0,
      l: Number(n & U32_MASK64) | 0
    };
  }
  function split(lst) {
    var le = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var Ah = new Uint32Array(lst.length);
    var Al = new Uint32Array(lst.length);

    for (var i = 0; i < lst.length; i++) {
      var _fromBig2 = fromBig(lst[i], le),
          h = _fromBig2.h,
          l = _fromBig2.l;

      var _ref = [h, l];
      Ah[i] = _ref[0];
      Al[i] = _ref[1];
    }

    return [Ah, Al];
  }
  var toBig = function toBig(h, l) {
    return BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  }; // for Shift in [0, 32)

  var shrSH = function shrSH(h, l, s) {
    return h >>> s;
  };

  var shrSL = function shrSL(h, l, s) {
    return h << 32 - s | l >>> s;
  }; // Right rotate for Shift in [1, 32)


  var rotrSH = function rotrSH(h, l, s) {
    return h >>> s | l << 32 - s;
  };

  var rotrSL = function rotrSL(h, l, s) {
    return h << 32 - s | l >>> s;
  }; // Right rotate for Shift in (32, 64), NOTE: 32 is special case.


  var rotrBH = function rotrBH(h, l, s) {
    return h << 64 - s | l >>> s - 32;
  };

  var rotrBL = function rotrBL(h, l, s) {
    return h >>> s - 32 | l << 64 - s;
  }; // Right rotate for shift===32 (just swaps l&h)


  var rotr32H = function rotr32H(h, l) {
    return l;
  };

  var rotr32L = function rotr32L(h, l) {
    return h;
  }; // Left rotate for Shift in [1, 32)


  var rotlSH = function rotlSH(h, l, s) {
    return h << s | l >>> 32 - s;
  };

  var rotlSL = function rotlSL(h, l, s) {
    return l << s | h >>> 32 - s;
  }; // Left rotate for Shift in (32, 64), NOTE: 32 is special case.


  var rotlBH = function rotlBH(h, l, s) {
    return l << s - 32 | h >>> 64 - s;
  };

  var rotlBL = function rotlBL(h, l, s) {
    return h << s - 32 | l >>> 64 - s;
  }; // JS uses 32-bit signed integers for bitwise operations which means we cannot
  // simple take carry out of low bit sum by shift, we need to use division.
  // Removing "export" has 5% perf penalty -_-


  function add(Ah, Al, Bh, Bl) {
    var l = (Al >>> 0) + (Bl >>> 0);
    return {
      h: Ah + Bh + (l / Math.pow(2, 32) | 0) | 0,
      l: l | 0
    };
  } // Addition with more than 2 elements

  var add3L = function add3L(Al, Bl, Cl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  };

  var add3H = function add3H(low, Ah, Bh, Ch) {
    return Ah + Bh + Ch + (low / Math.pow(2, 32) | 0) | 0;
  };

  var add4L = function add4L(Al, Bl, Cl, Dl) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  };

  var add4H = function add4H(low, Ah, Bh, Ch, Dh) {
    return Ah + Bh + Ch + Dh + (low / Math.pow(2, 32) | 0) | 0;
  };

  var add5L = function add5L(Al, Bl, Cl, Dl, El) {
    return (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  };

  var add5H = function add5H(low, Ah, Bh, Ch, Dh, Eh) {
    return Ah + Bh + Ch + Dh + Eh + (low / Math.pow(2, 32) | 0) | 0;
  }; // prettier-ignore


  var u64$1 = {
    fromBig: fromBig,
    split: split,
    toBig: toBig,
    shrSH: shrSH,
    shrSL: shrSL,
    rotrSH: rotrSH,
    rotrSL: rotrSL,
    rotrBH: rotrBH,
    rotrBL: rotrBL,
    rotr32H: rotr32H,
    rotr32L: rotr32L,
    rotlSH: rotlSH,
    rotlSL: rotlSL,
    rotlBH: rotlBH,
    rotlBL: rotlBL,
    add: add,
    add3L: add3L,
    add3H: add3H,
    add4L: add4L,
    add4H: add4H,
    add5H: add5H,
    add5L: add5L
  };
  var u64$2 = u64$1;

  // prettier-ignore

  var _u64$split$1 = u64$2.split(['0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc', '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118', '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2', '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694', '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65', '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5', '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4', '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70', '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df', '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b', '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30', '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8', '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8', '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3', '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec', '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b', '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178', '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b', '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c', '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'].map(function (n) {
    return BigInt(n);
  })),
      _u64$split2$1 = _slicedToArray(_u64$split$1, 2),
      SHA512_Kh = _u64$split2$1[0],
      SHA512_Kl = _u64$split2$1[1]; // Temporary buffer, not used to store anything between runs


  var SHA512_W_H = new Uint32Array(80);
  var SHA512_W_L = new Uint32Array(80);
  var SHA512 = /*#__PURE__*/function (_SHA) {
    _inherits(SHA512, _SHA);

    var _super = _createSuper(SHA512);

    function SHA512() {
      var _this;

      _classCallCheck(this, SHA512);

      _this = _super.call(this, 128, 64, 16, false); // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.
      // Also looks cleaner and easier to verify with spec.
      // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
      // h -- high 32 bits, l -- low 32 bits

      _this.Ah = 0x6a09e667 | 0;
      _this.Al = 0xf3bcc908 | 0;
      _this.Bh = 0xbb67ae85 | 0;
      _this.Bl = 0x84caa73b | 0;
      _this.Ch = 0x3c6ef372 | 0;
      _this.Cl = 0xfe94f82b | 0;
      _this.Dh = 0xa54ff53a | 0;
      _this.Dl = 0x5f1d36f1 | 0;
      _this.Eh = 0x510e527f | 0;
      _this.El = 0xade682d1 | 0;
      _this.Fh = 0x9b05688c | 0;
      _this.Fl = 0x2b3e6c1f | 0;
      _this.Gh = 0x1f83d9ab | 0;
      _this.Gl = 0xfb41bd6b | 0;
      _this.Hh = 0x5be0cd19 | 0;
      _this.Hl = 0x137e2179 | 0;
      return _this;
    } // prettier-ignore


    _createClass(SHA512, [{
      key: "get",
      value: function get() {
        var Ah = this.Ah,
            Al = this.Al,
            Bh = this.Bh,
            Bl = this.Bl,
            Ch = this.Ch,
            Cl = this.Cl,
            Dh = this.Dh,
            Dl = this.Dl,
            Eh = this.Eh,
            El = this.El,
            Fh = this.Fh,
            Fl = this.Fl,
            Gh = this.Gh,
            Gl = this.Gl,
            Hh = this.Hh,
            Hl = this.Hl;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      } // prettier-ignore

    }, {
      key: "set",
      value: function set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
    }, {
      key: "process",
      value: function process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for (var i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }

        for (var _i2 = 16; _i2 < 80; _i2++) {
          // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
          var W15h = SHA512_W_H[_i2 - 15] | 0;
          var W15l = SHA512_W_L[_i2 - 15] | 0;
          var s0h = u64$2.rotrSH(W15h, W15l, 1) ^ u64$2.rotrSH(W15h, W15l, 8) ^ u64$2.shrSH(W15h, W15l, 7);
          var s0l = u64$2.rotrSL(W15h, W15l, 1) ^ u64$2.rotrSL(W15h, W15l, 8) ^ u64$2.shrSL(W15h, W15l, 7); // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)

          var W2h = SHA512_W_H[_i2 - 2] | 0;
          var W2l = SHA512_W_L[_i2 - 2] | 0;
          var s1h = u64$2.rotrSH(W2h, W2l, 19) ^ u64$2.rotrBH(W2h, W2l, 61) ^ u64$2.shrSH(W2h, W2l, 6);
          var s1l = u64$2.rotrSL(W2h, W2l, 19) ^ u64$2.rotrBL(W2h, W2l, 61) ^ u64$2.shrSL(W2h, W2l, 6); // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];

          var SUMl = u64$2.add4L(s0l, s1l, SHA512_W_L[_i2 - 7], SHA512_W_L[_i2 - 16]);
          var SUMh = u64$2.add4H(SUMl, s0h, s1h, SHA512_W_H[_i2 - 7], SHA512_W_H[_i2 - 16]);
          SHA512_W_H[_i2] = SUMh | 0;
          SHA512_W_L[_i2] = SUMl | 0;
        }

        var Ah = this.Ah,
            Al = this.Al,
            Bh = this.Bh,
            Bl = this.Bl,
            Ch = this.Ch,
            Cl = this.Cl,
            Dh = this.Dh,
            Dl = this.Dl,
            Eh = this.Eh,
            El = this.El,
            Fh = this.Fh,
            Fl = this.Fl,
            Gh = this.Gh,
            Gl = this.Gl,
            Hh = this.Hh,
            Hl = this.Hl; // Compression function main loop, 80 rounds

        for (var _i4 = 0; _i4 < 80; _i4++) {
          // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
          var sigma1h = u64$2.rotrSH(Eh, El, 14) ^ u64$2.rotrSH(Eh, El, 18) ^ u64$2.rotrBH(Eh, El, 41);
          var sigma1l = u64$2.rotrSL(Eh, El, 14) ^ u64$2.rotrSL(Eh, El, 18) ^ u64$2.rotrBL(Eh, El, 41); //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;

          var CHIh = Eh & Fh ^ ~Eh & Gh;
          var CHIl = El & Fl ^ ~El & Gl; // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
          // prettier-ignore

          var T1ll = u64$2.add5L(Hl, sigma1l, CHIl, SHA512_Kl[_i4], SHA512_W_L[_i4]);
          var T1h = u64$2.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[_i4], SHA512_W_H[_i4]);
          var T1l = T1ll | 0; // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)

          var sigma0h = u64$2.rotrSH(Ah, Al, 28) ^ u64$2.rotrBH(Ah, Al, 34) ^ u64$2.rotrBH(Ah, Al, 39);
          var sigma0l = u64$2.rotrSL(Ah, Al, 28) ^ u64$2.rotrBL(Ah, Al, 34) ^ u64$2.rotrBL(Ah, Al, 39);
          var MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          var MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;

          var _u64$add = u64$2.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0);

          Eh = _u64$add.h;
          El = _u64$add.l;
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          var All = u64$2.add3L(T1l, sigma0l, MAJl);
          Ah = u64$2.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        } // Add the compressed chunk to the current hash value


        var _u64$add2 = u64$2.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0);

        Ah = _u64$add2.h;
        Al = _u64$add2.l;

        var _u64$add3 = u64$2.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0);

        Bh = _u64$add3.h;
        Bl = _u64$add3.l;

        var _u64$add4 = u64$2.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0);

        Ch = _u64$add4.h;
        Cl = _u64$add4.l;

        var _u64$add5 = u64$2.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0);

        Dh = _u64$add5.h;
        Dl = _u64$add5.l;

        var _u64$add6 = u64$2.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0);

        Eh = _u64$add6.h;
        El = _u64$add6.l;

        var _u64$add7 = u64$2.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0);

        Fh = _u64$add7.h;
        Fl = _u64$add7.l;

        var _u64$add8 = u64$2.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0);

        Gh = _u64$add8.h;
        Gl = _u64$add8.l;

        var _u64$add9 = u64$2.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0);

        Hh = _u64$add9.h;
        Hl = _u64$add9.l;
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
    }, {
      key: "roundClean",
      value: function roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    }]);

    return SHA512;
  }(SHA2);

  var SHA512_224 = /*#__PURE__*/function (_SHA2) {
    _inherits(SHA512_224, _SHA2);

    var _super2 = _createSuper(SHA512_224);

    function SHA512_224() {
      var _this2;

      _classCallCheck(this, SHA512_224);

      _this2 = _super2.call(this); // h -- high 32 bits, l -- low 32 bits

      _this2.Ah = 0x8c3d37c8 | 0;
      _this2.Al = 0x19544da2 | 0;
      _this2.Bh = 0x73e19966 | 0;
      _this2.Bl = 0x89dcd4d6 | 0;
      _this2.Ch = 0x1dfab7ae | 0;
      _this2.Cl = 0x32ff9c82 | 0;
      _this2.Dh = 0x679dd514 | 0;
      _this2.Dl = 0x582f9fcf | 0;
      _this2.Eh = 0x0f6d2b69 | 0;
      _this2.El = 0x7bd44da8 | 0;
      _this2.Fh = 0x77e36f73 | 0;
      _this2.Fl = 0x04c48942 | 0;
      _this2.Gh = 0x3f9d85a8 | 0;
      _this2.Gl = 0x6a1d36c8 | 0;
      _this2.Hh = 0x1112e6ad | 0;
      _this2.Hl = 0x91d692a1 | 0;
      _this2.outputLen = 28;
      return _this2;
    }

    return _createClass(SHA512_224);
  }(SHA512);

  var SHA512_256 = /*#__PURE__*/function (_SHA3) {
    _inherits(SHA512_256, _SHA3);

    var _super3 = _createSuper(SHA512_256);

    function SHA512_256() {
      var _this3;

      _classCallCheck(this, SHA512_256);

      _this3 = _super3.call(this); // h -- high 32 bits, l -- low 32 bits

      _this3.Ah = 0x22312194 | 0;
      _this3.Al = 0xfc2bf72c | 0;
      _this3.Bh = 0x9f555fa3 | 0;
      _this3.Bl = 0xc84c64c2 | 0;
      _this3.Ch = 0x2393b86b | 0;
      _this3.Cl = 0x6f53b151 | 0;
      _this3.Dh = 0x96387719 | 0;
      _this3.Dl = 0x5940eabd | 0;
      _this3.Eh = 0x96283ee2 | 0;
      _this3.El = 0xa88effe3 | 0;
      _this3.Fh = 0xbe5e1e25 | 0;
      _this3.Fl = 0x53863992 | 0;
      _this3.Gh = 0x2b0199fc | 0;
      _this3.Gl = 0x2c85b8aa | 0;
      _this3.Hh = 0x0eb72ddc | 0;
      _this3.Hl = 0x81c52ca2 | 0;
      _this3.outputLen = 32;
      return _this3;
    }

    return _createClass(SHA512_256);
  }(SHA512);

  var SHA384 = /*#__PURE__*/function (_SHA4) {
    _inherits(SHA384, _SHA4);

    var _super4 = _createSuper(SHA384);

    function SHA384() {
      var _this4;

      _classCallCheck(this, SHA384);

      _this4 = _super4.call(this); // h -- high 32 bits, l -- low 32 bits

      _this4.Ah = 0xcbbb9d5d | 0;
      _this4.Al = 0xc1059ed8 | 0;
      _this4.Bh = 0x629a292a | 0;
      _this4.Bl = 0x367cd507 | 0;
      _this4.Ch = 0x9159015a | 0;
      _this4.Cl = 0x3070dd17 | 0;
      _this4.Dh = 0x152fecd8 | 0;
      _this4.Dl = 0xf70e5939 | 0;
      _this4.Eh = 0x67332667 | 0;
      _this4.El = 0xffc00b31 | 0;
      _this4.Fh = 0x8eb44a87 | 0;
      _this4.Fl = 0x68581511 | 0;
      _this4.Gh = 0xdb0c2e0d | 0;
      _this4.Gl = 0x64f98fa7 | 0;
      _this4.Hh = 0x47b5481d | 0;
      _this4.Hl = 0xbefa4fa4 | 0;
      _this4.outputLen = 48;
      return _this4;
    }

    return _createClass(SHA384);
  }(SHA512);

  var sha512 = wrapConstructor(function () {
    return new SHA512();
  });
  wrapConstructor(function () {
    return new SHA512_224();
  });
  wrapConstructor(function () {
    return new SHA512_256();
  });
  wrapConstructor(function () {
    return new SHA384();
  });

  var _polyfillNode_crypto = {};

  var nodeCrypto = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	'default': _polyfillNode_crypto
  });

  var _0n$2 = BigInt(0);

  var _1n$2 = BigInt(1);

  var _2n$2 = BigInt(2);

  var _8n$1 = BigInt(8);

  var CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');
  var CURVE$1 = Object.freeze({
    a: BigInt(-1),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),
    l: CU_O,
    n: CU_O,
    h: BigInt(8),
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960')
  });
  var POW_2_256$1 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
  var SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
  BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');
  var SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
  var INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
  var ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
  var D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');

  var ExtendedPoint = /*#__PURE__*/function () {
    function ExtendedPoint(x, y, z, t) {
      _classCallCheck(this, ExtendedPoint);

      this.x = x;
      this.y = y;
      this.z = z;
      this.t = t;
    }

    _createClass(ExtendedPoint, [{
      key: "equals",
      value: function equals(other) {
        assertExtPoint(other);
        var X1 = this.x,
            Y1 = this.y,
            Z1 = this.z;
        var X2 = other.x,
            Y2 = other.y,
            Z2 = other.z;
        var X1Z2 = mod$1(X1 * Z2);
        var X2Z1 = mod$1(X2 * Z1);
        var Y1Z2 = mod$1(Y1 * Z2);
        var Y2Z1 = mod$1(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
      }
    }, {
      key: "negate",
      value: function negate() {
        return new ExtendedPoint(mod$1(-this.x), this.y, this.z, mod$1(-this.t));
      }
    }, {
      key: "double",
      value: function double() {
        var X1 = this.x,
            Y1 = this.y,
            Z1 = this.z;
        var a = CURVE$1.a;
        var A = mod$1(X1 * X1);
        var B = mod$1(Y1 * Y1);
        var C = mod$1(_2n$2 * mod$1(Z1 * Z1));
        var D = mod$1(a * A);
        var x1y1 = X1 + Y1;
        var E = mod$1(mod$1(x1y1 * x1y1) - A - B);
        var G = D + B;
        var F = G - C;
        var H = D - B;
        var X3 = mod$1(E * F);
        var Y3 = mod$1(G * H);
        var T3 = mod$1(E * H);
        var Z3 = mod$1(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
      }
    }, {
      key: "add",
      value: function add(other) {
        assertExtPoint(other);
        var X1 = this.x,
            Y1 = this.y,
            Z1 = this.z,
            T1 = this.t;
        var X2 = other.x,
            Y2 = other.y,
            Z2 = other.z,
            T2 = other.t;
        var A = mod$1((Y1 - X1) * (Y2 + X2));
        var B = mod$1((Y1 + X1) * (Y2 - X2));
        var F = mod$1(B - A);
        if (F === _0n$2) return this["double"]();
        var C = mod$1(Z1 * _2n$2 * T2);
        var D = mod$1(T1 * _2n$2 * Z2);
        var E = D + C;
        var G = B + A;
        var H = D - C;
        var X3 = mod$1(E * F);
        var Y3 = mod$1(G * H);
        var T3 = mod$1(E * H);
        var Z3 = mod$1(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
      }
    }, {
      key: "subtract",
      value: function subtract(other) {
        return this.add(other.negate());
      }
    }, {
      key: "precomputeWindow",
      value: function precomputeWindow(W) {
        var windows = 1 + 256 / W;
        var points = [];
        var p = this;
        var base = p;

        for (var window = 0; window < windows; window++) {
          base = p;
          points.push(base);

          for (var i = 1; i < Math.pow(2, W - 1); i++) {
            base = base.add(p);
            points.push(base);
          }

          p = base["double"]();
        }

        return points;
      }
    }, {
      key: "wNAF",
      value: function wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(ExtendedPoint.BASE)) affinePoint = Point$1.BASE;
        var W = affinePoint && affinePoint._WINDOW_SIZE || 1;

        if (256 % W) {
          throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
        }

        var precomputes = affinePoint && pointPrecomputes$1.get(affinePoint);

        if (!precomputes) {
          precomputes = this.precomputeWindow(W);

          if (affinePoint && W !== 1) {
            precomputes = ExtendedPoint.normalizeZ(precomputes);
            pointPrecomputes$1.set(affinePoint, precomputes);
          }
        }

        var p = ExtendedPoint.ZERO;
        var f = ExtendedPoint.BASE;
        var windows = 1 + 256 / W;
        var windowSize = Math.pow(2, W - 1);
        var mask = BigInt(Math.pow(2, W) - 1);
        var maxNumber = Math.pow(2, W);
        var shiftBy = BigInt(W);

        for (var window = 0; window < windows; window++) {
          var offset = window * windowSize;
          var wbits = Number(n & mask);
          n >>= shiftBy;

          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n$2;
          }

          var offset1 = offset;
          var offset2 = offset + Math.abs(wbits) - 1;
          var cond1 = window % 2 !== 0;
          var cond2 = wbits < 0;

          if (wbits === 0) {
            f = f.add(constTimeNegate$1(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate$1(cond2, precomputes[offset2]));
          }
        }

        return ExtendedPoint.normalizeZ([p, f])[0];
      }
    }, {
      key: "multiply",
      value: function multiply(scalar, affinePoint) {
        return this.wNAF(normalizeScalar$1(scalar, CURVE$1.l), affinePoint);
      }
    }, {
      key: "multiplyUnsafe",
      value: function multiplyUnsafe(scalar) {
        var n = normalizeScalar$1(scalar, CURVE$1.l, false);
        var G = ExtendedPoint.BASE;
        var P0 = ExtendedPoint.ZERO;
        if (n === _0n$2) return P0;
        if (this.equals(P0) || n === _1n$2) return this;
        if (this.equals(G)) return this.wNAF(n);
        var p = P0;
        var d = this;

        while (n > _0n$2) {
          if (n & _1n$2) p = p.add(d);
          d = d["double"]();
          n >>= _1n$2;
        }

        return p;
      }
    }, {
      key: "isSmallOrder",
      value: function isSmallOrder() {
        return this.multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO);
      }
    }, {
      key: "isTorsionFree",
      value: function isTorsionFree() {
        var p = this.multiplyUnsafe(CURVE$1.l / _2n$2)["double"]();
        if (CURVE$1.l % _2n$2) p = p.add(this);
        return p.equals(ExtendedPoint.ZERO);
      }
    }, {
      key: "toAffine",
      value: function toAffine(invZ) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var is0 = this.equals(ExtendedPoint.ZERO);
        if (invZ == null) invZ = is0 ? _8n$1 : invert$1(z);
        var ax = mod$1(x * invZ);
        var ay = mod$1(y * invZ);
        var zz = mod$1(z * invZ);
        if (is0) return Point$1.ZERO;
        if (zz !== _1n$2) throw new Error('invZ was invalid');
        return new Point$1(ax, ay);
      }
    }, {
      key: "fromRistrettoBytes",
      value: function fromRistrettoBytes() {
        legacyRist();
      }
    }, {
      key: "toRistrettoBytes",
      value: function toRistrettoBytes() {
        legacyRist();
      }
    }, {
      key: "fromRistrettoHash",
      value: function fromRistrettoHash() {
        legacyRist();
      }
    }], [{
      key: "fromAffine",
      value: function fromAffine(p) {
        if (!(p instanceof Point$1)) {
          throw new TypeError('ExtendedPoint#fromAffine: expected Point');
        }

        if (p.equals(Point$1.ZERO)) return ExtendedPoint.ZERO;
        return new ExtendedPoint(p.x, p.y, _1n$2, mod$1(p.x * p.y));
      }
    }, {
      key: "toAffineBatch",
      value: function toAffineBatch(points) {
        var toInv = invertBatch$1(points.map(function (p) {
          return p.z;
        }));
        return points.map(function (p, i) {
          return p.toAffine(toInv[i]);
        });
      }
    }, {
      key: "normalizeZ",
      value: function normalizeZ(points) {
        return this.toAffineBatch(points).map(this.fromAffine);
      }
    }]);

    return ExtendedPoint;
  }();

  ExtendedPoint.BASE = new ExtendedPoint(CURVE$1.Gx, CURVE$1.Gy, _1n$2, mod$1(CURVE$1.Gx * CURVE$1.Gy));
  ExtendedPoint.ZERO = new ExtendedPoint(_0n$2, _1n$2, _1n$2, _0n$2);

  function constTimeNegate$1(condition, item) {
    var neg = item.negate();
    return condition ? neg : item;
  }

  function assertExtPoint(other) {
    if (!(other instanceof ExtendedPoint)) throw new TypeError('ExtendedPoint expected');
  }

  function assertRstPoint(other) {
    if (!(other instanceof RistrettoPoint)) throw new TypeError('RistrettoPoint expected');
  }

  function legacyRist() {
    throw new Error('Legacy method: switch to RistrettoPoint');
  }

  var RistrettoPoint = /*#__PURE__*/function () {
    function RistrettoPoint(ep) {
      _classCallCheck(this, RistrettoPoint);

      this.ep = ep;
    }

    _createClass(RistrettoPoint, [{
      key: "toRawBytes",
      value: function toRawBytes() {
        var _this$ep = this.ep,
            x = _this$ep.x,
            y = _this$ep.y,
            z = _this$ep.z,
            t = _this$ep.t;
        var u1 = mod$1(mod$1(z + y) * mod$1(z - y));
        var u2 = mod$1(x * y);
        var u2sq = mod$1(u2 * u2);

        var _invertSqrt = invertSqrt(mod$1(u1 * u2sq)),
            invsqrt = _invertSqrt.value;

        var D1 = mod$1(invsqrt * u1);
        var D2 = mod$1(invsqrt * u2);
        var zInv = mod$1(D1 * D2 * t);
        var D;

        if (edIsNegative(t * zInv)) {
          var _x = mod$1(y * SQRT_M1);

          var _y = mod$1(x * SQRT_M1);

          x = _x;
          y = _y;
          D = mod$1(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }

        if (edIsNegative(x * zInv)) y = mod$1(-y);
        var s = mod$1((z - y) * D);
        if (edIsNegative(s)) s = mod$1(-s);
        return numberTo32BytesLE(s);
      }
    }, {
      key: "toHex",
      value: function toHex() {
        return bytesToHex$1(this.toRawBytes());
      }
    }, {
      key: "toString",
      value: function toString() {
        return this.toHex();
      }
    }, {
      key: "equals",
      value: function equals(other) {
        assertRstPoint(other);
        var a = this.ep;
        var b = other.ep;
        var one = mod$1(a.x * b.y) === mod$1(a.y * b.x);
        var two = mod$1(a.y * b.y) === mod$1(a.x * b.x);
        return one || two;
      }
    }, {
      key: "add",
      value: function add(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.add(other.ep));
      }
    }, {
      key: "subtract",
      value: function subtract(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.subtract(other.ep));
      }
    }, {
      key: "multiply",
      value: function multiply(scalar) {
        return new RistrettoPoint(this.ep.multiply(scalar));
      }
    }, {
      key: "multiplyUnsafe",
      value: function multiplyUnsafe(scalar) {
        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
      }
    }], [{
      key: "calcElligatorRistrettoMap",
      value: function calcElligatorRistrettoMap(r0) {
        var d = CURVE$1.d;
        var r = mod$1(SQRT_M1 * r0 * r0);
        var Ns = mod$1((r + _1n$2) * ONE_MINUS_D_SQ);
        var c = BigInt(-1);
        var D = mod$1((c - d * r) * mod$1(r + d));

        var _uvRatio = uvRatio(Ns, D),
            Ns_D_is_sq = _uvRatio.isValid,
            s = _uvRatio.value;

        var s_ = mod$1(s * r0);
        if (!edIsNegative(s_)) s_ = mod$1(-s_);
        if (!Ns_D_is_sq) s = s_;
        if (!Ns_D_is_sq) c = r;
        var Nt = mod$1(c * (r - _1n$2) * D_MINUS_ONE_SQ - D);
        var s2 = s * s;
        var W0 = mod$1((s + s) * D);
        var W1 = mod$1(Nt * SQRT_AD_MINUS_ONE);
        var W2 = mod$1(_1n$2 - s2);
        var W3 = mod$1(_1n$2 + s2);
        return new ExtendedPoint(mod$1(W0 * W3), mod$1(W2 * W1), mod$1(W1 * W3), mod$1(W0 * W2));
      }
    }, {
      key: "hashToCurve",
      value: function hashToCurve(hex) {
        hex = ensureBytes$1(hex, 64);
        var r1 = bytes255ToNumberLE(hex.slice(0, 32));
        var R1 = this.calcElligatorRistrettoMap(r1);
        var r2 = bytes255ToNumberLE(hex.slice(32, 64));
        var R2 = this.calcElligatorRistrettoMap(r2);
        return new RistrettoPoint(R1.add(R2));
      }
    }, {
      key: "fromHex",
      value: function fromHex(hex) {
        hex = ensureBytes$1(hex, 32);
        var a = CURVE$1.a,
            d = CURVE$1.d;
        var emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';
        var s = bytes255ToNumberLE(hex);
        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s)) throw new Error(emsg);
        var s2 = mod$1(s * s);
        var u1 = mod$1(_1n$2 + a * s2);
        var u2 = mod$1(_1n$2 - a * s2);
        var u1_2 = mod$1(u1 * u1);
        var u2_2 = mod$1(u2 * u2);
        var v = mod$1(a * d * u1_2 - u2_2);

        var _invertSqrt2 = invertSqrt(mod$1(v * u2_2)),
            isValid = _invertSqrt2.isValid,
            I = _invertSqrt2.value;

        var Dx = mod$1(I * u2);
        var Dy = mod$1(I * Dx * v);
        var x = mod$1((s + s) * Dx);
        if (edIsNegative(x)) x = mod$1(-x);
        var y = mod$1(u1 * Dy);
        var t = mod$1(x * y);
        if (!isValid || edIsNegative(t) || y === _0n$2) throw new Error(emsg);
        return new RistrettoPoint(new ExtendedPoint(x, y, _1n$2, t));
      }
    }]);

    return RistrettoPoint;
  }();

  RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
  RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
  var pointPrecomputes$1 = new WeakMap();

  var Point$1 = /*#__PURE__*/function () {
    function Point(x, y) {
      _classCallCheck(this, Point);

      this.x = x;
      this.y = y;
    }

    _createClass(Point, [{
      key: "_setWindowSize",
      value: function _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes$1["delete"](this);
      }
    }, {
      key: "toRawBytes",
      value: function toRawBytes() {
        var bytes = numberTo32BytesLE(this.y);
        bytes[31] |= this.x & _1n$2 ? 0x80 : 0;
        return bytes;
      }
    }, {
      key: "toHex",
      value: function toHex() {
        return bytesToHex$1(this.toRawBytes());
      }
    }, {
      key: "toX25519",
      value: function toX25519() {
        var y = this.y;
        var u = mod$1((_1n$2 + y) * invert$1(_1n$2 - y));
        return numberTo32BytesLE(u);
      }
    }, {
      key: "isTorsionFree",
      value: function isTorsionFree() {
        return ExtendedPoint.fromAffine(this).isTorsionFree();
      }
    }, {
      key: "equals",
      value: function equals(other) {
        return this.x === other.x && this.y === other.y;
      }
    }, {
      key: "negate",
      value: function negate() {
        return new Point(mod$1(-this.x), this.y);
      }
    }, {
      key: "add",
      value: function add(other) {
        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
      }
    }, {
      key: "subtract",
      value: function subtract(other) {
        return this.add(other.negate());
      }
    }, {
      key: "multiply",
      value: function multiply(scalar) {
        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
    }], [{
      key: "fromHex",
      value: function fromHex(hex) {
        var strict = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var d = CURVE$1.d,
            P = CURVE$1.P;
        hex = ensureBytes$1(hex, 32);
        var normed = hex.slice();
        normed[31] = hex[31] & ~0x80;
        var y = bytesToNumberLE(normed);
        if (strict && y >= P) throw new Error('Expected 0 < hex < P');
        if (!strict && y >= POW_2_256$1) throw new Error('Expected 0 < hex < 2**256');
        var y2 = mod$1(y * y);
        var u = mod$1(y2 - _1n$2);
        var v = mod$1(d * y2 + _1n$2);

        var _uvRatio2 = uvRatio(u, v),
            isValid = _uvRatio2.isValid,
            x = _uvRatio2.value;

        if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');
        var isXOdd = (x & _1n$2) === _1n$2;
        var isLastByteOdd = (hex[31] & 0x80) !== 0;

        if (isLastByteOdd !== isXOdd) {
          x = mod$1(-x);
        }

        return new Point(x, y);
      }
    }, {
      key: "fromPrivateKey",
      value: function () {
        var _fromPrivateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(privateKey) {
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return getExtendedPublicKey(privateKey);

              case 2:
                return _context.abrupt("return", _context.sent.point);

              case 3:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));

        function fromPrivateKey(_x2) {
          return _fromPrivateKey.apply(this, arguments);
        }

        return fromPrivateKey;
      }()
    }]);

    return Point;
  }();

  Point$1.BASE = new Point$1(CURVE$1.Gx, CURVE$1.Gy);
  Point$1.ZERO = new Point$1(_0n$2, _1n$2);

  var Signature$1 = /*#__PURE__*/function () {
    function Signature(r, s) {
      _classCallCheck(this, Signature);

      this.r = r;
      this.s = s;
      this.assertValidity();
    }

    _createClass(Signature, [{
      key: "assertValidity",
      value: function assertValidity() {
        var r = this.r,
            s = this.s;
        if (!(r instanceof Point$1)) throw new Error('Expected Point instance');
        normalizeScalar$1(s, CURVE$1.l, false);
        return this;
      }
    }, {
      key: "toRawBytes",
      value: function toRawBytes() {
        var u8 = new Uint8Array(64);
        u8.set(this.r.toRawBytes());
        u8.set(numberTo32BytesLE(this.s), 32);
        return u8;
      }
    }, {
      key: "toHex",
      value: function toHex() {
        return bytesToHex$1(this.toRawBytes());
      }
    }], [{
      key: "fromHex",
      value: function fromHex(hex) {
        var bytes = ensureBytes$1(hex, 64);
        var r = Point$1.fromHex(bytes.slice(0, 32), false);
        var s = bytesToNumberLE(bytes.slice(32, 64));
        return new Signature(r, s);
      }
    }]);

    return Signature;
  }();

  function concatBytes$1() {
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }

    if (!arrays.every(function (a) {
      return a instanceof Uint8Array;
    })) throw new Error('Expected Uint8Array list');
    if (arrays.length === 1) return arrays[0];
    var length = arrays.reduce(function (a, arr) {
      return a + arr.length;
    }, 0);
    var result = new Uint8Array(length);

    for (var i = 0, pad = 0; i < arrays.length; i++) {
      var arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }

    return result;
  }

  var hexes$1 = Array.from({
    length: 256
  }, function (v, i) {
    return i.toString(16).padStart(2, '0');
  });

  function bytesToHex$1(uint8a) {
    if (!(uint8a instanceof Uint8Array)) throw new Error('Uint8Array expected');
    var hex = '';

    for (var i = 0; i < uint8a.length; i++) {
      hex += hexes$1[uint8a[i]];
    }

    return hex;
  }

  function hexToBytes$1(hex) {
    if (typeof hex !== 'string') {
      throw new TypeError('hexToBytes: expected string, got ' + _typeof$1(hex));
    }

    if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex');
    var array = new Uint8Array(hex.length / 2);

    for (var i = 0; i < array.length; i++) {
      var j = i * 2;
      var hexByte = hex.slice(j, j + 2);

      var _byte = Number.parseInt(hexByte, 16);

      if (Number.isNaN(_byte) || _byte < 0) throw new Error('Invalid byte sequence');
      array[i] = _byte;
    }

    return array;
  }

  function numberTo32BytesBE(num) {
    var length = 32;
    var hex = num.toString(16).padStart(length * 2, '0');
    return hexToBytes$1(hex);
  }

  function numberTo32BytesLE(num) {
    return numberTo32BytesBE(num).reverse();
  }

  function edIsNegative(num) {
    return (mod$1(num) & _1n$2) === _1n$2;
  }

  function bytesToNumberLE(uint8a) {
    if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');
    return BigInt('0x' + bytesToHex$1(Uint8Array.from(uint8a).reverse()));
  }

  var MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');

  function bytes255ToNumberLE(bytes) {
    return mod$1(bytesToNumberLE(bytes) & MAX_255B);
  }

  function mod$1(a) {
    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE$1.P;
    var res = a % b;
    return res >= _0n$2 ? res : b + res;
  }

  function invert$1(number) {
    var modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE$1.P;

    if (number === _0n$2 || modulo <= _0n$2) {
      throw new Error("invert: expected positive integers, got n=".concat(number, " mod=").concat(modulo));
    }

    var a = mod$1(number, modulo);
    var b = modulo;
    var x = _0n$2,
        u = _1n$2;

    while (a !== _0n$2) {
      var q = b / a;
      var r = b % a;
      var m = x - u * q;
      b = a, a = r, x = u, u = m;
    }

    var gcd = b;
    if (gcd !== _1n$2) throw new Error('invert: does not exist');
    return mod$1(x, modulo);
  }

  function invertBatch$1(nums) {
    var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE$1.P;
    var tmp = new Array(nums.length);
    var lastMultiplied = nums.reduce(function (acc, num, i) {
      if (num === _0n$2) return acc;
      tmp[i] = acc;
      return mod$1(acc * num, p);
    }, _1n$2);
    var inverted = invert$1(lastMultiplied, p);
    nums.reduceRight(function (acc, num, i) {
      if (num === _0n$2) return acc;
      tmp[i] = mod$1(acc * tmp[i], p);
      return mod$1(acc * num, p);
    }, inverted);
    return tmp;
  }

  function pow2$1(x, power) {
    var P = CURVE$1.P;
    var res = x;

    while (power-- > _0n$2) {
      res *= res;
      res %= P;
    }

    return res;
  }

  function pow_2_252_3(x) {
    var P = CURVE$1.P;

    var _5n = BigInt(5);

    var _10n = BigInt(10);

    var _20n = BigInt(20);

    var _40n = BigInt(40);

    var _80n = BigInt(80);

    var x2 = x * x % P;
    var b2 = x2 * x % P;
    var b4 = pow2$1(b2, _2n$2) * b2 % P;
    var b5 = pow2$1(b4, _1n$2) * x % P;
    var b10 = pow2$1(b5, _5n) * b5 % P;
    var b20 = pow2$1(b10, _10n) * b10 % P;
    var b40 = pow2$1(b20, _20n) * b20 % P;
    var b80 = pow2$1(b40, _40n) * b40 % P;
    var b160 = pow2$1(b80, _80n) * b80 % P;
    var b240 = pow2$1(b160, _80n) * b80 % P;
    var b250 = pow2$1(b240, _10n) * b10 % P;
    var pow_p_5_8 = pow2$1(b250, _2n$2) * x % P;
    return {
      pow_p_5_8: pow_p_5_8,
      b2: b2
    };
  }

  function uvRatio(u, v) {
    var v3 = mod$1(v * v * v);
    var v7 = mod$1(v3 * v3 * v);
    var pow = pow_2_252_3(u * v7).pow_p_5_8;
    var x = mod$1(u * v3 * pow);
    var vx2 = mod$1(v * x * x);
    var root1 = x;
    var root2 = mod$1(x * SQRT_M1);
    var useRoot1 = vx2 === u;
    var useRoot2 = vx2 === mod$1(-u);
    var noRoot = vx2 === mod$1(-u * SQRT_M1);
    if (useRoot1) x = root1;
    if (useRoot2 || noRoot) x = root2;
    if (edIsNegative(x)) x = mod$1(-x);
    return {
      isValid: useRoot1 || useRoot2,
      value: x
    };
  }

  function invertSqrt(number) {
    return uvRatio(_1n$2, number);
  }

  function modlLE(hash) {
    return mod$1(bytesToNumberLE(hash), CURVE$1.l);
  }

  function equalBytes(b1, b2) {
    if (b1.length !== b2.length) {
      return false;
    }

    for (var i = 0; i < b1.length; i++) {
      if (b1[i] !== b2[i]) {
        return false;
      }
    }

    return true;
  }

  function ensureBytes$1(hex, expectedLength) {
    var bytes = hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes$1(hex);
    if (typeof expectedLength === 'number' && bytes.length !== expectedLength) throw new Error("Expected ".concat(expectedLength, " bytes"));
    return bytes;
  }

  function normalizeScalar$1(num, max) {
    var strict = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (!max) throw new TypeError('Specify max value');
    if (typeof num === 'number' && Number.isSafeInteger(num)) num = BigInt(num);

    if (typeof num === 'bigint' && num < max) {
      if (strict) {
        if (_0n$2 < num) return num;
      } else {
        if (_0n$2 <= num) return num;
      }
    }

    throw new TypeError('Expected valid scalar: 0 < scalar < max');
  }

  function adjustBytes25519(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 127;
    bytes[31] |= 64;
    return bytes;
  }

  function checkPrivateKey(key) {
    key = typeof key === 'bigint' || typeof key === 'number' ? numberTo32BytesBE(normalizeScalar$1(key, POW_2_256$1)) : ensureBytes$1(key);
    if (key.length !== 32) throw new Error("Expected 32 bytes");
    return key;
  }

  function getKeyFromHash(hashed) {
    var head = adjustBytes25519(hashed.slice(0, 32));
    var prefix = hashed.slice(32, 64);
    var scalar = modlLE(head);
    var point = Point$1.BASE.multiply(scalar);
    var pointBytes = point.toRawBytes();
    return {
      head: head,
      prefix: prefix,
      scalar: scalar,
      point: point,
      pointBytes: pointBytes
    };
  }

  var _sha512Sync;

  function sha512s() {
    if (typeof _sha512Sync !== 'function') throw new Error('utils.sha512Sync must be set to use sync methods');
    return _sha512Sync.apply(void 0, arguments);
  }

  function getExtendedPublicKey(_x3) {
    return _getExtendedPublicKey.apply(this, arguments);
  }

  function _getExtendedPublicKey() {
    _getExtendedPublicKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(key) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            _context3.t0 = getKeyFromHash;
            _context3.next = 3;
            return utils$1.sha512(checkPrivateKey(key));

          case 3:
            _context3.t1 = _context3.sent;
            return _context3.abrupt("return", (0, _context3.t0)(_context3.t1));

          case 5:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    }));
    return _getExtendedPublicKey.apply(this, arguments);
  }

  function getExtendedPublicKeySync(key) {
    return getKeyFromHash(sha512s(checkPrivateKey(key)));
  }

  function getPublicKeySync(privateKey) {
    return getExtendedPublicKeySync(privateKey).pointBytes;
  }

  function signSync$1(message, privateKey) {
    message = ensureBytes$1(message);

    var _getExtendedPublicKey2 = getExtendedPublicKeySync(privateKey),
        prefix = _getExtendedPublicKey2.prefix,
        scalar = _getExtendedPublicKey2.scalar,
        pointBytes = _getExtendedPublicKey2.pointBytes;

    var r = modlLE(sha512s(prefix, message));
    var R = Point$1.BASE.multiply(r);
    var k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));
    var s = mod$1(r + k * scalar, CURVE$1.l);
    return new Signature$1(R, s).toRawBytes();
  }

  function prepareVerification(sig, message, publicKey) {
    message = ensureBytes$1(message);
    if (!(publicKey instanceof Point$1)) publicKey = Point$1.fromHex(publicKey, false);

    var _ref = sig instanceof Signature$1 ? sig.assertValidity() : Signature$1.fromHex(sig),
        r = _ref.r,
        s = _ref.s;

    var SB = ExtendedPoint.BASE.multiplyUnsafe(s);
    return {
      r: r,
      s: s,
      SB: SB,
      pub: publicKey,
      msg: message
    };
  }

  function finishVerification(publicKey, r, SB, hashed) {
    var k = modlLE(hashed);
    var kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
    var RkA = ExtendedPoint.fromAffine(r).add(kA);
    return RkA.subtract(SB).multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO);
  }

  function verifySync(sig, message, publicKey) {
    var _prepareVerification = prepareVerification(sig, message, publicKey),
        r = _prepareVerification.r,
        SB = _prepareVerification.SB,
        msg = _prepareVerification.msg,
        pub = _prepareVerification.pub;

    var hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);
    return finishVerification(pub, r, SB, hashed);
  }

  var sync = {
    getExtendedPublicKey: getExtendedPublicKeySync,
    getPublicKey: getPublicKeySync,
    sign: signSync$1,
    verify: verifySync
  };

  Point$1.BASE._setWindowSize(8);
  var crypto$2 = {
    node: nodeCrypto,
    web: (typeof self === "undefined" ? "undefined" : _typeof$1(self)) === 'object' && 'crypto' in self ? self.crypto : undefined
  };
  var utils$1 = {
    bytesToHex: bytesToHex$1,
    hexToBytes: hexToBytes$1,
    concatBytes: concatBytes$1,
    getExtendedPublicKey: getExtendedPublicKey,
    mod: mod$1,
    invert: invert$1,
    TORSION_SUBGROUP: ['0100000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a', '0000000000000000000000000000000000000000000000000000000000000080', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05', 'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f', '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85', '0000000000000000000000000000000000000000000000000000000000000000', 'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'],
    hashToPrivateScalar: function hashToPrivateScalar(hash) {
      hash = ensureBytes$1(hash);
      if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
      return mod$1(bytesToNumberLE(hash), CURVE$1.l - _1n$2) + _1n$2;
    },
    randomBytes: function randomBytes() {
      var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;

      if (crypto$2.web) {
        return crypto$2.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto$2.node) {
        var randomBytes = crypto$2.node.randomBytes;
        return new Uint8Array(randomBytes(bytesLength).buffer);
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    },
    randomPrivateKey: function randomPrivateKey() {
      return utils$1.randomBytes(32);
    },
    sha512: function () {
      var _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var message,
            buffer,
            _args2 = arguments;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              message = concatBytes$1.apply(void 0, _args2);

              if (!crypto$2.web) {
                _context2.next = 8;
                break;
              }

              _context2.next = 4;
              return crypto$2.web.subtle.digest('SHA-512', message.buffer);

            case 4:
              buffer = _context2.sent;
              return _context2.abrupt("return", new Uint8Array(buffer));

            case 8:
              if (!crypto$2.node) {
                _context2.next = 12;
                break;
              }

              return _context2.abrupt("return", Uint8Array.from(crypto$2.node.createHash('sha512').update(message).digest()));

            case 12:
              throw new Error("The environment doesn't have sha512 function");

            case 13:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));

      function sha512() {
        return _sha.apply(this, arguments);
      }

      return sha512;
    }(),
    precompute: function precompute() {
      var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point$1.BASE;
      var cached = point.equals(Point$1.BASE) ? point : new Point$1(point.x, point.y);

      cached._setWindowSize(windowSize);

      cached.multiply(_2n$2);
      return cached;
    },
    sha512Sync: undefined
  };
  Object.defineProperties(utils$1, {
    sha512Sync: {
      configurable: false,
      get: function get() {
        return _sha512Sync;
      },
      set: function set(val) {
        if (!_sha512Sync) _sha512Sync = val;
      }
    }
  });

  var safeBuffer = {exports: {}};

  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

  (function (module, exports) {
    /* eslint-disable node/no-deprecated-api */
    var buffer = require$$0$1;
    var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }

    if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      // Copy properties from require('buffer')
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }

    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer(arg, encodingOrOffset, length);
    }

    SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

    copyProps(Buffer, SafeBuffer);

    SafeBuffer.from = function (arg, encodingOrOffset, length) {
      if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
      }

      return Buffer(arg, encodingOrOffset, length);
    };

    SafeBuffer.alloc = function (size, fill, encoding) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      var buf = Buffer(size);

      if (fill !== undefined) {
        if (typeof encoding === 'string') {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }

      return buf;
    };

    SafeBuffer.allocUnsafe = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      return Buffer(size);
    };

    SafeBuffer.allocUnsafeSlow = function (size) {
      if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
      }

      return buffer.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);

  // Copyright (c) 2018 base-x contributors
  // Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
  // Distributed under the MIT software license, see the accompanying
  // file LICENSE or http://www.opensource.org/licenses/mit-license.php.
  // @ts-ignore


  var _Buffer = safeBuffer.exports.Buffer;

  function base(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError('Alphabet too long');
    }

    var BASE_MAP = new Uint8Array(256);

    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }

    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);

      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + ' is ambiguous');
      }

      BASE_MAP[xc] = i;
    }

    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up

    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up

    function encode(source) {
      if (Array.isArray(source) || source instanceof Uint8Array) {
        source = _Buffer.from(source);
      }

      if (!_Buffer.isBuffer(source)) {
        throw new TypeError('Expected Buffer');
      }

      if (source.length === 0) {
        return '';
      } // Skip & count leading zeroes.


      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;

      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      } // Allocate enough space in big-endian base58 representation.


      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size); // Process the bytes.

      while (pbegin !== pend) {
        var carry = source[pbegin]; // Apply "b58 = b58 * 256 + ch".

        var i = 0;

        for (var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }

        if (carry !== 0) {
          throw new Error('Non-zero carry');
        }

        length = i;
        pbegin++;
      } // Skip leading zeroes in base58 result.


      var it2 = size - length;

      while (it2 !== size && b58[it2] === 0) {
        it2++;
      } // Translate the result into a string.


      var str = LEADER.repeat(zeroes);

      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }

      return str;
    }

    function decodeUnsafe(source) {
      if (typeof source !== 'string') {
        throw new TypeError('Expected String');
      }

      if (source.length === 0) {
        return _Buffer.alloc(0);
      }

      var psz = 0; // Skip and count leading '1's.

      var zeroes = 0;
      var length = 0;

      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      } // Allocate enough space in big-endian base256 representation.


      var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.

      var b256 = new Uint8Array(size); // Process the characters.

      while (source[psz]) {
        // Decode character
        var carry = BASE_MAP[source.charCodeAt(psz)]; // Invalid character

        if (carry === 255) {
          return;
        }

        var i = 0;

        for (var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }

        if (carry !== 0) {
          throw new Error('Non-zero carry');
        }

        length = i;
        psz++;
      } // Skip leading zeroes in b256.


      var it4 = size - length;

      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }

      var vch = _Buffer.allocUnsafe(zeroes + (size - it4));

      vch.fill(0x00, 0, zeroes);
      var j = zeroes;

      while (it4 !== size) {
        vch[j++] = b256[it4++];
      }

      return vch;
    }

    function decode(string) {
      var buffer = decodeUnsafe(string);

      if (buffer) {
        return buffer;
      }

      throw new Error('Non-base' + BASE + ' character');
    }

    return {
      encode: encode,
      decodeUnsafe: decodeUnsafe,
      decode: decode
    };
  }

  var src = base;

  var basex = src;
  var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
  var bs58 = basex(ALPHABET);
  var bs58$1 = bs58;

  var Chi = function Chi(a, b, c) {
    return a & b ^ ~a & c;
  }; // Majority function, true if any two inpust is true


  var Maj = function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
  }; // Round constants:
  // first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)
  // prettier-ignore


  var SHA256_K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]); // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):
  // prettier-ignore

  var IV = new Uint32Array([0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19]); // Temporary buffer, not used to store anything between runs
  // Named this way because it matches specification.

  var SHA256_W = new Uint32Array(64);

  var SHA256 = /*#__PURE__*/function (_SHA) {
    _inherits(SHA256, _SHA);

    var _super = _createSuper(SHA256);

    function SHA256() {
      var _this;

      _classCallCheck(this, SHA256);

      _this = _super.call(this, 64, 32, 8, false); // We cannot use array here since array allows indexing by variable
      // which means optimizer/compiler cannot use registers.

      _this.A = IV[0] | 0;
      _this.B = IV[1] | 0;
      _this.C = IV[2] | 0;
      _this.D = IV[3] | 0;
      _this.E = IV[4] | 0;
      _this.F = IV[5] | 0;
      _this.G = IV[6] | 0;
      _this.H = IV[7] | 0;
      return _this;
    }

    _createClass(SHA256, [{
      key: "get",
      value: function get() {
        var A = this.A,
            B = this.B,
            C = this.C,
            D = this.D,
            E = this.E,
            F = this.F,
            G = this.G,
            H = this.H;
        return [A, B, C, D, E, F, G, H];
      } // prettier-ignore

    }, {
      key: "set",
      value: function set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
    }, {
      key: "process",
      value: function process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for (var i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);

        for (var _i2 = 16; _i2 < 64; _i2++) {
          var W15 = SHA256_W[_i2 - 15];
          var W2 = SHA256_W[_i2 - 2];
          var s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          var s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[_i2] = s1 + SHA256_W[_i2 - 7] + s0 + SHA256_W[_i2 - 16] | 0;
        } // Compression function main loop, 64 rounds


        var A = this.A,
            B = this.B,
            C = this.C,
            D = this.D,
            E = this.E,
            F = this.F,
            G = this.G,
            H = this.H;

        for (var _i4 = 0; _i4 < 64; _i4++) {
          var sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          var T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[_i4] + SHA256_W[_i4] | 0;
          var sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
          var T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        } // Add the compressed chunk to the current hash value


        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
    }, {
      key: "roundClean",
      value: function roundClean() {
        SHA256_W.fill(0);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    }]);

    return SHA256;
  }(SHA2); // Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf


  var SHA224 = /*#__PURE__*/function (_SHA2) {
    _inherits(SHA224, _SHA2);

    var _super2 = _createSuper(SHA224);

    function SHA224() {
      var _this2;

      _classCallCheck(this, SHA224);

      _this2 = _super2.call(this);
      _this2.A = 0xc1059ed8 | 0;
      _this2.B = 0x367cd507 | 0;
      _this2.C = 0x3070dd17 | 0;
      _this2.D = 0xf70e5939 | 0;
      _this2.E = 0xffc00b31 | 0;
      _this2.F = 0x68581511 | 0;
      _this2.G = 0x64f98fa7 | 0;
      _this2.H = 0xbefa4fa4 | 0;
      _this2.outputLen = 28;
      return _this2;
    }

    return _createClass(SHA224);
  }(SHA256);
  /**
   * SHA2-256 hash function
   * @param message - data that would be hashed
   */


  var sha256 = wrapConstructor(function () {
    return new SHA256();
  });
  wrapConstructor(function () {
    return new SHA224();
  });

  var lib$1 = {};

  function inRange(a, min, max) {
    return min <= a && a <= max;
  }
  /**
   * @param {*} o
   * @return {Object}
   */


  function ToDictionary(o) {
    if (o === undefined) return {};
    if (o === Object(o)) return o;
    throw TypeError('Could not convert argument to dictionary');
  }
  /**
   * @param {string} string Input string of UTF-16 code units.
   * @return {!Array.<number>} Code points.
   */


  function stringToCodePoints(string) {
    // https://heycam.github.io/webidl/#dfn-obtain-unicode
    // 1. Let S be the DOMString value.
    var s = String(string); // 2. Let n be the length of S.

    var n = s.length; // 3. Initialize i to 0.

    var i = 0; // 4. Initialize U to be an empty sequence of Unicode characters.

    var u = []; // 5. While i < n:

    while (i < n) {
      // 1. Let c be the code unit in S at index i.
      var c = s.charCodeAt(i); // 2. Depending on the value of c:
      // c < 0xD800 or c > 0xDFFF

      if (c < 0xD800 || c > 0xDFFF) {
        // Append to U the Unicode character with code point c.
        u.push(c);
      } // 0xDC00 ≤ c ≤ 0xDFFF
      else if (0xDC00 <= c && c <= 0xDFFF) {
        // Append to U a U+FFFD REPLACEMENT CHARACTER.
        u.push(0xFFFD);
      } // 0xD800 ≤ c ≤ 0xDBFF
      else if (0xD800 <= c && c <= 0xDBFF) {
        // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT
        // CHARACTER.
        if (i === n - 1) {
          u.push(0xFFFD);
        } // 2. Otherwise, i < n−1:
        else {
          // 1. Let d be the code unit in S at index i+1.
          var d = string.charCodeAt(i + 1); // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:

          if (0xDC00 <= d && d <= 0xDFFF) {
            // 1. Let a be c & 0x3FF.
            var a = c & 0x3FF; // 2. Let b be d & 0x3FF.

            var b = d & 0x3FF; // 3. Append to U the Unicode character with code point
            // 2^16+2^10*a+b.

            u.push(0x10000 + (a << 10) + b); // 4. Set i to i+1.

            i += 1;
          } // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a
          // U+FFFD REPLACEMENT CHARACTER.
          else {
            u.push(0xFFFD);
          }
        }
      } // 3. Set i to i+1.


      i += 1;
    } // 6. Return U.


    return u;
  }
  /**
   * @param {!Array.<number>} code_points Array of code points.
   * @return {string} string String of UTF-16 code units.
   */


  function codePointsToString(code_points) {
    var s = '';

    for (var i = 0; i < code_points.length; ++i) {
      var cp = code_points[i];

      if (cp <= 0xFFFF) {
        s += String.fromCharCode(cp);
      } else {
        cp -= 0x10000;
        s += String.fromCharCode((cp >> 10) + 0xD800, (cp & 0x3FF) + 0xDC00);
      }
    }

    return s;
  } //
  // Implementation of Encoding specification
  // https://encoding.spec.whatwg.org/
  //
  //
  // 3. Terminology
  //

  /**
   * End-of-stream is a special token that signifies no more tokens
   * are in the stream.
   * @const
   */


  var end_of_stream = -1;
  /**
   * A stream represents an ordered sequence of tokens.
   *
   * @constructor
   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the
   * stream.
   */

  function Stream(tokens) {
    /** @type {!Array.<number>} */
    this.tokens = [].slice.call(tokens);
  }

  Stream.prototype = {
    /**
     * @return {boolean} True if end-of-stream has been hit.
     */
    endOfStream: function endOfStream() {
      return !this.tokens.length;
    },

    /**
     * When a token is read from a stream, the first token in the
     * stream must be returned and subsequently removed, and
     * end-of-stream must be returned otherwise.
     *
     * @return {number} Get the next token from the stream, or
     * end_of_stream.
     */
    read: function read() {
      if (!this.tokens.length) return end_of_stream;
      return this.tokens.shift();
    },

    /**
     * When one or more tokens are prepended to a stream, those tokens
     * must be inserted, in given order, before the first token in the
     * stream.
     *
     * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
     */
    prepend: function prepend(token) {
      if (Array.isArray(token)) {
        var tokens =
        /**@type {!Array.<number>}*/
        token;

        while (tokens.length) this.tokens.unshift(tokens.pop());
      } else {
        this.tokens.unshift(token);
      }
    },

    /**
     * When one or more tokens are pushed to a stream, those tokens
     * must be inserted, in given order, after the last token in the
     * stream.
     *
     * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
     */
    push: function push(token) {
      if (Array.isArray(token)) {
        var tokens =
        /**@type {!Array.<number>}*/
        token;

        while (tokens.length) this.tokens.push(tokens.shift());
      } else {
        this.tokens.push(token);
      }
    }
  }; //
  // 4. Encodings
  //
  // 4.1 Encoders and decoders

  /** @const */

  var finished = -1;
  /**
   * @param {boolean} fatal If true, decoding errors raise an exception.
   * @param {number=} opt_code_point Override the standard fallback code point.
   * @return {number} The code point to insert on a decoding error.
   */

  function decoderError(fatal, opt_code_point) {
    if (fatal) throw TypeError('Decoder error');
    return opt_code_point || 0xFFFD;
  }
  // 7. API
  //

  /** @const */

  var DEFAULT_ENCODING = 'utf-8'; // 7.1 Interface TextDecoder

  /**
   * @constructor
   * @param {string=} encoding The label of the encoding;
   *     defaults to 'utf-8'.
   * @param {Object=} options
   */

  function TextDecoder$1(encoding, options) {
    if (!(this instanceof TextDecoder$1)) {
      return new TextDecoder$1(encoding, options);
    }

    encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;

    if (encoding !== DEFAULT_ENCODING) {
      throw new Error('Encoding not supported. Only utf-8 is supported');
    }

    options = ToDictionary(options);
    /** @private @type {boolean} */

    this._streaming = false;
    /** @private @type {boolean} */

    this._BOMseen = false;
    /** @private @type {?Decoder} */

    this._decoder = null;
    /** @private @type {boolean} */

    this._fatal = Boolean(options['fatal']);
    /** @private @type {boolean} */

    this._ignoreBOM = Boolean(options['ignoreBOM']);
    Object.defineProperty(this, 'encoding', {
      value: 'utf-8'
    });
    Object.defineProperty(this, 'fatal', {
      value: this._fatal
    });
    Object.defineProperty(this, 'ignoreBOM', {
      value: this._ignoreBOM
    });
  }

  TextDecoder$1.prototype = {
    /**
     * @param {ArrayBufferView=} input The buffer of bytes to decode.
     * @param {Object=} options
     * @return {string} The decoded string.
     */
    decode: function decode(input, options) {
      var bytes;

      if (_typeof$1(input) === 'object' && input instanceof ArrayBuffer) {
        bytes = new Uint8Array(input);
      } else if (_typeof$1(input) === 'object' && 'buffer' in input && input.buffer instanceof ArrayBuffer) {
        bytes = new Uint8Array(input.buffer, input.byteOffset, input.byteLength);
      } else {
        bytes = new Uint8Array(0);
      }

      options = ToDictionary(options);

      if (!this._streaming) {
        this._decoder = new UTF8Decoder({
          fatal: this._fatal
        });
        this._BOMseen = false;
      }

      this._streaming = Boolean(options['stream']);
      var input_stream = new Stream(bytes);
      var code_points = [];
      /** @type {?(number|!Array.<number>)} */

      var result;

      while (!input_stream.endOfStream()) {
        result = this._decoder.handler(input_stream, input_stream.read());
        if (result === finished) break;
        if (result === null) continue;
        if (Array.isArray(result)) code_points.push.apply(code_points,
        /**@type {!Array.<number>}*/
        result);else code_points.push(result);
      }

      if (!this._streaming) {
        do {
          result = this._decoder.handler(input_stream, input_stream.read());
          if (result === finished) break;
          if (result === null) continue;
          if (Array.isArray(result)) code_points.push.apply(code_points,
          /**@type {!Array.<number>}*/
          result);else code_points.push(result);
        } while (!input_stream.endOfStream());

        this._decoder = null;
      }

      if (code_points.length) {
        // If encoding is one of utf-8, utf-16be, and utf-16le, and
        // ignore BOM flag and BOM seen flag are unset, run these
        // subsubsteps:
        if (['utf-8'].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {
          // If token is U+FEFF, set BOM seen flag.
          if (code_points[0] === 0xFEFF) {
            this._BOMseen = true;
            code_points.shift();
          } else {
            // Otherwise, if token is not end-of-stream, set BOM seen
            // flag and append token to output.
            this._BOMseen = true;
          }
        }
      }

      return codePointsToString(code_points);
    }
  }; // 7.2 Interface TextEncoder

  /**
   * @constructor
   * @param {string=} encoding The label of the encoding;
   *     defaults to 'utf-8'.
   * @param {Object=} options
   */

  function TextEncoder$1(encoding, options) {
    if (!(this instanceof TextEncoder$1)) return new TextEncoder$1(encoding, options);
    encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;

    if (encoding !== DEFAULT_ENCODING) {
      throw new Error('Encoding not supported. Only utf-8 is supported');
    }

    options = ToDictionary(options);
    /** @private @type {boolean} */

    this._streaming = false;
    /** @private @type {?Encoder} */

    this._encoder = null;
    /** @private @type {{fatal: boolean}} */

    this._options = {
      fatal: Boolean(options['fatal'])
    };
    Object.defineProperty(this, 'encoding', {
      value: 'utf-8'
    });
  }

  TextEncoder$1.prototype = {
    /**
     * @param {string=} opt_string The string to encode.
     * @param {Object=} options
     * @return {Uint8Array} Encoded bytes, as a Uint8Array.
     */
    encode: function encode(opt_string, options) {
      opt_string = opt_string ? String(opt_string) : '';
      options = ToDictionary(options); // NOTE: This option is nonstandard. None of the encodings
      // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,
      // so streaming is not necessary.

      if (!this._streaming) this._encoder = new UTF8Encoder(this._options);
      this._streaming = Boolean(options['stream']);
      var bytes = [];
      var input_stream = new Stream(stringToCodePoints(opt_string));
      /** @type {?(number|!Array.<number>)} */

      var result;

      while (!input_stream.endOfStream()) {
        result = this._encoder.handler(input_stream, input_stream.read());
        if (result === finished) break;
        if (Array.isArray(result)) bytes.push.apply(bytes,
        /**@type {!Array.<number>}*/
        result);else bytes.push(result);
      }

      if (!this._streaming) {
        while (true) {
          result = this._encoder.handler(input_stream, input_stream.read());
          if (result === finished) break;
          if (Array.isArray(result)) bytes.push.apply(bytes,
          /**@type {!Array.<number>}*/
          result);else bytes.push(result);
        }

        this._encoder = null;
      }

      return new Uint8Array(bytes);
    }
  }; //
  // 8. The encoding
  //
  // 8.1 utf-8

  /**
   * @constructor
   * @implements {Decoder}
   * @param {{fatal: boolean}} options
   */

  function UTF8Decoder(options) {
    var fatal = options.fatal; // utf-8's decoder's has an associated utf-8 code point, utf-8
    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8
    // lower boundary (initially 0x80), and a utf-8 upper boundary
    // (initially 0xBF).

    var
    /** @type {number} */
    utf8_code_point = 0,

    /** @type {number} */
    utf8_bytes_seen = 0,

    /** @type {number} */
    utf8_bytes_needed = 0,

    /** @type {number} */
    utf8_lower_boundary = 0x80,

    /** @type {number} */
    utf8_upper_boundary = 0xBF;
    /**
     * @param {Stream} stream The stream of bytes being decoded.
     * @param {number} bite The next byte read from the stream.
     * @return {?(number|!Array.<number>)} The next code point(s)
     *     decoded, or null if not enough data exists in the input
     *     stream to decode a complete code point.
     */

    this.handler = function (stream, bite) {
      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,
      // set utf-8 bytes needed to 0 and return error.
      if (bite === end_of_stream && utf8_bytes_needed !== 0) {
        utf8_bytes_needed = 0;
        return decoderError(fatal);
      } // 2. If byte is end-of-stream, return finished.


      if (bite === end_of_stream) return finished; // 3. If utf-8 bytes needed is 0, based on byte:

      if (utf8_bytes_needed === 0) {
        // 0x00 to 0x7F
        if (inRange(bite, 0x00, 0x7F)) {
          // Return a code point whose value is byte.
          return bite;
        } // 0xC2 to 0xDF


        if (inRange(bite, 0xC2, 0xDF)) {
          // Set utf-8 bytes needed to 1 and utf-8 code point to byte
          // − 0xC0.
          utf8_bytes_needed = 1;
          utf8_code_point = bite - 0xC0;
        } // 0xE0 to 0xEF
        else if (inRange(bite, 0xE0, 0xEF)) {
          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.
          if (bite === 0xE0) utf8_lower_boundary = 0xA0; // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.

          if (bite === 0xED) utf8_upper_boundary = 0x9F; // 3. Set utf-8 bytes needed to 2 and utf-8 code point to
          // byte − 0xE0.

          utf8_bytes_needed = 2;
          utf8_code_point = bite - 0xE0;
        } // 0xF0 to 0xF4
        else if (inRange(bite, 0xF0, 0xF4)) {
          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.
          if (bite === 0xF0) utf8_lower_boundary = 0x90; // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.

          if (bite === 0xF4) utf8_upper_boundary = 0x8F; // 3. Set utf-8 bytes needed to 3 and utf-8 code point to
          // byte − 0xF0.

          utf8_bytes_needed = 3;
          utf8_code_point = bite - 0xF0;
        } // Otherwise
        else {
          // Return error.
          return decoderError(fatal);
        } // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code
        // point to utf-8 code point << (6 × utf-8 bytes needed) and
        // return continue.


        utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;
        return null;
      } // 4. If byte is not in the range utf-8 lower boundary to utf-8
      // upper boundary, run these substeps:


      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {
        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8
        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set
        // utf-8 upper boundary to 0xBF.
        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;
        utf8_lower_boundary = 0x80;
        utf8_upper_boundary = 0xBF; // 2. Prepend byte to stream.

        stream.prepend(bite); // 3. Return error.

        return decoderError(fatal);
      } // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary
      // to 0xBF.


      utf8_lower_boundary = 0x80;
      utf8_upper_boundary = 0xBF; // 6. Increase utf-8 bytes seen by one and set utf-8 code point
      // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes
      // needed − utf-8 bytes seen)).

      utf8_bytes_seen += 1;
      utf8_code_point += bite - 0x80 << 6 * (utf8_bytes_needed - utf8_bytes_seen); // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,
      // continue.

      if (utf8_bytes_seen !== utf8_bytes_needed) return null; // 8. Let code point be utf-8 code point.

      var code_point = utf8_code_point; // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes
      // seen to 0.

      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0; // 10. Return a code point whose value is code point.

      return code_point;
    };
  }
  /**
   * @constructor
   * @implements {Encoder}
   * @param {{fatal: boolean}} options
   */


  function UTF8Encoder(options) {
    options.fatal;
    /**
     * @param {Stream} stream Input stream.
     * @param {number} code_point Next code point read from the stream.
     * @return {(number|!Array.<number>)} Byte(s) to emit.
     */

    this.handler = function (stream, code_point) {
      // 1. If code point is end-of-stream, return finished.
      if (code_point === end_of_stream) return finished; // 2. If code point is in the range U+0000 to U+007F, return a
      // byte whose value is code point.

      if (inRange(code_point, 0x0000, 0x007f)) return code_point; // 3. Set count and offset based on the range code point is in:

      var count, offset; // U+0080 to U+07FF:    1 and 0xC0

      if (inRange(code_point, 0x0080, 0x07FF)) {
        count = 1;
        offset = 0xC0;
      } // U+0800 to U+FFFF:    2 and 0xE0
      else if (inRange(code_point, 0x0800, 0xFFFF)) {
        count = 2;
        offset = 0xE0;
      } // U+10000 to U+10FFFF: 3 and 0xF0
      else if (inRange(code_point, 0x10000, 0x10FFFF)) {
        count = 3;
        offset = 0xF0;
      } // 4.Let bytes be a byte sequence whose first byte is (code
      // point >> (6 × count)) + offset.


      var bytes = [(code_point >> 6 * count) + offset]; // 5. Run these substeps while count is greater than 0:

      while (count > 0) {
        // 1. Set temp to code point >> (6 × (count − 1)).
        var temp = code_point >> 6 * (count - 1); // 2. Append to bytes 0x80 | (temp & 0x3F).

        bytes.push(0x80 | temp & 0x3F); // 3. Decrease count by one.

        count -= 1;
      } // 6. Return bytes bytes, in order.


      return bytes;
    };
  }

  var encoding_lib = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	TextEncoder: TextEncoder$1,
  	TextDecoder: TextDecoder$1
  });

  var require$$2 = /*@__PURE__*/getAugmentedNamespace(encoding_lib);

  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    });
  } : function (o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
  });

  var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function (o, v) {
    Object.defineProperty(o, "default", {
      enumerable: true,
      value: v
    });
  } : function (o, v) {
    o["default"] = v;
  });

  var __decorate = commonjsGlobal && commonjsGlobal.__decorate || function (decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof$1(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };

  var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

    __setModuleDefault(result, mod);

    return result;
  };

  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
    return mod && mod.__esModule ? mod : {
      "default": mod
    };
  };

  Object.defineProperty(lib$1, "__esModule", {
    value: true
  });
  var deserializeUnchecked_1 = lib$1.deserializeUnchecked = deserialize_1 = lib$1.deserialize = serialize_1 = lib$1.serialize = lib$1.BinaryReader = lib$1.BinaryWriter = lib$1.BorshError = lib$1.baseDecode = lib$1.baseEncode = void 0;

  var bn_js_1 = __importDefault(bn$1.exports);

  var bs58_1 = __importDefault(bs58); // TODO: Make sure this polyfill not included when not required


  var encoding = __importStar(require$$2);

  var ResolvedTextDecoder = typeof TextDecoder !== "function" ? encoding.TextDecoder : TextDecoder;
  var textDecoder = new ResolvedTextDecoder("utf-8", {
    fatal: true
  });

  function baseEncode(value) {
    if (typeof value === "string") {
      value = Buffer$1.from(value, "utf8");
    }

    return bs58_1["default"].encode(Buffer$1.from(value));
  }

  lib$1.baseEncode = baseEncode;

  function baseDecode(value) {
    return Buffer$1.from(bs58_1["default"].decode(value));
  }

  lib$1.baseDecode = baseDecode;
  var INITIAL_LENGTH = 1024;

  var BorshError = /*#__PURE__*/function (_Error) {
    _inherits(BorshError, _Error);

    var _super = _createSuper(BorshError);

    function BorshError(message) {
      var _this;

      _classCallCheck(this, BorshError);

      _this = _super.call(this, message);
      _this.fieldPath = [];
      _this.originalMessage = message;
      return _this;
    }

    _createClass(BorshError, [{
      key: "addToFieldPath",
      value: function addToFieldPath(fieldName) {
        this.fieldPath.splice(0, 0, fieldName); // NOTE: Modifying message directly as jest doesn't use .toString()

        this.message = this.originalMessage + ": " + this.fieldPath.join(".");
      }
    }]);

    return BorshError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  lib$1.BorshError = BorshError; /// Binary encoder.

  var BinaryWriter = /*#__PURE__*/function () {
    function BinaryWriter() {
      _classCallCheck(this, BinaryWriter);

      this.buf = Buffer$1.alloc(INITIAL_LENGTH);
      this.length = 0;
    }

    _createClass(BinaryWriter, [{
      key: "maybeResize",
      value: function maybeResize() {
        if (this.buf.length < 16 + this.length) {
          this.buf = Buffer$1.concat([this.buf, Buffer$1.alloc(INITIAL_LENGTH)]);
        }
      }
    }, {
      key: "writeU8",
      value: function writeU8(value) {
        this.maybeResize();
        this.buf.writeUInt8(value, this.length);
        this.length += 1;
      }
    }, {
      key: "writeU16",
      value: function writeU16(value) {
        this.maybeResize();
        this.buf.writeUInt16LE(value, this.length);
        this.length += 2;
      }
    }, {
      key: "writeU32",
      value: function writeU32(value) {
        this.maybeResize();
        this.buf.writeUInt32LE(value, this.length);
        this.length += 4;
      }
    }, {
      key: "writeU64",
      value: function writeU64(value) {
        this.maybeResize();
        this.writeBuffer(Buffer$1.from(new bn_js_1["default"](value).toArray("le", 8)));
      }
    }, {
      key: "writeU128",
      value: function writeU128(value) {
        this.maybeResize();
        this.writeBuffer(Buffer$1.from(new bn_js_1["default"](value).toArray("le", 16)));
      }
    }, {
      key: "writeU256",
      value: function writeU256(value) {
        this.maybeResize();
        this.writeBuffer(Buffer$1.from(new bn_js_1["default"](value).toArray("le", 32)));
      }
    }, {
      key: "writeU512",
      value: function writeU512(value) {
        this.maybeResize();
        this.writeBuffer(Buffer$1.from(new bn_js_1["default"](value).toArray("le", 64)));
      }
    }, {
      key: "writeBuffer",
      value: function writeBuffer(buffer) {
        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser
        this.buf = Buffer$1.concat([Buffer$1.from(this.buf.subarray(0, this.length)), buffer, Buffer$1.alloc(INITIAL_LENGTH)]);
        this.length += buffer.length;
      }
    }, {
      key: "writeString",
      value: function writeString(str) {
        this.maybeResize();
        var b = Buffer$1.from(str, "utf8");
        this.writeU32(b.length);
        this.writeBuffer(b);
      }
    }, {
      key: "writeFixedArray",
      value: function writeFixedArray(array) {
        this.writeBuffer(Buffer$1.from(array));
      }
    }, {
      key: "writeArray",
      value: function writeArray(array, fn) {
        this.maybeResize();
        this.writeU32(array.length);

        var _iterator = _createForOfIteratorHelper(array),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var elem = _step.value;
            this.maybeResize();
            fn(elem);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }, {
      key: "toArray",
      value: function toArray() {
        return this.buf.subarray(0, this.length);
      }
    }]);

    return BinaryWriter;
  }();

  lib$1.BinaryWriter = BinaryWriter;

  function handlingRangeError(target, propertyKey, propertyDescriptor) {
    var originalMethod = propertyDescriptor.value;

    propertyDescriptor.value = function () {
      try {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return originalMethod.apply(this, args);
      } catch (e) {
        if (e instanceof RangeError) {
          var code = e.code;

          if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(code) >= 0) {
            throw new BorshError("Reached the end of buffer when deserializing");
          }
        }

        throw e;
      }
    };
  }

  var BinaryReader = /*#__PURE__*/function () {
    function BinaryReader(buf) {
      _classCallCheck(this, BinaryReader);

      this.buf = buf;
      this.offset = 0;
    }

    _createClass(BinaryReader, [{
      key: "readU8",
      value: function readU8() {
        var value = this.buf.readUInt8(this.offset);
        this.offset += 1;
        return value;
      }
    }, {
      key: "readU16",
      value: function readU16() {
        var value = this.buf.readUInt16LE(this.offset);
        this.offset += 2;
        return value;
      }
    }, {
      key: "readU32",
      value: function readU32() {
        var value = this.buf.readUInt32LE(this.offset);
        this.offset += 4;
        return value;
      }
    }, {
      key: "readU64",
      value: function readU64() {
        var buf = this.readBuffer(8);
        return new bn_js_1["default"](buf, "le");
      }
    }, {
      key: "readU128",
      value: function readU128() {
        var buf = this.readBuffer(16);
        return new bn_js_1["default"](buf, "le");
      }
    }, {
      key: "readU256",
      value: function readU256() {
        var buf = this.readBuffer(32);
        return new bn_js_1["default"](buf, "le");
      }
    }, {
      key: "readU512",
      value: function readU512() {
        var buf = this.readBuffer(64);
        return new bn_js_1["default"](buf, "le");
      }
    }, {
      key: "readBuffer",
      value: function readBuffer(len) {
        if (this.offset + len > this.buf.length) {
          throw new BorshError("Expected buffer length ".concat(len, " isn't within bounds"));
        }

        var result = this.buf.slice(this.offset, this.offset + len);
        this.offset += len;
        return result;
      }
    }, {
      key: "readString",
      value: function readString() {
        var len = this.readU32();
        var buf = this.readBuffer(len);

        try {
          // NOTE: Using TextDecoder to fail on invalid UTF-8
          return textDecoder.decode(buf);
        } catch (e) {
          throw new BorshError("Error decoding UTF-8 string: ".concat(e));
        }
      }
    }, {
      key: "readFixedArray",
      value: function readFixedArray(len) {
        return new Uint8Array(this.readBuffer(len));
      }
    }, {
      key: "readArray",
      value: function readArray(fn) {
        var len = this.readU32();
        var result = Array();

        for (var i = 0; i < len; ++i) {
          result.push(fn());
        }

        return result;
      }
    }]);

    return BinaryReader;
  }();

  __decorate([handlingRangeError], BinaryReader.prototype, "readU8", null);

  __decorate([handlingRangeError], BinaryReader.prototype, "readU16", null);

  __decorate([handlingRangeError], BinaryReader.prototype, "readU32", null);

  __decorate([handlingRangeError], BinaryReader.prototype, "readU64", null);

  __decorate([handlingRangeError], BinaryReader.prototype, "readU128", null);

  __decorate([handlingRangeError], BinaryReader.prototype, "readU256", null);

  __decorate([handlingRangeError], BinaryReader.prototype, "readU512", null);

  __decorate([handlingRangeError], BinaryReader.prototype, "readString", null);

  __decorate([handlingRangeError], BinaryReader.prototype, "readFixedArray", null);

  __decorate([handlingRangeError], BinaryReader.prototype, "readArray", null);

  lib$1.BinaryReader = BinaryReader;

  function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  function serializeField(schema, fieldName, value, fieldType, writer) {
    try {
      // TODO: Handle missing values properly (make sure they never result in just skipped write)
      if (typeof fieldType === "string") {
        writer["write".concat(capitalizeFirstLetter(fieldType))](value);
      } else if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          if (value.length !== fieldType[0]) {
            throw new BorshError("Expecting byte array of length ".concat(fieldType[0], ", but got ").concat(value.length, " bytes"));
          }

          writer.writeFixedArray(value);
        } else if (fieldType.length === 2 && typeof fieldType[1] === "number") {
          if (value.length !== fieldType[1]) {
            throw new BorshError("Expecting byte array of length ".concat(fieldType[1], ", but got ").concat(value.length, " bytes"));
          }

          for (var i = 0; i < fieldType[1]; i++) {
            serializeField(schema, null, value[i], fieldType[0], writer);
          }
        } else {
          writer.writeArray(value, function (item) {
            serializeField(schema, fieldName, item, fieldType[0], writer);
          });
        }
      } else if (fieldType.kind !== undefined) {
        switch (fieldType.kind) {
          case "option":
            {
              if (value === null || value === undefined) {
                writer.writeU8(0);
              } else {
                writer.writeU8(1);
                serializeField(schema, fieldName, value, fieldType.type, writer);
              }

              break;
            }

          case "map":
            {
              writer.writeU32(value.size);
              value.forEach(function (val, key) {
                serializeField(schema, fieldName, key, fieldType.key, writer);
                serializeField(schema, fieldName, val, fieldType.value, writer);
              });
              break;
            }

          default:
            throw new BorshError("FieldType ".concat(fieldType, " unrecognized"));
        }
      } else {
        serializeStruct(schema, value, writer);
      }
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }

      throw error;
    }
  }

  function serializeStruct(schema, obj, writer) {
    if (typeof obj.borshSerialize === "function") {
      obj.borshSerialize(writer);
      return;
    }

    var structSchema = schema.get(obj.constructor);

    if (!structSchema) {
      throw new BorshError("Class ".concat(obj.constructor.name, " is missing in schema"));
    }

    if (structSchema.kind === "struct") {
      structSchema.fields.map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            fieldName = _ref2[0],
            fieldType = _ref2[1];

        serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
      });
    } else if (structSchema.kind === "enum") {
      var name = obj[structSchema.field];

      for (var idx = 0; idx < structSchema.values.length; ++idx) {
        var _structSchema$values$2 = _slicedToArray(structSchema.values[idx], 2),
            fieldName = _structSchema$values$2[0],
            fieldType = _structSchema$values$2[1];

        if (fieldName === name) {
          writer.writeU8(idx);
          serializeField(schema, fieldName, obj[fieldName], fieldType, writer);
          break;
        }
      }
    } else {
      throw new BorshError("Unexpected schema kind: ".concat(structSchema.kind, " for ").concat(obj.constructor.name));
    }
  } /// Serialize given object using schema of the form:
  /// { class_name -> [ [field_name, field_type], .. ], .. }


  function serialize(schema, obj) {
    var Writer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BinaryWriter;
    var writer = new Writer();
    serializeStruct(schema, obj, writer);
    return writer.toArray();
  }

  var serialize_1 = lib$1.serialize = serialize;

  function deserializeField(schema, fieldName, fieldType, reader) {
    try {
      if (typeof fieldType === "string") {
        return reader["read".concat(capitalizeFirstLetter(fieldType))]();
      }

      if (fieldType instanceof Array) {
        if (typeof fieldType[0] === "number") {
          return reader.readFixedArray(fieldType[0]);
        } else if (typeof fieldType[1] === "number") {
          var arr = [];

          for (var i = 0; i < fieldType[1]; i++) {
            arr.push(deserializeField(schema, null, fieldType[0], reader));
          }

          return arr;
        } else {
          return reader.readArray(function () {
            return deserializeField(schema, fieldName, fieldType[0], reader);
          });
        }
      }

      if (fieldType.kind === "option") {
        var option = reader.readU8();

        if (option) {
          return deserializeField(schema, fieldName, fieldType.type, reader);
        }

        return undefined;
      }

      if (fieldType.kind === "map") {
        var map = new Map();
        var length = reader.readU32();

        for (var _i2 = 0; _i2 < length; _i2++) {
          var key = deserializeField(schema, fieldName, fieldType.key, reader);
          var val = deserializeField(schema, fieldName, fieldType.value, reader);
          map.set(key, val);
        }

        return map;
      }

      return deserializeStruct(schema, fieldType, reader);
    } catch (error) {
      if (error instanceof BorshError) {
        error.addToFieldPath(fieldName);
      }

      throw error;
    }
  }

  function deserializeStruct(schema, classType, reader) {
    if (typeof classType.borshDeserialize === "function") {
      return classType.borshDeserialize(reader);
    }

    var structSchema = schema.get(classType);

    if (!structSchema) {
      throw new BorshError("Class ".concat(classType.name, " is missing in schema"));
    }

    if (structSchema.kind === "struct") {
      var result = {};

      var _iterator2 = _createForOfIteratorHelper(schema.get(classType).fields),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value2 = _slicedToArray(_step2.value, 2),
              fieldName = _step2$value2[0],
              fieldType = _step2$value2[1];

          result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return new classType(result);
    }

    if (structSchema.kind === "enum") {
      var idx = reader.readU8();

      if (idx >= structSchema.values.length) {
        throw new BorshError("Enum index: ".concat(idx, " is out of range"));
      }

      var _structSchema$values$4 = _slicedToArray(structSchema.values[idx], 2),
          _fieldName = _structSchema$values$4[0],
          _fieldType = _structSchema$values$4[1];

      var fieldValue = deserializeField(schema, _fieldName, _fieldType, reader);
      return new classType(_defineProperty({}, _fieldName, fieldValue));
    }

    throw new BorshError("Unexpected schema kind: ".concat(structSchema.kind, " for ").concat(classType.constructor.name));
  } /// Deserializes object from bytes using schema.


  function deserialize(schema, classType, buffer) {
    var Reader = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BinaryReader;
    var reader = new Reader(buffer);
    var result = deserializeStruct(schema, classType, reader);

    if (reader.offset < buffer.length) {
      throw new BorshError("Unexpected ".concat(buffer.length - reader.offset, " bytes after deserialized data"));
    }

    return result;
  }

  var deserialize_1 = lib$1.deserialize = deserialize; /// Deserializes object from bytes using schema, without checking the length read

  function deserializeUnchecked(schema, classType, buffer) {
    var Reader = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : BinaryReader;
    var reader = new Reader(buffer);
    return deserializeStruct(schema, classType, reader);
  }

  deserializeUnchecked_1 = lib$1.deserializeUnchecked = deserializeUnchecked;

  var Layout$3 = {};

  Object.defineProperty(Layout$3, "__esModule", {
    value: true
  });
  Layout$3.s16 = Layout$3.s8 = Layout$3.nu64be = Layout$3.u48be = Layout$3.u40be = Layout$3.u32be = Layout$3.u24be = Layout$3.u16be = nu64 = Layout$3.nu64 = Layout$3.u48 = Layout$3.u40 = u32 = Layout$3.u32 = Layout$3.u24 = u16 = Layout$3.u16 = u8 = Layout$3.u8 = offset = Layout$3.offset = Layout$3.greedy = Layout$3.Constant = Layout$3.UTF8 = Layout$3.CString = Layout$3.Blob = Layout$3.Boolean = Layout$3.BitField = Layout$3.BitStructure = Layout$3.VariantLayout = Layout$3.Union = Layout$3.UnionLayoutDiscriminator = Layout$3.UnionDiscriminator = Layout$3.Structure = Layout$3.Sequence = Layout$3.DoubleBE = Layout$3.Double = Layout$3.FloatBE = Layout$3.Float = Layout$3.NearInt64BE = Layout$3.NearInt64 = Layout$3.NearUInt64BE = Layout$3.NearUInt64 = Layout$3.IntBE = Layout$3.Int = Layout$3.UIntBE = Layout$3.UInt = Layout$3.OffsetLayout = Layout$3.GreedyCount = Layout$3.ExternalLayout = Layout$3.bindConstructorLayout = Layout$3.nameWithProperty = Layout$3.Layout = Layout$3.uint8ArrayToBuffer = Layout$3.checkUint8Array = void 0;
  Layout$3.constant = Layout$3.utf8 = Layout$3.cstr = blob$1 = Layout$3.blob = Layout$3.unionLayoutDiscriminator = Layout$3.union = seq$1 = Layout$3.seq = Layout$3.bits = struct = Layout$3.struct = Layout$3.f64be = Layout$3.f64 = Layout$3.f32be = Layout$3.f32 = Layout$3.ns64be = Layout$3.s48be = Layout$3.s40be = Layout$3.s32be = Layout$3.s24be = Layout$3.s16be = ns64 = Layout$3.ns64 = Layout$3.s48 = Layout$3.s40 = Layout$3.s32 = Layout$3.s24 = void 0;
  var buffer_1 = require$$0$1;
  /* Check if a value is a Uint8Array.
   *
   * @ignore */

  function checkUint8Array(b) {
    if (!(b instanceof Uint8Array)) {
      throw new TypeError('b must be a Uint8Array');
    }
  }

  Layout$3.checkUint8Array = checkUint8Array;
  /* Create a Buffer instance from a Uint8Array.
   *
   * @ignore */

  function uint8ArrayToBuffer(b) {
    checkUint8Array(b);
    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);
  }

  Layout$3.uint8ArrayToBuffer = uint8ArrayToBuffer;
  /**
   * Base class for layout objects.
   *
   * **NOTE** This is an abstract base class; you can create instances
   * if it amuses you, but they won't support the {@link
   * Layout#encode|encode} or {@link Layout#decode|decode} functions.
   *
   * @param {Number} span - Initializer for {@link Layout#span|span}.  The
   * parameter must be an integer; a negative value signifies that the
   * span is {@link Layout#getSpan|value-specific}.
   *
   * @param {string} [property] - Initializer for {@link
   * Layout#property|property}.
   *
   * @abstract
   */

  var Layout$2 = /*#__PURE__*/function () {
    function Layout(span, property) {
      _classCallCheck(this, Layout);

      if (!Number.isInteger(span)) {
        throw new TypeError('span must be an integer');
      }
      /** The span of the layout in bytes.
       *
       * Positive values are generally expected.
       *
       * Zero will only appear in {@link Constant}s and in {@link
       * Sequence}s where the {@link Sequence#count|count} is zero.
       *
       * A negative value indicates that the span is value-specific, and
       * must be obtained using {@link Layout#getSpan|getSpan}. */


      this.span = span;
      /** The property name used when this layout is represented in an
       * Object.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances.  If left undefined the span of the unnamed layout will
       * be treated as padding: it will not be mutated by {@link
       * Layout#encode|encode} nor represented as a property in the
       * decoded Object. */

      this.property = property;
    }
    /** Function to create an Object into which decoded properties will
     * be written.
     *
     * Used only for layouts that {@link Layout#decode|decode} to Object
     * instances, which means:
     * * {@link Structure}
     * * {@link Union}
     * * {@link VariantLayout}
     * * {@link BitStructure}
     *
     * If left undefined the JavaScript representation of these layouts
     * will be Object instances.
     *
     * See {@link bindConstructorLayout}.
     */


    _createClass(Layout, [{
      key: "makeDestinationObject",
      value: function makeDestinationObject() {
        return {};
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Uint8Array} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */

    }, {
      key: "getSpan",
      value: function getSpan(b, offset) {
        if (0 > this.span) {
          throw new RangeError('indeterminate span');
        }

        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */

    }, {
      key: "replicate",
      value: function replicate(property) {
        var rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */

    }, {
      key: "fromArray",
      value: function fromArray(values) {
        return undefined;
      }
    }]);

    return Layout;
  }();

  Layout$3.Layout = Layout$2;
  /* Provide text that carries a name (such as for a function that will
   * be throwing an error) annotated with the property of a given layout
   * (such as one for which the value was unacceptable).
   *
   * @ignore */

  function nameWithProperty$1(name, lo) {
    if (lo.property) {
      return name + '[' + lo.property + ']';
    }

    return name;
  }

  Layout$3.nameWithProperty = nameWithProperty$1;
  /**
   * Augment a class so that instances can be encoded/decoded using a
   * given layout.
   *
   * Calling this function couples `Class` with `layout` in several ways:
   *
   * * `Class.layout_` becomes a static member property equal to `layout`;
   * * `layout.boundConstructor_` becomes a static member property equal
   *    to `Class`;
   * * The {@link Layout#makeDestinationObject|makeDestinationObject()}
   *   property of `layout` is set to a function that returns a `new
   *   Class()`;
   * * `Class.decode(b, offset)` becomes a static member function that
   *   delegates to {@link Layout#decode|layout.decode}.  The
   *   synthesized function may be captured and extended.
   * * `Class.prototype.encode(b, offset)` provides an instance member
   *   function that delegates to {@link Layout#encode|layout.encode}
   *   with `src` set to `this`.  The synthesized function may be
   *   captured and extended, but when the extension is invoked `this`
   *   must be explicitly bound to the instance.
   *
   * @param {class} Class - a JavaScript class with a nullary
   * constructor.
   *
   * @param {Layout} layout - the {@link Layout} instance used to encode
   * instances of `Class`.
   */
  // `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types

  function bindConstructorLayout$1(Class, layout) {
    if ('function' !== typeof Class) {
      throw new TypeError('Class must be constructor');
    }

    if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {
      throw new Error('Class is already bound to a layout');
    }

    if (!(layout && layout instanceof Layout$2)) {
      throw new TypeError('layout must be a Layout');
    }

    if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {
      throw new Error('layout is already bound to a constructor');
    }

    Class.layout_ = layout;
    layout.boundConstructor_ = Class;

    layout.makeDestinationObject = function () {
      return new Class();
    };

    Object.defineProperty(Class.prototype, 'encode', {
      value: function value(b, offset) {
        return layout.encode(this, b, offset);
      },
      writable: true
    });
    Object.defineProperty(Class, 'decode', {
      value: function value(b, offset) {
        return layout.decode(b, offset);
      },
      writable: true
    });
  }

  Layout$3.bindConstructorLayout = bindConstructorLayout$1;
  /**
   * An object that behaves like a layout but does not consume space
   * within its containing layout.
   *
   * This is primarily used to obtain metadata about a member, such as a
   * {@link OffsetLayout} that can provide data about a {@link
   * Layout#getSpan|value-specific span}.
   *
   * **NOTE** This is an abstract base class; you can create instances
   * if it amuses you, but they won't support {@link
   * ExternalLayout#isCount|isCount} or other {@link Layout} functions.
   *
   * @param {Number} span - initializer for {@link Layout#span|span}.
   * The parameter can range from 1 through 6.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @abstract
   * @augments {Layout}
   */

  var ExternalLayout$1 = /*#__PURE__*/function (_Layout) {
    _inherits(ExternalLayout, _Layout);

    var _super = _createSuper(ExternalLayout);

    function ExternalLayout() {
      _classCallCheck(this, ExternalLayout);

      return _super.apply(this, arguments);
    }

    _createClass(ExternalLayout, [{
      key: "isCount",
      value:
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      function isCount() {
        throw new Error('ExternalLayout is abstract');
      }
    }]);

    return ExternalLayout;
  }(Layout$2);

  Layout$3.ExternalLayout = ExternalLayout$1;
  /**
   * An {@link ExternalLayout} that determines its {@link
   * Layout#decode|value} based on offset into and length of the buffer
   * on which it is invoked.
   *
   * *Factory*: {@link module:Layout.greedy|greedy}
   *
   * @param {Number} [elementSpan] - initializer for {@link
   * GreedyCount#elementSpan|elementSpan}.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {ExternalLayout}
   */

  var GreedyCount$1 = /*#__PURE__*/function (_ExternalLayout) {
    _inherits(GreedyCount, _ExternalLayout);

    var _super2 = _createSuper(GreedyCount);

    function GreedyCount() {
      var _this;

      var elementSpan = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var property = arguments.length > 1 ? arguments[1] : undefined;

      _classCallCheck(this, GreedyCount);

      if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
        throw new TypeError('elementSpan must be a (positive) integer');
      }

      _this = _super2.call(this, -1, property);
      /** The layout for individual elements of the sequence.  The value
       * must be a positive integer.  If not provided, the value will be
       * 1. */

      _this.elementSpan = elementSpan;
      return _this;
    }
    /** @override */


    _createClass(GreedyCount, [{
      key: "isCount",
      value: function isCount() {
        return true;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        checkUint8Array(b);
        var rem = b.length - offset;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        return 0;
      }
    }]);

    return GreedyCount;
  }(ExternalLayout$1);

  Layout$3.GreedyCount = GreedyCount$1;
  /**
   * An {@link ExternalLayout} that supports accessing a {@link Layout}
   * at a fixed offset from the start of another Layout.  The offset may
   * be before, within, or after the base layout.
   *
   * *Factory*: {@link module:Layout.offset|offset}
   *
   * @param {Layout} layout - initializer for {@link
   * OffsetLayout#layout|layout}, modulo `property`.
   *
   * @param {Number} [offset] - Initializes {@link
   * OffsetLayout#offset|offset}.  Defaults to zero.
   *
   * @param {string} [property] - Optional new property name for a
   * {@link Layout#replicate| replica} of `layout` to be used as {@link
   * OffsetLayout#layout|layout}.  If not provided the `layout` is used
   * unchanged.
   *
   * @augments {Layout}
   */

  var OffsetLayout$1 = /*#__PURE__*/function (_ExternalLayout2) {
    _inherits(OffsetLayout, _ExternalLayout2);

    var _super3 = _createSuper(OffsetLayout);

    function OffsetLayout(layout) {
      var _this2;

      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var property = arguments.length > 2 ? arguments[2] : undefined;

      _classCallCheck(this, OffsetLayout);

      if (!(layout instanceof Layout$2)) {
        throw new TypeError('layout must be a Layout');
      }

      if (!Number.isInteger(offset)) {
        throw new TypeError('offset must be integer or undefined');
      }

      _this2 = _super3.call(this, layout.span, property || layout.property);
      /** The subordinated layout. */

      _this2.layout = layout;
      /** The location of {@link OffsetLayout#layout} relative to the
       * start of another layout.
       *
       * The value may be positive or negative, but an error will thrown
       * if at the point of use it goes outside the span of the Uint8Array
       * being accessed.  */

      _this2.offset = offset;
      return _this2;
    }
    /** @override */


    _createClass(OffsetLayout, [{
      key: "isCount",
      value: function isCount() {
        return this.layout instanceof UInt$1 || this.layout instanceof UIntBE$1;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return this.layout.decode(b, offset + this.offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return this.layout.encode(src, b, offset + this.offset);
      }
    }]);

    return OffsetLayout;
  }(ExternalLayout$1);

  Layout$3.OffsetLayout = OffsetLayout$1;
  /**
   * Represent an unsigned integer in little-endian format.
   *
   * *Factory*: {@link module:Layout.u8|u8}, {@link
   *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link
   *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link
   *  module:Layout.u48|u48}
   *
   * @param {Number} span - initializer for {@link Layout#span|span}.
   * The parameter can range from 1 through 6.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var UInt$1 = /*#__PURE__*/function (_Layout2) {
    _inherits(UInt, _Layout2);

    var _super4 = _createSuper(UInt);

    function UInt(span, property) {
      var _this3;

      _classCallCheck(this, UInt);

      _this3 = _super4.call(this, span, property);

      if (6 < _this3.span) {
        throw new RangeError('span must not exceed 6 bytes');
      }

      return _this3;
    }
    /** @override */


    _createClass(UInt, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);
        return this.span;
      }
    }]);

    return UInt;
  }(Layout$2);

  Layout$3.UInt = UInt$1;
  /**
   * Represent an unsigned integer in big-endian format.
   *
   * *Factory*: {@link module:Layout.u8be|u8be}, {@link
   * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},
   * {@link module:Layout.u32be|u32be}, {@link
   * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}
   *
   * @param {Number} span - initializer for {@link Layout#span|span}.
   * The parameter can range from 1 through 6.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var UIntBE$1 = /*#__PURE__*/function (_Layout3) {
    _inherits(UIntBE, _Layout3);

    var _super5 = _createSuper(UIntBE);

    function UIntBE(span, property) {
      var _this4;

      _classCallCheck(this, UIntBE);

      _this4 = _super5.call(this, span, property);

      if (6 < _this4.span) {
        throw new RangeError('span must not exceed 6 bytes');
      }

      return _this4;
    }
    /** @override */


    _createClass(UIntBE, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);
        return this.span;
      }
    }]);

    return UIntBE;
  }(Layout$2);

  Layout$3.UIntBE = UIntBE$1;
  /**
   * Represent a signed integer in little-endian format.
   *
   * *Factory*: {@link module:Layout.s8|s8}, {@link
   *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link
   *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link
   *  module:Layout.s48|s48}
   *
   * @param {Number} span - initializer for {@link Layout#span|span}.
   * The parameter can range from 1 through 6.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var Int$1 = /*#__PURE__*/function (_Layout4) {
    _inherits(Int, _Layout4);

    var _super6 = _createSuper(Int);

    function Int(span, property) {
      var _this5;

      _classCallCheck(this, Int);

      _this5 = _super6.call(this, span, property);

      if (6 < _this5.span) {
        throw new RangeError('span must not exceed 6 bytes');
      }

      return _this5;
    }
    /** @override */


    _createClass(Int, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);
        return this.span;
      }
    }]);

    return Int;
  }(Layout$2);

  Layout$3.Int = Int$1;
  /**
   * Represent a signed integer in big-endian format.
   *
   * *Factory*: {@link module:Layout.s8be|s8be}, {@link
   * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},
   * {@link module:Layout.s32be|s32be}, {@link
   * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}
   *
   * @param {Number} span - initializer for {@link Layout#span|span}.
   * The parameter can range from 1 through 6.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var IntBE$1 = /*#__PURE__*/function (_Layout5) {
    _inherits(IntBE, _Layout5);

    var _super7 = _createSuper(IntBE);

    function IntBE(span, property) {
      var _this6;

      _classCallCheck(this, IntBE);

      _this6 = _super7.call(this, span, property);

      if (6 < _this6.span) {
        throw new RangeError('span must not exceed 6 bytes');
      }

      return _this6;
    }
    /** @override */


    _createClass(IntBE, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);
        return this.span;
      }
    }]);

    return IntBE;
  }(Layout$2);

  Layout$3.IntBE = IntBE$1;
  var V2E32$1 = Math.pow(2, 32);
  /* True modulus high and low 32-bit words, where low word is always
   * non-negative. */

  function divmodInt64$1(src) {
    var hi32 = Math.floor(src / V2E32$1);
    var lo32 = src - hi32 * V2E32$1;
    return {
      hi32: hi32,
      lo32: lo32
    };
  }
  /* Reconstruct Number from quotient and non-negative remainder */


  function roundedInt64$1(hi32, lo32) {
    return hi32 * V2E32$1 + lo32;
  }
  /**
   * Represent an unsigned 64-bit integer in little-endian format when
   * encoded and as a near integral JavaScript Number when decoded.
   *
   * *Factory*: {@link module:Layout.nu64|nu64}
   *
   * **NOTE** Values with magnitude greater than 2^52 may not decode to
   * the exact value of the encoded representation.
   *
   * @augments {Layout}
   */


  var NearUInt64$1 = /*#__PURE__*/function (_Layout6) {
    _inherits(NearUInt64, _Layout6);

    var _super8 = _createSuper(NearUInt64);

    function NearUInt64(property) {
      _classCallCheck(this, NearUInt64);

      return _super8.call(this, 8, property);
    }
    /** @override */


    _createClass(NearUInt64, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var buffer = uint8ArrayToBuffer(b);
        var lo32 = buffer.readUInt32LE(offset);
        var hi32 = buffer.readUInt32LE(offset + 4);
        return roundedInt64$1(hi32, lo32);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var split = divmodInt64$1(src);
        var buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split.lo32, offset);
        buffer.writeUInt32LE(split.hi32, offset + 4);
        return 8;
      }
    }]);

    return NearUInt64;
  }(Layout$2);

  Layout$3.NearUInt64 = NearUInt64$1;
  /**
   * Represent an unsigned 64-bit integer in big-endian format when
   * encoded and as a near integral JavaScript Number when decoded.
   *
   * *Factory*: {@link module:Layout.nu64be|nu64be}
   *
   * **NOTE** Values with magnitude greater than 2^52 may not decode to
   * the exact value of the encoded representation.
   *
   * @augments {Layout}
   */

  var NearUInt64BE$1 = /*#__PURE__*/function (_Layout7) {
    _inherits(NearUInt64BE, _Layout7);

    var _super9 = _createSuper(NearUInt64BE);

    function NearUInt64BE(property) {
      _classCallCheck(this, NearUInt64BE);

      return _super9.call(this, 8, property);
    }
    /** @override */


    _createClass(NearUInt64BE, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var buffer = uint8ArrayToBuffer(b);
        var hi32 = buffer.readUInt32BE(offset);
        var lo32 = buffer.readUInt32BE(offset + 4);
        return roundedInt64$1(hi32, lo32);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var split = divmodInt64$1(src);
        var buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32BE(split.hi32, offset);
        buffer.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    }]);

    return NearUInt64BE;
  }(Layout$2);

  Layout$3.NearUInt64BE = NearUInt64BE$1;
  /**
   * Represent a signed 64-bit integer in little-endian format when
   * encoded and as a near integral JavaScript Number when decoded.
   *
   * *Factory*: {@link module:Layout.ns64|ns64}
   *
   * **NOTE** Values with magnitude greater than 2^52 may not decode to
   * the exact value of the encoded representation.
   *
   * @augments {Layout}
   */

  var NearInt64$1 = /*#__PURE__*/function (_Layout8) {
    _inherits(NearInt64, _Layout8);

    var _super10 = _createSuper(NearInt64);

    function NearInt64(property) {
      _classCallCheck(this, NearInt64);

      return _super10.call(this, 8, property);
    }
    /** @override */


    _createClass(NearInt64, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var buffer = uint8ArrayToBuffer(b);
        var lo32 = buffer.readUInt32LE(offset);
        var hi32 = buffer.readInt32LE(offset + 4);
        return roundedInt64$1(hi32, lo32);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var split = divmodInt64$1(src);
        var buffer = uint8ArrayToBuffer(b);
        buffer.writeUInt32LE(split.lo32, offset);
        buffer.writeInt32LE(split.hi32, offset + 4);
        return 8;
      }
    }]);

    return NearInt64;
  }(Layout$2);

  Layout$3.NearInt64 = NearInt64$1;
  /**
   * Represent a signed 64-bit integer in big-endian format when
   * encoded and as a near integral JavaScript Number when decoded.
   *
   * *Factory*: {@link module:Layout.ns64be|ns64be}
   *
   * **NOTE** Values with magnitude greater than 2^52 may not decode to
   * the exact value of the encoded representation.
   *
   * @augments {Layout}
   */

  var NearInt64BE$1 = /*#__PURE__*/function (_Layout9) {
    _inherits(NearInt64BE, _Layout9);

    var _super11 = _createSuper(NearInt64BE);

    function NearInt64BE(property) {
      _classCallCheck(this, NearInt64BE);

      return _super11.call(this, 8, property);
    }
    /** @override */


    _createClass(NearInt64BE, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var buffer = uint8ArrayToBuffer(b);
        var hi32 = buffer.readInt32BE(offset);
        var lo32 = buffer.readUInt32BE(offset + 4);
        return roundedInt64$1(hi32, lo32);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var split = divmodInt64$1(src);
        var buffer = uint8ArrayToBuffer(b);
        buffer.writeInt32BE(split.hi32, offset);
        buffer.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    }]);

    return NearInt64BE;
  }(Layout$2);

  Layout$3.NearInt64BE = NearInt64BE$1;
  /**
   * Represent a 32-bit floating point number in little-endian format.
   *
   * *Factory*: {@link module:Layout.f32|f32}
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var Float$1 = /*#__PURE__*/function (_Layout10) {
    _inherits(Float, _Layout10);

    var _super12 = _createSuper(Float);

    function Float(property) {
      _classCallCheck(this, Float);

      return _super12.call(this, 4, property);
    }
    /** @override */


    _createClass(Float, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return uint8ArrayToBuffer(b).readFloatLE(offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        uint8ArrayToBuffer(b).writeFloatLE(src, offset);
        return 4;
      }
    }]);

    return Float;
  }(Layout$2);

  Layout$3.Float = Float$1;
  /**
   * Represent a 32-bit floating point number in big-endian format.
   *
   * *Factory*: {@link module:Layout.f32be|f32be}
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var FloatBE$1 = /*#__PURE__*/function (_Layout11) {
    _inherits(FloatBE, _Layout11);

    var _super13 = _createSuper(FloatBE);

    function FloatBE(property) {
      _classCallCheck(this, FloatBE);

      return _super13.call(this, 4, property);
    }
    /** @override */


    _createClass(FloatBE, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return uint8ArrayToBuffer(b).readFloatBE(offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        uint8ArrayToBuffer(b).writeFloatBE(src, offset);
        return 4;
      }
    }]);

    return FloatBE;
  }(Layout$2);

  Layout$3.FloatBE = FloatBE$1;
  /**
   * Represent a 64-bit floating point number in little-endian format.
   *
   * *Factory*: {@link module:Layout.f64|f64}
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var Double$1 = /*#__PURE__*/function (_Layout12) {
    _inherits(Double, _Layout12);

    var _super14 = _createSuper(Double);

    function Double(property) {
      _classCallCheck(this, Double);

      return _super14.call(this, 8, property);
    }
    /** @override */


    _createClass(Double, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return uint8ArrayToBuffer(b).readDoubleLE(offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);
        return 8;
      }
    }]);

    return Double;
  }(Layout$2);

  Layout$3.Double = Double$1;
  /**
   * Represent a 64-bit floating point number in big-endian format.
   *
   * *Factory*: {@link module:Layout.f64be|f64be}
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var DoubleBE$1 = /*#__PURE__*/function (_Layout13) {
    _inherits(DoubleBE, _Layout13);

    var _super15 = _createSuper(DoubleBE);

    function DoubleBE(property) {
      _classCallCheck(this, DoubleBE);

      return _super15.call(this, 8, property);
    }
    /** @override */


    _createClass(DoubleBE, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        return uint8ArrayToBuffer(b).readDoubleBE(offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);
        return 8;
      }
    }]);

    return DoubleBE;
  }(Layout$2);

  Layout$3.DoubleBE = DoubleBE$1;
  /**
   * Represent a contiguous sequence of a specific layout as an Array.
   *
   * *Factory*: {@link module:Layout.seq|seq}
   *
   * @param {Layout} elementLayout - initializer for {@link
   * Sequence#elementLayout|elementLayout}.
   *
   * @param {(Number|ExternalLayout)} count - initializer for {@link
   * Sequence#count|count}.  The parameter must be either a positive
   * integer or an instance of {@link ExternalLayout}.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var Sequence$1 = /*#__PURE__*/function (_Layout14) {
    _inherits(Sequence, _Layout14);

    var _super16 = _createSuper(Sequence);

    function Sequence(elementLayout, count, property) {
      var _this7;

      _classCallCheck(this, Sequence);

      if (!(elementLayout instanceof Layout$2)) {
        throw new TypeError('elementLayout must be a Layout');
      }

      if (!(count instanceof ExternalLayout$1 && count.isCount() || Number.isInteger(count) && 0 <= count)) {
        throw new TypeError('count must be non-negative integer ' + 'or an unsigned integer ExternalLayout');
      }

      var span = -1;

      if (!(count instanceof ExternalLayout$1) && 0 < elementLayout.span) {
        span = count * elementLayout.span;
      }

      _this7 = _super16.call(this, span, property);
      /** The layout for individual elements of the sequence. */

      _this7.elementLayout = elementLayout;
      /** The number of elements in the sequence.
       *
       * This will be either a non-negative integer or an instance of
       * {@link ExternalLayout} for which {@link
       * ExternalLayout#isCount|isCount()} is `true`. */

      _this7.count = count;
      return _this7;
    }
    /** @override */


    _createClass(Sequence, [{
      key: "getSpan",
      value: function getSpan(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (0 <= this.span) {
          return this.span;
        }

        var span = 0;
        var count = this.count;

        if (count instanceof ExternalLayout$1) {
          count = count.decode(b, offset);
        }

        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          var idx = 0;

          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset + span);
            ++idx;
          }
        }

        return span;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var rv = [];
        var i = 0;
        var count = this.count;

        if (count instanceof ExternalLayout$1) {
          count = count.decode(b, offset);
        }

        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset));
          offset += this.elementLayout.getSpan(b, offset);
          i += 1;
        }

        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var elo = this.elementLayout;
        var span = src.reduce(function (span, v) {
          return span + elo.encode(v, b, offset + span);
        }, 0);

        if (this.count instanceof ExternalLayout$1) {
          this.count.encode(src.length, b, offset);
        }

        return span;
      }
    }]);

    return Sequence;
  }(Layout$2);

  Layout$3.Sequence = Sequence$1;
  /**
   * Represent a contiguous sequence of arbitrary layout elements as an
   * Object.
   *
   * *Factory*: {@link module:Layout.struct|struct}
   *
   * **NOTE** The {@link Layout#span|span} of the structure is variable
   * if any layout in {@link Structure#fields|fields} has a variable
   * span.  When {@link Layout#encode|encoding} we must have a value for
   * all variable-length fields, or we wouldn't be able to figure out
   * how much space to use for storage.  We can only identify the value
   * for a field when it has a {@link Layout#property|property}.  As
   * such, although a structure may contain both unnamed fields and
   * variable-length fields, it cannot contain an unnamed
   * variable-length field.
   *
   * @param {Layout[]} fields - initializer for {@link
   * Structure#fields|fields}.  An error is raised if this contains a
   * variable-length field for which a {@link Layout#property|property}
   * is not defined.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @param {Boolean} [decodePrefixes] - initializer for {@link
   * Structure#decodePrefixes|property}.
   *
   * @throws {Error} - if `fields` contains an unnamed variable-length
   * layout.
   *
   * @augments {Layout}
   */

  var Structure$1 = /*#__PURE__*/function (_Layout15) {
    _inherits(Structure, _Layout15);

    var _super17 = _createSuper(Structure);

    function Structure(fields, property, decodePrefixes) {
      var _this8;

      _classCallCheck(this, Structure);

      if (!(Array.isArray(fields) && fields.reduce(function (acc, v) {
        return acc && v instanceof Layout$2;
      }, true))) {
        throw new TypeError('fields must be array of Layout instances');
      }

      if ('boolean' === typeof property && undefined === decodePrefixes) {
        decodePrefixes = property;
        property = undefined;
      }
      /* Verify absence of unnamed variable-length fields. */


      var _iterator = _createForOfIteratorHelper(fields),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var fd = _step.value;

          if (0 > fd.span && undefined === fd.property) {
            throw new Error('fields cannot contain unnamed variable-length layout');
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var span = -1;

      try {
        span = fields.reduce(function (span, fd) {
          return span + fd.getSpan();
        }, 0);
      } catch (e) {// ignore error
      }

      _this8 = _super17.call(this, span, property);
      /** The sequence of {@link Layout} values that comprise the
       * structure.
       *
       * The individual elements need not be the same type, and may be
       * either scalar or aggregate layouts.  If a member layout leaves
       * its {@link Layout#property|property} undefined the
       * corresponding region of the buffer associated with the element
       * will not be mutated.
       *
       * @type {Layout[]} */

      _this8.fields = fields;
      /** Control behavior of {@link Layout#decode|decode()} given short
       * buffers.
       *
       * In some situations a structure many be extended with additional
       * fields over time, with older installations providing only a
       * prefix of the full structure.  If this property is `true`
       * decoding will accept those buffers and leave subsequent fields
       * undefined, as long as the buffer ends at a field boundary.
       * Defaults to `false`. */

      _this8.decodePrefixes = !!decodePrefixes;
      return _this8;
    }
    /** @override */


    _createClass(Structure, [{
      key: "getSpan",
      value: function getSpan(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (0 <= this.span) {
          return this.span;
        }

        var span = 0;

        try {
          span = this.fields.reduce(function (span, fd) {
            var fsp = fd.getSpan(b, offset);
            offset += fsp;
            return span + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError('indeterminate span');
        }

        return span;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        checkUint8Array(b);
        var dest = this.makeDestinationObject();

        var _iterator2 = _createForOfIteratorHelper(this.fields),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var fd = _step2.value;

            if (undefined !== fd.property) {
              dest[fd.property] = fd.decode(b, offset);
            }

            offset += fd.getSpan(b, offset);

            if (this.decodePrefixes && b.length === offset) {
              break;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var firstOffset = offset;
        var lastOffset = 0;
        var lastWrote = 0;

        var _iterator3 = _createForOfIteratorHelper(this.fields),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var fd = _step3.value;
            var span = fd.span;
            lastWrote = 0 < span ? span : 0;

            if (undefined !== fd.property) {
              var fv = src[fd.property];

              if (undefined !== fv) {
                lastWrote = fd.encode(fv, b, offset);

                if (0 > span) {
                  /* Read the as-encoded span, which is not necessarily the
                   * same as what we wrote. */
                  span = fd.getSpan(b, offset);
                }
              }
            }

            lastOffset = offset;
            offset += span;
          }
          /* Use (lastOffset + lastWrote) instead of offset because the last
           * item may have had a dynamic length and we don't want to include
           * the padding between it and the end of the space reserved for
           * it. */

        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */

    }, {
      key: "fromArray",
      value: function fromArray(values) {
        var dest = this.makeDestinationObject();

        var _iterator4 = _createForOfIteratorHelper(this.fields),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var fd = _step4.value;

            if (undefined !== fd.property && 0 < values.length) {
              dest[fd.property] = values.shift();
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */

    }, {
      key: "layoutFor",
      value: function layoutFor(property) {
        if ('string' !== typeof property) {
          throw new TypeError('property must be string');
        }

        var _iterator5 = _createForOfIteratorHelper(this.fields),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var fd = _step5.value;

            if (fd.property === property) {
              return fd;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return undefined;
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */

    }, {
      key: "offsetOf",
      value: function offsetOf(property) {
        if ('string' !== typeof property) {
          throw new TypeError('property must be string');
        }

        var offset = 0;

        var _iterator6 = _createForOfIteratorHelper(this.fields),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var fd = _step6.value;

            if (fd.property === property) {
              return offset;
            }

            if (0 > fd.span) {
              offset = -1;
            } else if (0 <= offset) {
              offset += fd.span;
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        return undefined;
      }
    }]);

    return Structure;
  }(Layout$2);

  Layout$3.Structure = Structure$1;
  /**
   * An object that can provide a {@link
   * Union#discriminator|discriminator} API for {@link Union}.
   *
   * **NOTE** This is an abstract base class; you can create instances
   * if it amuses you, but they won't support the {@link
   * UnionDiscriminator#encode|encode} or {@link
   * UnionDiscriminator#decode|decode} functions.
   *
   * @param {string} [property] - Default for {@link
   * UnionDiscriminator#property|property}.
   *
   * @abstract
   */

  var UnionDiscriminator$1 = /*#__PURE__*/function () {
    function UnionDiscriminator(property) {
      _classCallCheck(this, UnionDiscriminator);

      /** The {@link Layout#property|property} to be used when the
       * discriminator is referenced in isolation (generally when {@link
       * Union#decode|Union decode} cannot delegate to a specific
       * variant). */
      this.property = property;
    }
    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
     *
     * The implementation of this method need not reference the buffer if
     * variant information is available through other means. */


    _createClass(UnionDiscriminator, [{
      key: "decode",
      value: function decode(b, offset) {
        throw new Error('UnionDiscriminator is abstract');
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        throw new Error('UnionDiscriminator is abstract');
      }
    }]);

    return UnionDiscriminator;
  }();

  Layout$3.UnionDiscriminator = UnionDiscriminator$1;
  /**
   * An object that can provide a {@link
   * UnionDiscriminator|discriminator API} for {@link Union} using an
   * unsigned integral {@link Layout} instance located either inside or
   * outside the union.
   *
   * @param {ExternalLayout} layout - initializes {@link
   * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link
   * ExternalLayout#isCount|isCount()}.
   *
   * @param {string} [property] - Default for {@link
   * UnionDiscriminator#property|property}, superseding the property
   * from `layout`, but defaulting to `variant` if neither `property`
   * nor layout provide a property name.
   *
   * @augments {UnionDiscriminator}
   */

  var UnionLayoutDiscriminator$1 = /*#__PURE__*/function (_UnionDiscriminator) {
    _inherits(UnionLayoutDiscriminator, _UnionDiscriminator);

    var _super18 = _createSuper(UnionLayoutDiscriminator);

    function UnionLayoutDiscriminator(layout, property) {
      var _this9;

      _classCallCheck(this, UnionLayoutDiscriminator);

      if (!(layout instanceof ExternalLayout$1 && layout.isCount())) {
        throw new TypeError('layout must be an unsigned integer ExternalLayout');
      }

      _this9 = _super18.call(this, property || layout.property || 'variant');
      /** The {@link ExternalLayout} used to access the discriminator
       * value. */

      _this9.layout = layout;
      return _this9;
    }
    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */


    _createClass(UnionLayoutDiscriminator, [{
      key: "decode",
      value: function decode(b, offset) {
        return this.layout.decode(b, offset);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        return this.layout.encode(src, b, offset);
      }
    }]);

    return UnionLayoutDiscriminator;
  }(UnionDiscriminator$1);

  Layout$3.UnionLayoutDiscriminator = UnionLayoutDiscriminator$1;
  /**
   * Represent any number of span-compatible layouts.
   *
   * *Factory*: {@link module:Layout.union|union}
   *
   * If the union has a {@link Union#defaultLayout|default layout} that
   * layout must have a non-negative {@link Layout#span|span}.  The span
   * of a fixed-span union includes its {@link
   * Union#discriminator|discriminator} if the variant is a {@link
   * Union#usesPrefixDiscriminator|prefix of the union}, plus the span
   * of its {@link Union#defaultLayout|default layout}.
   *
   * If the union does not have a default layout then the encoded span
   * of the union depends on the encoded span of its variant (which may
   * be fixed or variable).
   *
   * {@link VariantLayout#layout|Variant layout}s are added through
   * {@link Union#addVariant|addVariant}.  If the union has a default
   * layout, the span of the {@link VariantLayout#layout|layout
   * contained by the variant} must not exceed the span of the {@link
   * Union#defaultLayout|default layout} (minus the span of a {@link
   * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The
   * span of the variant will equal the span of the union itself.
   *
   * The variant for a buffer can only be identified from the {@link
   * Union#discriminator|discriminator} {@link
   * UnionDiscriminator#property|property} (in the case of the {@link
   * Union#defaultLayout|default layout}), or by using {@link
   * Union#getVariant|getVariant} and examining the resulting {@link
   * VariantLayout} instance.
   *
   * A variant compatible with a JavaScript object can be identified
   * using {@link Union#getSourceVariant|getSourceVariant}.
   *
   * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to
   * identify the layout used to interpret the union contents.  The
   * parameter must be an instance of {@link UnionDiscriminator}, an
   * {@link ExternalLayout} that satisfies {@link
   * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link
   * UIntBE}).  When a non-external layout element is passed the layout
   * appears at the start of the union.  In all cases the (synthesized)
   * {@link UnionDiscriminator} instance is recorded as {@link
   * Union#discriminator|discriminator}.
   *
   * @param {(Layout|null)} defaultLayout - initializer for {@link
   * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.
   * If `null` there is no default layout: the union has data-dependent
   * length and attempts to decode or encode unrecognized variants will
   * throw an exception.  A {@link Layout} instance must have a
   * non-negative {@link Layout#span|span}, and if it lacks a {@link
   * Layout#property|property} the {@link
   * Union#defaultLayout|defaultLayout} will be a {@link
   * Layout#replicate|replica} with property `content`.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var Union$1 = /*#__PURE__*/function (_Layout16) {
    _inherits(Union, _Layout16);

    var _super19 = _createSuper(Union);

    function Union(discr, defaultLayout, property) {
      var _this10;

      _classCallCheck(this, Union);

      var discriminator;

      if (discr instanceof UInt$1 || discr instanceof UIntBE$1) {
        discriminator = new UnionLayoutDiscriminator$1(new OffsetLayout$1(discr));
      } else if (discr instanceof ExternalLayout$1 && discr.isCount()) {
        discriminator = new UnionLayoutDiscriminator$1(discr);
      } else if (!(discr instanceof UnionDiscriminator$1)) {
        throw new TypeError('discr must be a UnionDiscriminator ' + 'or an unsigned integer layout');
      } else {
        discriminator = discr;
      }

      if (undefined === defaultLayout) {
        defaultLayout = null;
      }

      if (!(null === defaultLayout || defaultLayout instanceof Layout$2)) {
        throw new TypeError('defaultLayout must be null or a Layout');
      }

      if (null !== defaultLayout) {
        if (0 > defaultLayout.span) {
          throw new Error('defaultLayout must have constant span');
        }

        if (undefined === defaultLayout.property) {
          defaultLayout = defaultLayout.replicate('content');
        }
      }
      /* The union span can be estimated only if there's a default
       * layout.  The union spans its default layout, plus any prefix
       * variant layout.  By construction both layouts, if present, have
       * non-negative span. */


      var span = -1;

      if (defaultLayout) {
        span = defaultLayout.span;

        if (0 <= span && (discr instanceof UInt$1 || discr instanceof UIntBE$1)) {
          span += discriminator.layout.span;
        }
      }

      _this10 = _super19.call(this, span, property);
      /** The interface for the discriminator value in isolation.
       *
       * This a {@link UnionDiscriminator} either passed to the
       * constructor or synthesized from the `discr` constructor
       * argument.  {@link
       * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be
       * `true` iff the `discr` parameter was a non-offset {@link
       * Layout} instance. */

      _this10.discriminator = discriminator;
      /** `true` if the {@link Union#discriminator|discriminator} is the
       * first field in the union.
       *
       * If `false` the discriminator is obtained from somewhere
       * else. */

      _this10.usesPrefixDiscriminator = discr instanceof UInt$1 || discr instanceof UIntBE$1;
      /** The layout for non-discriminator content when the value of the
       * discriminator is not recognized.
       *
       * This is the value passed to the constructor.  It is
       * structurally equivalent to the second component of {@link
       * Union#layout|layout} but may have a different property
       * name. */

      _this10.defaultLayout = defaultLayout;
      /** A registry of allowed variants.
       *
       * The keys are unsigned integers which should be compatible with
       * {@link Union.discriminator|discriminator}.  The property value
       * is the corresponding {@link VariantLayout} instances assigned
       * to this union by {@link Union#addVariant|addVariant}.
       *
       * **NOTE** The registry remains mutable so that variants can be
       * {@link Union#addVariant|added} at any time.  Users should not
       * manipulate the content of this property. */

      _this10.registry = {};
      /* Private variable used when invoking getSourceVariant */

      var boundGetSourceVariant = _this10.defaultGetSourceVariant.bind(_assertThisInitialized(_this10));
      /** Function to infer the variant selected by a source object.
       *
       * Defaults to {@link
       * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may
       * be overridden using {@link
       * Union#configGetSourceVariant|configGetSourceVariant}.
       *
       * @param {Object} src - as with {@link
       * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
       *
       * @returns {(undefined|VariantLayout)} The default variant
       * (`undefined`) or first registered variant that uses a property
       * available in `src`. */


      _this10.getSourceVariant = function (src) {
        return boundGetSourceVariant(src);
      };
      /** Function to override the implementation of {@link
       * Union#getSourceVariant|getSourceVariant}.
       *
       * Use this if the desired variant cannot be identified using the
       * algorithm of {@link
       * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
       *
       * **NOTE** The provided function will be invoked bound to this
       * Union instance, providing local access to {@link
       * Union#registry|registry}.
       *
       * @param {Function} gsv - a function that follows the API of
       * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */


      _this10.configGetSourceVariant = function (gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };

      return _this10;
    }
    /** @override */


    _createClass(Union, [{
      key: "getSpan",
      value: function getSpan(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (0 <= this.span) {
          return this.span;
        }
        /* Default layouts always have non-negative span, so we don't have
         * one and we have to recognize the variant which will in turn
         * determine the span. */


        var vlo = this.getVariant(b, offset);

        if (!vlo) {
          throw new Error('unable to determine span for unrecognized variant');
        }

        return vlo.getSpan(b, offset);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisfied rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */

    }, {
      key: "defaultGetSourceVariant",
      value: function defaultGetSourceVariant(src) {
        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {
          if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {
            return undefined;
          }

          var vlo = this.registry[src[this.discriminator.property]];

          if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {
            return vlo;
          }
        } else {
          for (var tag in this.registry) {
            var _vlo = this.registry[tag];

            if (_vlo.property && Object.prototype.hasOwnProperty.call(src, _vlo.property)) {
              return _vlo;
            }
          }
        }

        throw new Error('unable to infer src variant');
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */

    }, {
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var dest;
        var dlo = this.discriminator;
        var discr = dlo.decode(b, offset);
        var clo = this.registry[discr];

        if (undefined === clo) {
          var defaultLayout = this.defaultLayout;
          var contentOffset = 0;

          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }

          dest = this.makeDestinationObject();
          dest[dlo.property] = discr; // defaultLayout.property can be undefined, but this is allowed by buffer-layout
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

          dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);
        } else {
          dest = clo.decode(b, offset);
        }

        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var vlo = this.getSourceVariant(src);

        if (undefined === vlo) {
          var dlo = this.discriminator; // this.defaultLayout is not undefined when vlo is undefined
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

          var clo = this.defaultLayout;
          var contentOffset = 0;

          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }

          dlo.encode(src[dlo.property], b, offset); // clo.property is not undefined when vlo is undefined
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

          return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
        }

        return vlo.encode(src, b, offset);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */

    }, {
      key: "addVariant",
      value: function addVariant(variant, layout, property) {
        var rv = new VariantLayout$1(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Uint8Array)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Uint8Array}.
       *
       * @return {({VariantLayout}|undefined)}
       */

    }, {
      key: "getVariant",
      value: function getVariant(vb) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var variant;

        if (vb instanceof Uint8Array) {
          variant = this.discriminator.decode(vb, offset);
        } else {
          variant = vb;
        }

        return this.registry[variant];
      }
    }]);

    return Union;
  }(Layout$2);

  Layout$3.Union = Union$1;
  /**
   * Represent a specific variant within a containing union.
   *
   * **NOTE** The {@link Layout#span|span} of the variant may include
   * the span of the {@link Union#discriminator|discriminator} used to
   * identify it, but values read and written using the variant strictly
   * conform to the content of {@link VariantLayout#layout|layout}.
   *
   * **NOTE** User code should not invoke this constructor directly.  Use
   * the union {@link Union#addVariant|addVariant} helper method.
   *
   * @param {Union} union - initializer for {@link
   * VariantLayout#union|union}.
   *
   * @param {Number} variant - initializer for {@link
   * VariantLayout#variant|variant}.
   *
   * @param {Layout} [layout] - initializer for {@link
   * VariantLayout#layout|layout}.  If absent the variant carries no
   * data.
   *
   * @param {String} [property] - initializer for {@link
   * Layout#property|property}.  Unlike many other layouts, variant
   * layouts normally include a property name so they can be identified
   * within their containing {@link Union}.  The property identifier may
   * be absent only if `layout` is is absent.
   *
   * @augments {Layout}
   */

  var VariantLayout$1 = /*#__PURE__*/function (_Layout17) {
    _inherits(VariantLayout, _Layout17);

    var _super20 = _createSuper(VariantLayout);

    function VariantLayout(union, variant, layout, property) {
      var _this11;

      _classCallCheck(this, VariantLayout);

      if (!(union instanceof Union$1)) {
        throw new TypeError('union must be a Union');
      }

      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError('variant must be a (non-negative) integer');
      }

      if ('string' === typeof layout && undefined === property) {
        property = layout;
        layout = null;
      }

      if (layout) {
        if (!(layout instanceof Layout$2)) {
          throw new TypeError('layout must be a Layout');
        }

        if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {
          throw new Error('variant span exceeds span of containing union');
        }

        if ('string' !== typeof property) {
          throw new TypeError('variant must have a String property');
        }
      }

      var span = union.span;

      if (0 > union.span) {
        span = layout ? layout.span : 0;

        if (0 <= span && union.usesPrefixDiscriminator) {
          span += union.discriminator.layout.span;
        }
      }

      _this11 = _super20.call(this, span, property);
      /** The {@link Union} to which this variant belongs. */

      _this11.union = union;
      /** The unsigned integral value identifying this variant within
       * the {@link Union#discriminator|discriminator} of the containing
       * union. */

      _this11.variant = variant;
      /** The {@link Layout} to be used when reading/writing the
       * non-discriminator part of the {@link
       * VariantLayout#union|union}.  If `null` the variant carries no
       * data. */

      _this11.layout = layout || null;
      return _this11;
    }
    /** @override */


    _createClass(VariantLayout, [{
      key: "getSpan",
      value: function getSpan(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (0 <= this.span) {
          /* Will be equal to the containing union span if that is not
           * variable. */
          return this.span;
        }

        var contentOffset = 0;

        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        /* Span is defined solely by the variant (and prefix discriminator) */


        var span = 0;

        if (this.layout) {
          span = this.layout.getSpan(b, offset + contentOffset);
        }

        return contentOffset + span;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var dest = this.makeDestinationObject();

        if (this !== this.union.getVariant(b, offset)) {
          throw new Error('variant mismatch');
        }

        var contentOffset = 0;

        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }

        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }

        return dest;
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var contentOffset = 0;

        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }

        if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {
          throw new TypeError('variant lacks property ' + this.property);
        }

        this.union.discriminator.encode(this.variant, b, offset);
        var span = contentOffset;

        if (this.layout) {
          this.layout.encode(src[this.property], b, offset + contentOffset);
          span += this.layout.getSpan(b, offset + contentOffset);

          if (0 <= this.union.span && span > this.union.span) {
            throw new Error('encoded variant overruns containing union');
          }
        }

        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */

    }, {
      key: "fromArray",
      value: function fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }

        return undefined;
      }
    }]);

    return VariantLayout;
  }(Layout$2);

  Layout$3.VariantLayout = VariantLayout$1;
  /** JavaScript chose to define bitwise operations as operating on
   * signed 32-bit values in 2's complement form, meaning any integer
   * with bit 31 set is going to look negative.  For right shifts that's
   * not a problem, because `>>>` is a logical shift, but for every
   * other bitwise operator we have to compensate for possible negative
   * results. */

  function fixBitwiseResult$1(v) {
    if (0 > v) {
      v += 0x100000000;
    }

    return v;
  }
  /**
   * Contain a sequence of bit fields as an unsigned integer.
   *
   * *Factory*: {@link module:Layout.bits|bits}
   *
   * This is a container element; within it there are {@link BitField}
   * instances that provide the extracted properties.  The container
   * simply defines the aggregate representation and its bit ordering.
   * The representation is an object containing properties with numeric
   * or {@link Boolean} values.
   *
   * {@link BitField}s are added with the {@link
   * BitStructure#addField|addField} and {@link
   * BitStructure#addBoolean|addBoolean} methods.

   * @param {Layout} word - initializer for {@link
   * BitStructure#word|word}.  The parameter must be an instance of
   * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.
   *
   * @param {bool} [msb] - `true` if the bit numbering starts at the
   * most significant bit of the containing word; `false` (default) if
   * it starts at the least significant bit of the containing word.  If
   * the parameter at this position is a string and `property` is
   * `undefined` the value of this argument will instead be used as the
   * value of `property`.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var BitStructure$1 = /*#__PURE__*/function (_Layout18) {
    _inherits(BitStructure, _Layout18);

    var _super21 = _createSuper(BitStructure);

    function BitStructure(word, msb, property) {
      var _this12;

      _classCallCheck(this, BitStructure);

      if (!(word instanceof UInt$1 || word instanceof UIntBE$1)) {
        throw new TypeError('word must be a UInt or UIntBE layout');
      }

      if ('string' === typeof msb && undefined === property) {
        property = msb;
        msb = false;
      }

      if (4 < word.span) {
        throw new RangeError('word cannot exceed 32 bits');
      }

      _this12 = _super21.call(this, word.span, property);
      /** The layout used for the packed value.  {@link BitField}
       * instances are packed sequentially depending on {@link
       * BitStructure#msb|msb}. */

      _this12.word = word;
      /** Whether the bit sequences are packed starting at the most
       * significant bit growing down (`true`), or the least significant
       * bit growing up (`false`).
       *
       * **NOTE** Regardless of this value, the least significant bit of
       * any {@link BitField} value is the least significant bit of the
       * corresponding section of the packed value. */

      _this12.msb = !!msb;
      /** The sequence of {@link BitField} layouts that comprise the
       * packed structure.
       *
       * **NOTE** The array remains mutable to allow fields to be {@link
       * BitStructure#addField|added} after construction.  Users should
       * not manipulate the content of this property.*/

      _this12.fields = [];
      /* Storage for the value.  Capture a variable instead of using an
       * instance property because we don't want anything to change the
       * value without going through the mutator. */

      var value = 0;

      _this12._packedSetValue = function (v) {
        value = fixBitwiseResult$1(v);
        return this;
      };

      _this12._packedGetValue = function () {
        return value;
      };

      return _this12;
    }
    /** @override */


    _createClass(BitStructure, [{
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var dest = this.makeDestinationObject();
        var value = this.word.decode(b, offset);

        this._packedSetValue(value);

        var _iterator7 = _createForOfIteratorHelper(this.fields),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var fd = _step7.value;

            if (undefined !== fd.property) {
              dest[fd.property] = fd.decode(b);
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }

        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var value = this.word.decode(b, offset);

        this._packedSetValue(value);

        var _iterator8 = _createForOfIteratorHelper(this.fields),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var fd = _step8.value;

            if (undefined !== fd.property) {
              var fv = src[fd.property];

              if (undefined !== fv) {
                fd.encode(fv);
              }
            }
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }

        return this.word.encode(this._packedGetValue(), b, offset);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */

    }, {
      key: "addField",
      value: function addField(bits, property) {
        var bf = new BitField$1(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */
      // `Boolean` conflicts with the native primitive type
      // eslint-disable-next-line @typescript-eslint/ban-types

    }, {
      key: "addBoolean",
      value: function addBoolean(property) {
        // This is my Boolean, not the Javascript one.
        var bf = new Boolean$2(this, property);
        this.fields.push(bf);
        return bf;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */

    }, {
      key: "fieldFor",
      value: function fieldFor(property) {
        if ('string' !== typeof property) {
          throw new TypeError('property must be string');
        }

        var _iterator9 = _createForOfIteratorHelper(this.fields),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var fd = _step9.value;

            if (fd.property === property) {
              return fd;
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        return undefined;
      }
    }]);

    return BitStructure;
  }(Layout$2);

  Layout$3.BitStructure = BitStructure$1;
  /**
   * Represent a sequence of bits within a {@link BitStructure}.
   *
   * All bit field values are represented as unsigned integers.
   *
   * **NOTE** User code should not invoke this constructor directly.
   * Use the container {@link BitStructure#addField|addField} helper
   * method.
   *
   * **NOTE** BitField instances are not instances of {@link Layout}
   * since {@link Layout#span|span} measures 8-bit units.
   *
   * @param {BitStructure} container - initializer for {@link
   * BitField#container|container}.
   *
   * @param {Number} bits - initializer for {@link BitField#bits|bits}.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   */

  var BitField$1 = /*#__PURE__*/function () {
    function BitField(container, bits, property) {
      _classCallCheck(this, BitField);

      if (!(container instanceof BitStructure$1)) {
        throw new TypeError('container must be a BitStructure');
      }

      if (!Number.isInteger(bits) || 0 >= bits) {
        throw new TypeError('bits must be positive integer');
      }

      var totalBits = 8 * container.span;
      var usedBits = container.fields.reduce(function (sum, fd) {
        return sum + fd.bits;
      }, 0);

      if (bits + usedBits > totalBits) {
        throw new Error('bits too long for span remainder (' + (totalBits - usedBits) + ' of ' + totalBits + ' remain)');
      }
      /** The {@link BitStructure} instance to which this bit field
       * belongs. */


      this.container = container;
      /** The span of this value in bits. */

      this.bits = bits;
      /** A mask of {@link BitField#bits|bits} bits isolating value bits
       * that fit within the field.
       *
       * That is, it masks a value that has not yet been shifted into
       * position within its containing packed integer. */

      this.valueMask = (1 << bits) - 1;

      if (32 === bits) {
        // shifted value out of range
        this.valueMask = 0xFFFFFFFF;
      }
      /** The offset of the value within the containing packed unsigned
       * integer.  The least significant bit of the packed value is at
       * offset zero, regardless of bit ordering used. */


      this.start = usedBits;

      if (this.container.msb) {
        this.start = totalBits - usedBits - bits;
      }
      /** A mask of {@link BitField#bits|bits} isolating the field value
       * within the containing packed unsigned integer. */


      this.wordMask = fixBitwiseResult$1(this.valueMask << this.start);
      /** The property name used when this bitfield is represented in an
       * Object.
       *
       * Intended to be functionally equivalent to {@link
       * Layout#property}.
       *
       * If left undefined the corresponding span of bits will be
       * treated as padding: it will not be mutated by {@link
       * Layout#encode|encode} nor represented as a property in the
       * decoded Object. */

      this.property = property;
    }
    /** Store a value into the corresponding subsequence of the containing
     * bit field. */


    _createClass(BitField, [{
      key: "decode",
      value: function decode(b, offset) {
        var word = this.container._packedGetValue();

        var wordValue = fixBitwiseResult$1(word & this.wordMask);
        var value = wordValue >>> this.start;
        return value;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */

    }, {
      key: "encode",
      value: function encode(value) {
        if ('number' !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult$1(value & this.valueMask)) {
          throw new TypeError(nameWithProperty$1('BitField.encode', this) + ' value must be integer not exceeding ' + this.valueMask);
        }

        var word = this.container._packedGetValue();

        var wordValue = fixBitwiseResult$1(value << this.start);

        this.container._packedSetValue(fixBitwiseResult$1(word & ~this.wordMask) | wordValue);
      }
    }]);

    return BitField;
  }();

  Layout$3.BitField = BitField$1;
  /**
   * Represent a single bit within a {@link BitStructure} as a
   * JavaScript boolean.
   *
   * **NOTE** User code should not invoke this constructor directly.
   * Use the container {@link BitStructure#addBoolean|addBoolean} helper
   * method.
   *
   * @param {BitStructure} container - initializer for {@link
   * BitField#container|container}.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {BitField}
   */

  /* eslint-disable no-extend-native */

  var Boolean$2 = /*#__PURE__*/function (_BitField) {
    _inherits(Boolean, _BitField);

    var _super22 = _createSuper(Boolean);

    function Boolean(container, property) {
      _classCallCheck(this, Boolean);

      return _super22.call(this, container, 1, property);
    }
    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
     *
     * @returns {boolean} */


    _createClass(Boolean, [{
      key: "decode",
      value: function decode(b, offset) {
        return !!_get(_getPrototypeOf(Boolean.prototype), "decode", this).call(this, b, offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(value) {
        if ('boolean' === typeof value) {
          // BitField requires integer values
          value = +value;
        }

        _get(_getPrototypeOf(Boolean.prototype), "encode", this).call(this, value);
      }
    }]);

    return Boolean;
  }(BitField$1);

  Layout$3.Boolean = Boolean$2;
  /* eslint-enable no-extend-native */

  /**
   * Contain a fixed-length block of arbitrary data, represented as a
   * Uint8Array.
   *
   * *Factory*: {@link module:Layout.blob|blob}
   *
   * @param {(Number|ExternalLayout)} length - initializes {@link
   * Blob#length|length}.
   *
   * @param {String} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var Blob$1 = /*#__PURE__*/function (_Layout19) {
    _inherits(Blob, _Layout19);

    var _super23 = _createSuper(Blob);

    function Blob(length, property) {
      var _this13;

      _classCallCheck(this, Blob);

      if (!(length instanceof ExternalLayout$1 && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError('length must be positive integer ' + 'or an unsigned integer ExternalLayout');
      }

      var span = -1;

      if (!(length instanceof ExternalLayout$1)) {
        span = length;
      }

      _this13 = _super23.call(this, span, property);
      /** The number of bytes in the blob.
       *
       * This may be a non-negative integer, or an instance of {@link
       * ExternalLayout} that satisfies {@link
       * ExternalLayout#isCount|isCount()}. */

      _this13.length = length;
      return _this13;
    }
    /** @override */


    _createClass(Blob, [{
      key: "getSpan",
      value: function getSpan(b, offset) {
        var span = this.span;

        if (0 > span) {
          span = this.length.decode(b, offset);
        }

        return span;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var span = this.span;

        if (0 > span) {
          span = this.length.decode(b, offset);
        }

        return uint8ArrayToBuffer(b).slice(offset, offset + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        var span = this.length;

        if (this.length instanceof ExternalLayout$1) {
          span = src.length;
        }

        if (!(src instanceof Uint8Array && span === src.length)) {
          throw new TypeError(nameWithProperty$1('Blob.encode', this) + ' requires (length ' + span + ') Uint8Array as src');
        }

        if (offset + span > b.length) {
          throw new RangeError('encoding overruns Uint8Array');
        }

        var srcBuffer = uint8ArrayToBuffer(src);
        uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');

        if (this.length instanceof ExternalLayout$1) {
          this.length.encode(span, b, offset);
        }

        return span;
      }
    }]);

    return Blob;
  }(Layout$2);

  Layout$3.Blob = Blob$1;
  /**
   * Contain a `NUL`-terminated UTF8 string.
   *
   * *Factory*: {@link module:Layout.cstr|cstr}
   *
   * **NOTE** Any UTF8 string that incorporates a zero-valued byte will
   * not be correctly decoded by this layout.
   *
   * @param {String} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var CString$1 = /*#__PURE__*/function (_Layout20) {
    _inherits(CString, _Layout20);

    var _super24 = _createSuper(CString);

    function CString(property) {
      _classCallCheck(this, CString);

      return _super24.call(this, -1, property);
    }
    /** @override */


    _createClass(CString, [{
      key: "getSpan",
      value: function getSpan(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        checkUint8Array(b);
        var idx = offset;

        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }

        return 1 + idx - offset;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var span = this.getSpan(b, offset);
        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        /* Must force this to a string, lest it be a number and the
         * "utf8-encoding" below actually allocate a buffer of length
         * src */
        if ('string' !== typeof src) {
          src = String(src);
        }

        var srcb = buffer_1.Buffer.from(src, 'utf8');
        var span = srcb.length;

        if (offset + span > b.length) {
          throw new RangeError('encoding overruns Buffer');
        }

        var buffer = uint8ArrayToBuffer(b);
        srcb.copy(buffer, offset);
        buffer[offset + span] = 0;
        return span + 1;
      }
    }]);

    return CString;
  }(Layout$2);

  Layout$3.CString = CString$1;
  /**
   * Contain a UTF8 string with implicit length.
   *
   * *Factory*: {@link module:Layout.utf8|utf8}
   *
   * **NOTE** Because the length is implicit in the size of the buffer
   * this layout should be used only in isolation, or in a situation
   * where the length can be expressed by operating on a slice of the
   * containing buffer.
   *
   * @param {Number} [maxSpan] - the maximum length allowed for encoded
   * string content.  If not provided there is no bound on the allowed
   * content.
   *
   * @param {String} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var UTF8$1 = /*#__PURE__*/function (_Layout21) {
    _inherits(UTF8, _Layout21);

    var _super25 = _createSuper(UTF8);

    function UTF8(maxSpan, property) {
      var _this14;

      _classCallCheck(this, UTF8);

      if ('string' === typeof maxSpan && undefined === property) {
        property = maxSpan;
        maxSpan = undefined;
      }

      if (undefined === maxSpan) {
        maxSpan = -1;
      } else if (!Number.isInteger(maxSpan)) {
        throw new TypeError('maxSpan must be an integer');
      }

      _this14 = _super25.call(this, -1, property);
      /** The maximum span of the layout in bytes.
       *
       * Positive values are generally expected.  Zero is abnormal.
       * Attempts to encode or decode a value that exceeds this length
       * will throw a `RangeError`.
       *
       * A negative value indicates that there is no bound on the length
       * of the content. */

      _this14.maxSpan = maxSpan;
      return _this14;
    }
    /** @override */


    _createClass(UTF8, [{
      key: "getSpan",
      value: function getSpan(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        checkUint8Array(b);
        return b.length - offset;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var span = this.getSpan(b, offset);

        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError('text length exceeds maxSpan');
        }

        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b) {
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        /* Must force this to a string, lest it be a number and the
         * "utf8-encoding" below actually allocate a buffer of length
         * src */
        if ('string' !== typeof src) {
          src = String(src);
        }

        var srcb = buffer_1.Buffer.from(src, 'utf8');
        var span = srcb.length;

        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError('text length exceeds maxSpan');
        }

        if (offset + span > b.length) {
          throw new RangeError('encoding overruns Buffer');
        }

        srcb.copy(uint8ArrayToBuffer(b), offset);
        return span;
      }
    }]);

    return UTF8;
  }(Layout$2);

  Layout$3.UTF8 = UTF8$1;
  /**
   * Contain a constant value.
   *
   * This layout may be used in cases where a JavaScript value can be
   * inferred without an expression in the binary encoding.  An example
   * would be a {@link VariantLayout|variant layout} where the content
   * is implied by the union {@link Union#discriminator|discriminator}.
   *
   * @param {Object|Number|String} value - initializer for {@link
   * Constant#value|value}.  If the value is an object (or array) and
   * the application intends the object to remain unchanged regardless
   * of what is done to values decoded by this layout, the value should
   * be frozen prior passing it to this constructor.
   *
   * @param {String} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */

  var Constant$1 = /*#__PURE__*/function (_Layout22) {
    _inherits(Constant, _Layout22);

    var _super26 = _createSuper(Constant);

    function Constant(value, property) {
      var _this15;

      _classCallCheck(this, Constant);

      _this15 = _super26.call(this, 0, property);
      /** The value produced by this constant when the layout is {@link
       * Constant#decode|decoded}.
       *
       * Any JavaScript value including `null` and `undefined` is
       * permitted.
       *
       * **WARNING** If `value` passed in the constructor was not
       * frozen, it is possible for users of decoded values to change
       * the content of the value. */

      _this15.value = value;
      return _this15;
    }
    /** @override */


    _createClass(Constant, [{
      key: "decode",
      value: function decode(b, offset) {
        return this.value;
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        /* Constants take no space */
        return 0;
      }
    }]);

    return Constant;
  }(Layout$2);

  Layout$3.Constant = Constant$1;
  /** Factory for {@link GreedyCount}. */

  Layout$3.greedy = function (elementSpan, property) {
    return new GreedyCount$1(elementSpan, property);
  };
  /** Factory for {@link OffsetLayout}. */


  var offset = Layout$3.offset = function (layout, offset, property) {
    return new OffsetLayout$1(layout, offset, property);
  };
  /** Factory for {@link UInt|unsigned int layouts} spanning one
   * byte. */


  var u8 = Layout$3.u8 = function (property) {
    return new UInt$1(1, property);
  };
  /** Factory for {@link UInt|little-endian unsigned int layouts}
   * spanning two bytes. */


  var u16 = Layout$3.u16 = function (property) {
    return new UInt$1(2, property);
  };
  /** Factory for {@link UInt|little-endian unsigned int layouts}
   * spanning three bytes. */


  Layout$3.u24 = function (property) {
    return new UInt$1(3, property);
  };
  /** Factory for {@link UInt|little-endian unsigned int layouts}
   * spanning four bytes. */


  var u32 = Layout$3.u32 = function (property) {
    return new UInt$1(4, property);
  };
  /** Factory for {@link UInt|little-endian unsigned int layouts}
   * spanning five bytes. */


  Layout$3.u40 = function (property) {
    return new UInt$1(5, property);
  };
  /** Factory for {@link UInt|little-endian unsigned int layouts}
   * spanning six bytes. */


  Layout$3.u48 = function (property) {
    return new UInt$1(6, property);
  };
  /** Factory for {@link NearUInt64|little-endian unsigned int
   * layouts} interpreted as Numbers. */


  var nu64 = Layout$3.nu64 = function (property) {
    return new NearUInt64$1(property);
  };
  /** Factory for {@link UInt|big-endian unsigned int layouts}
   * spanning two bytes. */


  Layout$3.u16be = function (property) {
    return new UIntBE$1(2, property);
  };
  /** Factory for {@link UInt|big-endian unsigned int layouts}
   * spanning three bytes. */


  Layout$3.u24be = function (property) {
    return new UIntBE$1(3, property);
  };
  /** Factory for {@link UInt|big-endian unsigned int layouts}
   * spanning four bytes. */


  Layout$3.u32be = function (property) {
    return new UIntBE$1(4, property);
  };
  /** Factory for {@link UInt|big-endian unsigned int layouts}
   * spanning five bytes. */


  Layout$3.u40be = function (property) {
    return new UIntBE$1(5, property);
  };
  /** Factory for {@link UInt|big-endian unsigned int layouts}
   * spanning six bytes. */


  Layout$3.u48be = function (property) {
    return new UIntBE$1(6, property);
  };
  /** Factory for {@link NearUInt64BE|big-endian unsigned int
   * layouts} interpreted as Numbers. */


  Layout$3.nu64be = function (property) {
    return new NearUInt64BE$1(property);
  };
  /** Factory for {@link Int|signed int layouts} spanning one
   * byte. */


  Layout$3.s8 = function (property) {
    return new Int$1(1, property);
  };
  /** Factory for {@link Int|little-endian signed int layouts}
   * spanning two bytes. */


  Layout$3.s16 = function (property) {
    return new Int$1(2, property);
  };
  /** Factory for {@link Int|little-endian signed int layouts}
   * spanning three bytes. */


  Layout$3.s24 = function (property) {
    return new Int$1(3, property);
  };
  /** Factory for {@link Int|little-endian signed int layouts}
   * spanning four bytes. */


  Layout$3.s32 = function (property) {
    return new Int$1(4, property);
  };
  /** Factory for {@link Int|little-endian signed int layouts}
   * spanning five bytes. */


  Layout$3.s40 = function (property) {
    return new Int$1(5, property);
  };
  /** Factory for {@link Int|little-endian signed int layouts}
   * spanning six bytes. */


  Layout$3.s48 = function (property) {
    return new Int$1(6, property);
  };
  /** Factory for {@link NearInt64|little-endian signed int layouts}
   * interpreted as Numbers. */


  var ns64 = Layout$3.ns64 = function (property) {
    return new NearInt64$1(property);
  };
  /** Factory for {@link Int|big-endian signed int layouts}
   * spanning two bytes. */


  Layout$3.s16be = function (property) {
    return new IntBE$1(2, property);
  };
  /** Factory for {@link Int|big-endian signed int layouts}
   * spanning three bytes. */


  Layout$3.s24be = function (property) {
    return new IntBE$1(3, property);
  };
  /** Factory for {@link Int|big-endian signed int layouts}
   * spanning four bytes. */


  Layout$3.s32be = function (property) {
    return new IntBE$1(4, property);
  };
  /** Factory for {@link Int|big-endian signed int layouts}
   * spanning five bytes. */


  Layout$3.s40be = function (property) {
    return new IntBE$1(5, property);
  };
  /** Factory for {@link Int|big-endian signed int layouts}
   * spanning six bytes. */


  Layout$3.s48be = function (property) {
    return new IntBE$1(6, property);
  };
  /** Factory for {@link NearInt64BE|big-endian signed int layouts}
   * interpreted as Numbers. */


  Layout$3.ns64be = function (property) {
    return new NearInt64BE$1(property);
  };
  /** Factory for {@link Float|little-endian 32-bit floating point} values. */


  Layout$3.f32 = function (property) {
    return new Float$1(property);
  };
  /** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */


  Layout$3.f32be = function (property) {
    return new FloatBE$1(property);
  };
  /** Factory for {@link Double|little-endian 64-bit floating point} values. */


  Layout$3.f64 = function (property) {
    return new Double$1(property);
  };
  /** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */


  Layout$3.f64be = function (property) {
    return new DoubleBE$1(property);
  };
  /** Factory for {@link Structure} values. */


  var struct = Layout$3.struct = function (fields, property, decodePrefixes) {
    return new Structure$1(fields, property, decodePrefixes);
  };
  /** Factory for {@link BitStructure} values. */


  Layout$3.bits = function (word, msb, property) {
    return new BitStructure$1(word, msb, property);
  };
  /** Factory for {@link Sequence} values. */


  var seq$1 = Layout$3.seq = function (elementLayout, count, property) {
    return new Sequence$1(elementLayout, count, property);
  };
  /** Factory for {@link Union} values. */


  Layout$3.union = function (discr, defaultLayout, property) {
    return new Union$1(discr, defaultLayout, property);
  };
  /** Factory for {@link UnionLayoutDiscriminator} values. */


  Layout$3.unionLayoutDiscriminator = function (layout, property) {
    return new UnionLayoutDiscriminator$1(layout, property);
  };
  /** Factory for {@link Blob} values. */


  var blob$1 = Layout$3.blob = function (length, property) {
    return new Blob$1(length, property);
  };
  /** Factory for {@link CString} values. */


  Layout$3.cstr = function (property) {
    return new CString$1(property);
  };
  /** Factory for {@link UTF8} values. */


  Layout$3.utf8 = function (maxSpan, property) {
    return new UTF8$1(maxSpan, property);
  };
  /** Factory for {@link Constant} values. */


  Layout$3.constant = function (value, property) {
    return new Constant$1(value, property);
  };

  var browser$1 = {};

  Object.defineProperty(browser$1, "__esModule", {
    value: true
  });
  /**
   * Convert a little-endian buffer into a BigInt.
   * @param buf The little-endian buffer to convert
   * @returns A BigInt with the little-endian representation of buf.
   */

  function toBigIntLE(buf) {
    {
      var reversed = Buffer$1.from(buf);
      reversed.reverse();
      var hex = reversed.toString('hex');

      if (hex.length === 0) {
        return BigInt(0);
      }

      return BigInt("0x".concat(hex));
    }
  }

  var toBigIntLE_1 = browser$1.toBigIntLE = toBigIntLE;
  /**
   * Convert a big-endian buffer into a BigInt
   * @param buf The big-endian buffer to convert.
   * @returns A BigInt with the big-endian representation of buf.
   */

  function toBigIntBE(buf) {
    {
      var hex = buf.toString('hex');

      if (hex.length === 0) {
        return BigInt(0);
      }

      return BigInt("0x".concat(hex));
    }
  }

  browser$1.toBigIntBE = toBigIntBE;
  /**
   * Convert a BigInt to a little-endian buffer.
   * @param num   The BigInt to convert.
   * @param width The number of bytes that the resulting buffer should be.
   * @returns A little-endian buffer representation of num.
   */

  function toBufferLE(num, width) {
    {
      var hex = num.toString(16);
      var buffer = Buffer$1.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');
      buffer.reverse();
      return buffer;
    } // Allocation is done here, since it is slower using napi in C
  }

  var toBufferLE_1 = browser$1.toBufferLE = toBufferLE;
  /**
   * Convert a BigInt to a big-endian buffer.
   * @param num   The BigInt to convert.
   * @param width The number of bytes that the resulting buffer should be.
   * @returns A big-endian buffer representation of num.
   */

  function toBufferBE(num, width) {
    {
      var hex = num.toString(16);
      return Buffer$1.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');
    }
  }

  browser$1.toBufferBE = toBufferBE;

  var _excluded$1 = ["message"];

  var _marked = /*#__PURE__*/_regeneratorRuntime().mark(toFailures);

  /**
   * A `StructFailure` represents a single specific failure in validation.
   */

  /**
   * `StructError` objects are thrown (or returned) when validation fails.
   *
   * Validation logic is design to exit early for maximum performance. The error
   * represents the first error encountered during validation. For more detail,
   * the `error.failures` property is a generator function that can be run to
   * continue validation and receive all the failures in the data.
   */
  var StructError = /*#__PURE__*/function (_TypeError) {
    _inherits(StructError, _TypeError);

    var _super = _createSuper(StructError);

    function StructError(failure, failures) {
      var _this;

      _classCallCheck(this, StructError);

      var cached;

      var message = failure.message,
          rest = _objectWithoutProperties(failure, _excluded$1);

      var path = failure.path;
      var msg = path.length === 0 ? message : "At path: " + path.join('.') + " -- " + message;
      _this = _super.call(this, msg);
      Object.assign(_assertThisInitialized(_this), rest);
      _this.name = _this.constructor.name;

      _this.failures = function () {
        var _cached;

        return (_cached = cached) != null ? _cached : cached = [failure].concat(_toConsumableArray(failures()));
      };

      return _this;
    }

    return _createClass(StructError);
  }( /*#__PURE__*/_wrapNativeSuper(TypeError));
  /**
   * Check if a value is an iterator.
   */


  function isIterable(x) {
    return isObject(x) && typeof x[Symbol.iterator] === 'function';
  }
  /**
   * Check if a value is a plain object.
   */


  function isObject(x) {
    return _typeof$1(x) === 'object' && x != null;
  }
  /**
   * Return a value as a printable string.
   */


  function print(value) {
    return typeof value === 'string' ? JSON.stringify(value) : "" + value;
  }
  /**
   * Shifts (removes and returns) the first value from the `input` iterator.
   * Like `Array.prototype.shift()` but for an `Iterator`.
   */


  function shiftIterator(input) {
    var _input$next = input.next(),
        done = _input$next.done,
        value = _input$next.value;

    return done ? undefined : value;
  }
  /**
   * Convert a single validation result to a failure.
   */


  function toFailure(result, context, struct, value) {
    if (result === true) {
      return;
    } else if (result === false) {
      result = {};
    } else if (typeof result === 'string') {
      result = {
        message: result
      };
    }

    var path = context.path,
        branch = context.branch;
    var type = struct.type;
    var _result = result,
        refinement = _result.refinement,
        _result$message = _result.message,
        message = _result$message === void 0 ? "Expected a value of type `" + type + "`" + (refinement ? " with refinement `" + refinement + "`" : '') + ", but received: `" + print(value) + "`" : _result$message;
    return _objectSpread2(_objectSpread2({
      value: value,
      type: type,
      refinement: refinement,
      key: path[path.length - 1],
      path: path,
      branch: branch
    }, result), {}, {
      message: message
    });
  }
  /**
   * Convert a validation result to an iterable of failures.
   */


  function toFailures(result, context, struct, value) {
    var _iterator, _step, r, failure;

    return _regeneratorRuntime().wrap(function toFailures$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          if (!isIterable(result)) {
            result = [result];
          }

          _iterator = _createForOfIteratorHelper(result);
          _context.prev = 2;

          _iterator.s();

        case 4:
          if ((_step = _iterator.n()).done) {
            _context.next = 12;
            break;
          }

          r = _step.value;
          failure = toFailure(r, context, struct, value);

          if (!failure) {
            _context.next = 10;
            break;
          }

          _context.next = 10;
          return failure;

        case 10:
          _context.next = 4;
          break;

        case 12:
          _context.next = 17;
          break;

        case 14:
          _context.prev = 14;
          _context.t0 = _context["catch"](2);

          _iterator.e(_context.t0);

        case 17:
          _context.prev = 17;

          _iterator.f();

          return _context.finish(17);

        case 20:
        case "end":
          return _context.stop();
      }
    }, _marked, null, [[2, 14, 17, 20]]);
  }
  /**
   * Check a value against a struct, traversing deeply into nested values, and
   * returning an iterator of failures or success.
   */


  function run(value, struct) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var _options$path, path, _options$branch, branch, _options$coerce, coerce, _options$mask, mask, ctx, key, valid, _iterator2, _step2, _failure, _iterator3, _step3, _step3$value2, k, v, s, ts, _iterator5, _step5, t, _iterator4, _step4, failure;

      return _regeneratorRuntime().wrap(function _callee$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _options$path = options.path, path = _options$path === void 0 ? [] : _options$path, _options$branch = options.branch, branch = _options$branch === void 0 ? [value] : _options$branch, _options$coerce = options.coerce, coerce = _options$coerce === void 0 ? false : _options$coerce, _options$mask = options.mask, mask = _options$mask === void 0 ? false : _options$mask;
            ctx = {
              path: path,
              branch: branch
            };

            if (coerce) {
              value = struct.coercer(value, ctx);

              if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {
                for (key in value) {
                  if (struct.schema[key] === undefined) {
                    delete value[key];
                  }
                }
              }
            }

            valid = true;
            _iterator2 = _createForOfIteratorHelper(struct.validator(value, ctx));
            _context2.prev = 5;

            _iterator2.s();

          case 7:
            if ((_step2 = _iterator2.n()).done) {
              _context2.next = 14;
              break;
            }

            _failure = _step2.value;
            valid = false;
            _context2.next = 12;
            return [_failure, undefined];

          case 12:
            _context2.next = 7;
            break;

          case 14:
            _context2.next = 19;
            break;

          case 16:
            _context2.prev = 16;
            _context2.t0 = _context2["catch"](5);

            _iterator2.e(_context2.t0);

          case 19:
            _context2.prev = 19;

            _iterator2.f();

            return _context2.finish(19);

          case 22:
            _iterator3 = _createForOfIteratorHelper(struct.entries(value, ctx));
            _context2.prev = 23;

            _iterator3.s();

          case 25:
            if ((_step3 = _iterator3.n()).done) {
              _context2.next = 52;
              break;
            }

            _step3$value2 = _slicedToArray(_step3.value, 3), k = _step3$value2[0], v = _step3$value2[1], s = _step3$value2[2];
            ts = run(v, s, {
              path: k === undefined ? path : [].concat(_toConsumableArray(path), [k]),
              branch: k === undefined ? branch : [].concat(_toConsumableArray(branch), [v]),
              coerce: coerce,
              mask: mask
            });
            _iterator5 = _createForOfIteratorHelper(ts);
            _context2.prev = 29;

            _iterator5.s();

          case 31:
            if ((_step5 = _iterator5.n()).done) {
              _context2.next = 42;
              break;
            }

            t = _step5.value;

            if (!t[0]) {
              _context2.next = 39;
              break;
            }

            valid = false;
            _context2.next = 37;
            return [t[0], undefined];

          case 37:
            _context2.next = 40;
            break;

          case 39:
            if (coerce) {
              v = t[1];

              if (k === undefined) {
                value = v;
              } else if (value instanceof Map) {
                value.set(k, v);
              } else if (value instanceof Set) {
                value.add(v);
              } else if (isObject(value)) {
                value[k] = v;
              }
            }

          case 40:
            _context2.next = 31;
            break;

          case 42:
            _context2.next = 47;
            break;

          case 44:
            _context2.prev = 44;
            _context2.t1 = _context2["catch"](29);

            _iterator5.e(_context2.t1);

          case 47:
            _context2.prev = 47;

            _iterator5.f();

            return _context2.finish(47);

          case 50:
            _context2.next = 25;
            break;

          case 52:
            _context2.next = 57;
            break;

          case 54:
            _context2.prev = 54;
            _context2.t2 = _context2["catch"](23);

            _iterator3.e(_context2.t2);

          case 57:
            _context2.prev = 57;

            _iterator3.f();

            return _context2.finish(57);

          case 60:
            if (!valid) {
              _context2.next = 79;
              break;
            }

            _iterator4 = _createForOfIteratorHelper(struct.refiner(value, ctx));
            _context2.prev = 62;

            _iterator4.s();

          case 64:
            if ((_step4 = _iterator4.n()).done) {
              _context2.next = 71;
              break;
            }

            failure = _step4.value;
            valid = false;
            _context2.next = 69;
            return [failure, undefined];

          case 69:
            _context2.next = 64;
            break;

          case 71:
            _context2.next = 76;
            break;

          case 73:
            _context2.prev = 73;
            _context2.t3 = _context2["catch"](62);

            _iterator4.e(_context2.t3);

          case 76:
            _context2.prev = 76;

            _iterator4.f();

            return _context2.finish(76);

          case 79:
            if (!valid) {
              _context2.next = 82;
              break;
            }

            _context2.next = 82;
            return [undefined, value];

          case 82:
          case "end":
            return _context2.stop();
        }
      }, _callee, null, [[5, 16, 19, 22], [23, 54, 57, 60], [29, 44, 47, 50], [62, 73, 76, 79]]);
    })();
  }
  /**
   * `Struct` objects encapsulate the validation logic for a specific type of
   * values. Once constructed, you use the `assert`, `is` or `validate` helpers to
   * validate unknown input data against the struct.
   */


  var Struct$1 = /*#__PURE__*/function () {
    function Struct(props) {
      var _this2 = this;

      _classCallCheck(this, Struct);

      var type = props.type,
          schema = props.schema,
          validator = props.validator,
          refiner = props.refiner,
          _props$coercer = props.coercer,
          coercer = _props$coercer === void 0 ? function (value) {
        return value;
      } : _props$coercer,
          _props$entries = props.entries,
          entries = _props$entries === void 0 ? /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        return _regeneratorRuntime().wrap(function _callee2$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
            case "end":
              return _context3.stop();
          }
        }, _callee2);
      }) : _props$entries;
      this.type = type;
      this.schema = schema;
      this.entries = entries;
      this.coercer = coercer;

      if (validator) {
        this.validator = function (value, context) {
          var result = validator(value, context);
          return toFailures(result, context, _this2, value);
        };
      } else {
        this.validator = function () {
          return [];
        };
      }

      if (refiner) {
        this.refiner = function (value, context) {
          var result = refiner(value, context);
          return toFailures(result, context, _this2, value);
        };
      } else {
        this.refiner = function () {
          return [];
        };
      }
    }
    /**
     * Assert that a value passes the struct's validation, throwing if it doesn't.
     */


    _createClass(Struct, [{
      key: "assert",
      value: function assert(value) {
        return _assert(value, this);
      }
      /**
       * Create a value with the struct's coercion logic, then validate it.
       */

    }, {
      key: "create",
      value: function create(value) {
        return _create(value, this);
      }
      /**
       * Check if a value passes the struct's validation.
       */

    }, {
      key: "is",
      value: function is(value) {
        return _is(value, this);
      }
      /**
       * Mask a value, coercing and validating it, but returning only the subset of
       * properties defined by the struct's schema.
       */

    }, {
      key: "mask",
      value: function mask(value) {
        return _mask(value, this);
      }
      /**
       * Validate a value with the struct's validation logic, returning a tuple
       * representing the result.
       *
       * You may optionally pass `true` for the `withCoercion` argument to coerce
       * the value before attempting to validate it. If you do, the result will
       * contain the coerced result when successful.
       */

    }, {
      key: "validate",
      value: function validate(value) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        return _validate(value, this, options);
      }
    }]);

    return Struct;
  }();
  /**
   * Assert that a value passes a struct, throwing if it doesn't.
   */


  function _assert(value, struct) {
    var result = _validate(value, struct);

    if (result[0]) {
      throw result[0];
    }
  }
  /**
   * Create a value with the coercion logic of struct and validate it.
   */


  function _create(value, struct) {
    var result = _validate(value, struct, {
      coerce: true
    });

    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  /**
   * Mask a value, returning only the subset of properties defined by a struct.
   */


  function _mask(value, struct) {
    var result = _validate(value, struct, {
      coerce: true,
      mask: true
    });

    if (result[0]) {
      throw result[0];
    } else {
      return result[1];
    }
  }
  /**
   * Check if a value passes a struct.
   */


  function _is(value, struct) {
    var result = _validate(value, struct);

    return !result[0];
  }
  /**
   * Validate a value against a struct, returning an error if invalid, or the
   * value (with potential coercion) if valid.
   */


  function _validate(value, struct) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var tuples = run(value, struct, options);
    var tuple = shiftIterator(tuples);

    if (tuple[0]) {
      var error = new StructError(tuple[0], /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var _iterator6, _step6, t;

        return _regeneratorRuntime().wrap(function _callee3$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              _iterator6 = _createForOfIteratorHelper(tuples);
              _context4.prev = 1;

              _iterator6.s();

            case 3:
              if ((_step6 = _iterator6.n()).done) {
                _context4.next = 10;
                break;
              }

              t = _step6.value;

              if (!t[0]) {
                _context4.next = 8;
                break;
              }

              _context4.next = 8;
              return t[0];

            case 8:
              _context4.next = 3;
              break;

            case 10:
              _context4.next = 15;
              break;

            case 12:
              _context4.prev = 12;
              _context4.t0 = _context4["catch"](1);

              _iterator6.e(_context4.t0);

            case 15:
              _context4.prev = 15;

              _iterator6.f();

              return _context4.finish(15);

            case 18:
            case "end":
              return _context4.stop();
          }
        }, _callee3, null, [[1, 12, 15, 18]]);
      }));
      return [error, undefined];
    } else {
      var v = tuple[1];
      return [undefined, v];
    }
  }
  /**
   * Define a new struct type with a custom validation function.
   */


  function define(name, validator) {
    return new Struct$1({
      type: name,
      schema: null,
      validator: validator
    });
  }
  /**
   * Ensure that any value passes validation.
   */


  function any() {
    return define('any', function () {
      return true;
    });
  }

  function array(Element) {
    return new Struct$1({
      type: 'array',
      schema: Element,
      entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {
        var _iterator9, _step9, _step9$value2, i, v;

        return _regeneratorRuntime().wrap(function entries$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              if (!(Element && Array.isArray(value))) {
                _context7.next = 18;
                break;
              }

              _iterator9 = _createForOfIteratorHelper(value.entries());
              _context7.prev = 2;

              _iterator9.s();

            case 4:
              if ((_step9 = _iterator9.n()).done) {
                _context7.next = 10;
                break;
              }

              _step9$value2 = _slicedToArray(_step9.value, 2), i = _step9$value2[0], v = _step9$value2[1];
              _context7.next = 8;
              return [i, v, Element];

            case 8:
              _context7.next = 4;
              break;

            case 10:
              _context7.next = 15;
              break;

            case 12:
              _context7.prev = 12;
              _context7.t0 = _context7["catch"](2);

              _iterator9.e(_context7.t0);

            case 15:
              _context7.prev = 15;

              _iterator9.f();

              return _context7.finish(15);

            case 18:
            case "end":
              return _context7.stop();
          }
        }, entries, null, [[2, 12, 15, 18]]);
      }),
      coercer: function coercer(value) {
        return Array.isArray(value) ? value.slice() : value;
      },
      validator: function validator(value) {
        return Array.isArray(value) || "Expected an array value, but received: " + print(value);
      }
    });
  }
  /**
   * Ensure that a value is a boolean.
   */


  function _boolean() {
    return define('boolean', function (value) {
      return typeof value === 'boolean';
    });
  }
  /**
   * Ensure that a value is an instance of a specific class.
   */


  function instance(Class) {
    return define('instance', function (value) {
      return value instanceof Class || "Expected a `" + Class.name + "` instance, but received: " + print(value);
    });
  }

  function literal(constant) {
    var description = print(constant);

    var t = _typeof$1(constant);

    return new Struct$1({
      type: 'literal',
      schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,
      validator: function validator(value) {
        return value === constant || "Expected the literal `" + description + "`, but received: " + print(value);
      }
    });
  }
  /**
   * Ensure that no value ever passes validation.
   */


  function never() {
    return define('never', function () {
      return false;
    });
  }
  /**
   * Augment an existing struct to allow `null` values.
   */


  function nullable(struct) {
    return new Struct$1(_objectSpread2(_objectSpread2({}, struct), {}, {
      validator: function validator(value, ctx) {
        return value === null || struct.validator(value, ctx);
      },
      refiner: function refiner(value, ctx) {
        return value === null || struct.refiner(value, ctx);
      }
    }));
  }
  /**
   * Ensure that a value is a number.
   */


  function number() {
    return define('number', function (value) {
      return typeof value === 'number' && !isNaN(value) || "Expected a number, but received: " + print(value);
    });
  }
  /**
   * Augment a struct to allow `undefined` values.
   */


  function optional(struct) {
    return new Struct$1(_objectSpread2(_objectSpread2({}, struct), {}, {
      validator: function validator(value, ctx) {
        return value === undefined || struct.validator(value, ctx);
      },
      refiner: function refiner(value, ctx) {
        return value === undefined || struct.refiner(value, ctx);
      }
    }));
  }
  /**
   * Ensure that a value is an object with keys and values of specific types, but
   * without ensuring any specific shape of properties.
   *
   * Like TypeScript's `Record` utility.
   */


  function record(Key, Value) {
    return new Struct$1({
      type: 'record',
      schema: null,
      entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {
        var k, v;
        return _regeneratorRuntime().wrap(function entries$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              if (!isObject(value)) {
                _context13.next = 11;
                break;
              }

              _context13.t0 = _regeneratorRuntime().keys(value);

            case 2:
              if ((_context13.t1 = _context13.t0()).done) {
                _context13.next = 11;
                break;
              }

              k = _context13.t1.value;
              v = value[k];
              _context13.next = 7;
              return [k, k, Key];

            case 7:
              _context13.next = 9;
              return [k, v, Value];

            case 9:
              _context13.next = 2;
              break;

            case 11:
            case "end":
              return _context13.stop();
          }
        }, entries);
      }),
      validator: function validator(value) {
        return isObject(value) || "Expected an object, but received: " + print(value);
      }
    });
  }
  /**
   * Ensure that a value is a string.
   */


  function string() {
    return define('string', function (value) {
      return typeof value === 'string' || "Expected a string, but received: " + print(value);
    });
  }

  function tuple(Elements) {
    var Never = never();
    return new Struct$1({
      type: 'tuple',
      schema: null,
      entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {
        var length, i;
        return _regeneratorRuntime().wrap(function entries$(_context15) {
          while (1) switch (_context15.prev = _context15.next) {
            case 0:
              if (!Array.isArray(value)) {
                _context15.next = 9;
                break;
              }

              length = Math.max(Elements.length, value.length);
              i = 0;

            case 3:
              if (!(i < length)) {
                _context15.next = 9;
                break;
              }

              _context15.next = 6;
              return [i, value[i], Elements[i] || Never];

            case 6:
              i++;
              _context15.next = 3;
              break;

            case 9:
            case "end":
              return _context15.stop();
          }
        }, entries);
      }),
      validator: function validator(value) {
        return Array.isArray(value) || "Expected an array, but received: " + print(value);
      }
    });
  }
  /**
   * Ensure that a value has a set of known properties of specific types.
   *
   * Note: Unrecognized properties are allowed and untouched. This is similar to
   * how TypeScript's structural typing works.
   */


  function type(schema) {
    var keys = Object.keys(schema);
    return new Struct$1({
      type: 'type',
      schema: schema,
      entries: /*#__PURE__*/_regeneratorRuntime().mark(function entries(value) {
        var _iterator18, _step18, k;

        return _regeneratorRuntime().wrap(function entries$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              if (!isObject(value)) {
                _context16.next = 18;
                break;
              }

              _iterator18 = _createForOfIteratorHelper(keys);
              _context16.prev = 2;

              _iterator18.s();

            case 4:
              if ((_step18 = _iterator18.n()).done) {
                _context16.next = 10;
                break;
              }

              k = _step18.value;
              _context16.next = 8;
              return [k, value[k], schema[k]];

            case 8:
              _context16.next = 4;
              break;

            case 10:
              _context16.next = 15;
              break;

            case 12:
              _context16.prev = 12;
              _context16.t0 = _context16["catch"](2);

              _iterator18.e(_context16.t0);

            case 15:
              _context16.prev = 15;

              _iterator18.f();

              return _context16.finish(15);

            case 18:
            case "end":
              return _context16.stop();
          }
        }, entries, null, [[2, 12, 15, 18]]);
      }),
      validator: function validator(value) {
        return isObject(value) || "Expected an object, but received: " + print(value);
      }
    });
  }

  function union(Structs) {
    var description = Structs.map(function (s) {
      return s.type;
    }).join(' | ');
    return new Struct$1({
      type: 'union',
      schema: null,
      validator: function validator(value, ctx) {
        var failures = [];

        var _iterator19 = _createForOfIteratorHelper(Structs),
            _step19;

        try {
          for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {
            var S = _step19.value;

            var _run3 = run(value, S, ctx),
                _run4 = _toArray(_run3),
                tuples = _run4.slice(0);

            var _tuples2 = _slicedToArray(tuples, 1),
                first = _tuples2[0];

            if (!first[0]) {
              return [];
            } else {
              var _iterator20 = _createForOfIteratorHelper(tuples),
                  _step20;

              try {
                for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {
                  var _step20$value2 = _slicedToArray(_step20.value, 1),
                      failure = _step20$value2[0];

                  if (failure) {
                    failures.push(failure);
                  }
                }
              } catch (err) {
                _iterator20.e(err);
              } finally {
                _iterator20.f();
              }
            }
          }
        } catch (err) {
          _iterator19.e(err);
        } finally {
          _iterator19.f();
        }

        return ["Expected the value to satisfy a union of `" + description + "`, but received: " + print(value)].concat(failures);
      }
    });
  }
  /**
   * Ensure that any value passes validation, without widening its type to `any`.
   */


  function unknown() {
    return define('unknown', function () {
      return true;
    });
  }
  /**
   * Augment a `Struct` to add an additional coercion step to its input.
   *
   * This allows you to transform input data before validating it, to increase the
   * likelihood that it passes validation—for example for default values, parsing
   * different formats, etc.
   *
   * Note: You must use `create(value, Struct)` on the value to have the coercion
   * take effect! Using simply `assert()` or `is()` will not use coercion.
   */


  function coerce(struct, condition, _coercer) {
    return new Struct$1(_objectSpread2(_objectSpread2({}, struct), {}, {
      coercer: function coercer(value, ctx) {
        return _is(value, condition) ? struct.coercer(_coercer(value, ctx), ctx) : struct.coercer(value, ctx);
      }
    }));
  }

  // Unique ID creation requires a high quality random # generator. In the browser we therefore
  // require the crypto API and do not support built-in fallback to lower quality random number
  // generators (like Math.random()).
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
      // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
      // find the complete implementation of crypto (msCrypto) on IE11.
      getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

      if (!getRandomValues) {
        throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
      }
    }

    return getRandomValues(rnds8);
  }

  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

  function validate(uuid) {
    return typeof uuid === 'string' && REGEX.test(uuid);
  }

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */

  var byteToHex = [];

  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).substr(1));
  }

  function stringify$1(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0; // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434

    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields

    if (!validate(uuid)) {
      throw TypeError('Stringified UUID is invalid');
    }

    return uuid;
  }

  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  var _nodeId;

  var _clockseq; // Previous uuid creation time


  var _lastMSecs = 0;
  var _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details

  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || new Array(16);
    options = options || {};
    var node = options.node || _nodeId;
    var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189

    if (node == null || clockseq == null) {
      var seedBytes = options.random || (options.rng || rng)();

      if (node == null) {
        // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
        node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }

      if (clockseq == null) {
        // Per 4.2.2, randomize (14 bit) clockseq
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
      }
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.


    var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock

    var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)

    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression

    if (dt < 0 && options.clockseq === undefined) {
      clockseq = clockseq + 1 & 0x3fff;
    } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval


    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
      nsecs = 0;
    } // Per 4.2.1.2 Throw error if too many uuids are requested


    if (nsecs >= 10000) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch

    msecs += 12219292800000; // `time_low`

    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`

    var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`

    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version

    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)

    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`

    b[i++] = clockseq & 0xff; // `node`

    for (var n = 0; n < 6; ++n) {
      b[i + n] = node[n];
    }

    return buf || stringify$1(b);
  }

  function parse(uuid) {
    if (!validate(uuid)) {
      throw TypeError('Invalid UUID');
    }

    var v;
    var arr = new Uint8Array(16); // Parse ########-....-....-....-............

    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 0xff;
    arr[2] = v >>> 8 & 0xff;
    arr[3] = v & 0xff; // Parse ........-####-....-....-............

    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 0xff; // Parse ........-....-####-....-............

    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 0xff; // Parse ........-....-....-####-............

    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 0xff; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)

    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
    arr[11] = v / 0x100000000 & 0xff;
    arr[12] = v >>> 24 & 0xff;
    arr[13] = v >>> 16 & 0xff;
    arr[14] = v >>> 8 & 0xff;
    arr[15] = v & 0xff;
    return arr;
  }

  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape

    var bytes = [];

    for (var i = 0; i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }

    return bytes;
  }

  var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';
  var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';
  function v35 (name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      if (typeof value === 'string') {
        value = stringToBytes(value);
      }

      if (typeof namespace === 'string') {
        namespace = parse(namespace);
      }

      if (namespace.length !== 16) {
        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');
      } // Compute hash of namespace and value, Per 4.3
      // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
      // hashfunc([...namespace, ... value])`


      var bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 0x0f | version;
      bytes[8] = bytes[8] & 0x3f | 0x80;

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }

        return buf;
      }

      return stringify$1(bytes);
    } // Function#name is not settable on some platforms (#270)


    try {
      generateUUID.name = name; // eslint-disable-next-line no-empty
    } catch (err) {} // For CommonJS default export support


    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
  }

  /*
   * Browser-compatible JavaScript MD5
   *
   * Modification of JavaScript MD5
   * https://github.com/blueimp/JavaScript-MD5
   *
   * Copyright 2011, Sebastian Tschan
   * https://blueimp.net
   *
   * Licensed under the MIT license:
   * https://opensource.org/licenses/MIT
   *
   * Based on
   * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
   * Digest Algorithm, as defined in RFC 1321.
   * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   * Distributed under the BSD License
   * See http://pajhome.org.uk/crypt/md5 for more info.
   */
  function md5(bytes) {
    if (typeof bytes === 'string') {
      var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

      bytes = new Uint8Array(msg.length);

      for (var i = 0; i < msg.length; ++i) {
        bytes[i] = msg.charCodeAt(i);
      }
    }

    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
  }
  /*
   * Convert an array of little-endian words to an array of bytes
   */


  function md5ToHexEncodedArray(input) {
    var output = [];
    var length32 = input.length * 32;
    var hexTab = '0123456789abcdef';

    for (var i = 0; i < length32; i += 8) {
      var x = input[i >> 5] >>> i % 32 & 0xff;
      var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);
      output.push(hex);
    }

    return output;
  }
  /**
   * Calculate output length with padding and bit length
   */


  function getOutputLength(inputLength8) {
    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
  }
  /*
   * Calculate the MD5 of an array of little-endian words, and a bit length.
   */


  function wordsToMd5(x, len) {
    /* append padding */
    x[len >> 5] |= 0x80 << len % 32;
    x[getOutputLength(len) - 1] = len;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;

    for (var i = 0; i < x.length; i += 16) {
      var olda = a;
      var oldb = b;
      var oldc = c;
      var oldd = d;
      a = md5ff(a, b, c, d, x[i], 7, -680876936);
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5gg(b, c, d, a, x[i], 20, -373897302);
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5hh(d, a, b, c, x[i], 11, -358537222);
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5ii(a, b, c, d, x[i], 6, -198630844);
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safeAdd(a, olda);
      b = safeAdd(b, oldb);
      c = safeAdd(c, oldc);
      d = safeAdd(d, oldd);
    }

    return [a, b, c, d];
  }
  /*
   * Convert an array bytes to an array of little-endian words
   * Characters >255 have their high-byte silently ignored.
   */


  function bytesToWords(input) {
    if (input.length === 0) {
      return [];
    }

    var length8 = input.length * 8;
    var output = new Uint32Array(getOutputLength(length8));

    for (var i = 0; i < length8; i += 8) {
      output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;
    }

    return output;
  }
  /*
   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
   * to work around bugs in some JS interpreters.
   */


  function safeAdd(x, y) {
    var lsw = (x & 0xffff) + (y & 0xffff);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xffff;
  }
  /*
   * Bitwise rotate a 32-bit number to the left.
   */


  function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }
  /*
   * These functions implement the four basic operations the algorithm uses.
   */


  function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
  }

  function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
  }

  function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
  }

  function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
  }

  function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
  }

  var v3 = v35('v3', 0x30, md5);
  var v3$1 = v3;

  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }

      return buf;
    }

    return stringify$1(rnds);
  }

  // Adapted from Chris Veness' SHA1 code at
  // http://www.movable-type.co.uk/scripts/sha1.html
  function f(s, x, y, z) {
    switch (s) {
      case 0:
        return x & y ^ ~x & z;

      case 1:
        return x ^ y ^ z;

      case 2:
        return x & y ^ x & z ^ y & z;

      case 3:
        return x ^ y ^ z;
    }
  }

  function ROTL(x, n) {
    return x << n | x >>> 32 - n;
  }

  function sha1(bytes) {
    var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];
    var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];

    if (typeof bytes === 'string') {
      var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape

      bytes = [];

      for (var i = 0; i < msg.length; ++i) {
        bytes.push(msg.charCodeAt(i));
      }
    } else if (!Array.isArray(bytes)) {
      // Convert Array-like to Array
      bytes = Array.prototype.slice.call(bytes);
    }

    bytes.push(0x80);
    var l = bytes.length / 4 + 2;
    var N = Math.ceil(l / 16);
    var M = new Array(N);

    for (var _i = 0; _i < N; ++_i) {
      var arr = new Uint32Array(16);

      for (var j = 0; j < 16; ++j) {
        arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
      }

      M[_i] = arr;
    }

    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
    M[N - 1][14] = Math.floor(M[N - 1][14]);
    M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;

    for (var _i2 = 0; _i2 < N; ++_i2) {
      var W = new Uint32Array(80);

      for (var t = 0; t < 16; ++t) {
        W[t] = M[_i2][t];
      }

      for (var _t = 16; _t < 80; ++_t) {
        W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
      }

      var a = H[0];
      var b = H[1];
      var c = H[2];
      var d = H[3];
      var e = H[4];

      for (var _t2 = 0; _t2 < 80; ++_t2) {
        var s = Math.floor(_t2 / 20);
        var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
        e = d;
        d = c;
        c = ROTL(b, 30) >>> 0;
        b = a;
        a = T;
      }

      H[0] = H[0] + a >>> 0;
      H[1] = H[1] + b >>> 0;
      H[2] = H[2] + c >>> 0;
      H[3] = H[3] + d >>> 0;
      H[4] = H[4] + e >>> 0;
    }

    return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];
  }

  var v5 = v35('v5', 0x50, sha1);
  var v5$1 = v5;

  var nil = '00000000-0000-0000-0000-000000000000';

  function version(uuid) {
    if (!validate(uuid)) {
      throw TypeError('Invalid UUID');
    }

    return parseInt(uuid.substr(14, 1), 16);
  }

  var esmBrowser = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	v1: v1,
  	v3: v3$1,
  	v4: v4,
  	v5: v5$1,
  	NIL: nil,
  	version: version,
  	validate: validate,
  	stringify: stringify$1,
  	parse: parse
  });

  var require$$0 = /*@__PURE__*/getAugmentedNamespace(esmBrowser);

  var uuid$1 = require$$0.v4;
  /**
   *  Generates a JSON-RPC 1.0 or 2.0 request
   *  @param {String} method Name of method to call
   *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value
   *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation
   *  @param {Object} [options]
   *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)
   *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
   *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID
   *  @throws {TypeError} If any of the parameters are invalid
   *  @return {Object} A JSON-RPC 1.0 or 2.0 request
   *  @memberOf Utils
   */

  var generateRequest$1 = function generateRequest(method, params, id, options) {
    if (typeof method !== 'string') {
      throw new TypeError(method + ' must be a string');
    }

    options = options || {}; // check valid version provided

    var version = typeof options.version === 'number' ? options.version : 2;

    if (version !== 1 && version !== 2) {
      throw new TypeError(version + ' must be 1 or 2');
    }

    var request = {
      method: method
    };

    if (version === 2) {
      request.jsonrpc = '2.0';
    }

    if (params) {
      // params given, but invalid?
      if (_typeof$1(params) !== 'object' && !Array.isArray(params)) {
        throw new TypeError(params + ' must be an object, array or omitted');
      }

      request.params = params;
    } // if id was left out, generate one (null means explicit notification)


    if (typeof id === 'undefined') {
      var generator = typeof options.generator === 'function' ? options.generator : function () {
        return uuid$1();
      };
      request.id = generator(request, options);
    } else if (version === 2 && id === null) {
      // we have a version 2 notification
      if (options.notificationIdNull) {
        request.id = null; // id will not be set at all unless option provided
      }
    } else {
      request.id = id;
    }

    return request;
  };

  var generateRequest_1 = generateRequest$1;

  var uuid = require$$0.v4;
  var generateRequest = generateRequest_1;
  /**
   * Constructor for a Jayson Browser Client that does not depend any node.js core libraries
   * @class ClientBrowser
   * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback
   * @param {Object} [options]
   * @param {Function} [options.reviver] Reviver function for JSON
   * @param {Function} [options.replacer] Replacer function for JSON
   * @param {Number} [options.version=2] JSON-RPC version to use (1|2)
   * @param {Function} [options.generator] Function to use for generating request IDs
   *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it
   * @return {ClientBrowser}
   */

  var ClientBrowser = function ClientBrowser(callServer, options) {
    if (!(this instanceof ClientBrowser)) {
      return new ClientBrowser(callServer, options);
    }

    if (!options) {
      options = {};
    }

    this.options = {
      reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,
      replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,
      generator: typeof options.generator !== 'undefined' ? options.generator : function () {
        return uuid();
      },
      version: typeof options.version !== 'undefined' ? options.version : 2,
      notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false
    };
    this.callServer = callServer;
  };

  var browser = ClientBrowser;
  /**
   *  Creates a request and dispatches it if given a callback.
   *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String
   *  @param {Array|Object} [params] Parameters for the method
   *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request
   *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.
   *  @throws {TypeError} Invalid parameters
   *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request
   */

  ClientBrowser.prototype.request = function (method, params, id, callback) {
    var self = this;
    var request = null; // is this a batch request?

    var isBatch = Array.isArray(method) && typeof params === 'function';

    if (this.options.version === 1 && isBatch) {
      throw new TypeError('JSON-RPC 1.0 does not support batching');
    } // is this a raw request?


    var isRaw = !isBatch && method && _typeof$1(method) === 'object' && typeof params === 'function';

    if (isBatch || isRaw) {
      callback = params;
      request = method;
    } else {
      if (typeof id === 'function') {
        callback = id; // specifically undefined because "null" is a notification request

        id = undefined;
      }

      var hasCallback = typeof callback === 'function';

      try {
        request = generateRequest(method, params, id, {
          generator: this.options.generator,
          version: this.options.version,
          notificationIdNull: this.options.notificationIdNull
        });
      } catch (err) {
        if (hasCallback) {
          return callback(err);
        }

        throw err;
      } // no callback means we should just return a raw request


      if (!hasCallback) {
        return request;
      }
    }

    var message;

    try {
      message = JSON.stringify(request, this.options.replacer);
    } catch (err) {
      return callback(err);
    }

    this.callServer(message, function (err, response) {
      self._parseResponse(err, response, callback);
    }); // always return the raw request

    return request;
  };
  /**
   * Parses a response from a server
   * @param {Object} err Error to pass on that is unrelated to the actual response
   * @param {String} responseText JSON-RPC 1.0 or 2.0 response
   * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters
   * @private
   */


  ClientBrowser.prototype._parseResponse = function (err, responseText, callback) {
    if (err) {
      callback(err);
      return;
    }

    if (!responseText) {
      // empty response text, assume that is correct because it could be a
      // notification which jayson does not give any body for
      return callback();
    }

    var response;

    try {
      response = JSON.parse(responseText, this.options.reviver);
    } catch (err) {
      return callback(err);
    }

    if (callback.length === 3) {
      // if callback length is 3, we split callback arguments on error and response
      // is batch response?
      if (Array.isArray(response)) {
        // neccesary to split strictly on validity according to spec here
        var isError = function isError(res) {
          return typeof res.error !== 'undefined';
        };

        var isNotError = function isNotError(res) {
          return !isError(res);
        };

        return callback(null, response.filter(isError), response.filter(isNotError));
      } else {
        // split regardless of validity
        return callback(null, response.error, response.result);
      }
    }

    callback(null, response);
  };

  var RpcClient = browser;

  var client = {};

  var interopRequireDefault = {exports: {}};

  (function (module) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }

    module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(interopRequireDefault);

  var regeneratorRuntime$1 = {exports: {}};

  var _typeof = {exports: {}};

  var hasRequired_typeof;

  function require_typeof() {
    if (hasRequired_typeof) return _typeof.exports;
    hasRequired_typeof = 1;

    (function (module) {
      function _typeof(obj) {
        "@babel/helpers - typeof";

        return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
          return typeof obj;
        } : function (obj) {
          return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
      }

      module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(_typeof);

    return _typeof.exports;
  }

  var hasRequiredRegeneratorRuntime;

  function requireRegeneratorRuntime() {
    if (hasRequiredRegeneratorRuntime) return regeneratorRuntime$1.exports;
    hasRequiredRegeneratorRuntime = 1;

    (function (module) {
      var _typeof = require_typeof()["default"];

      function _regeneratorRuntime() {
        /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

        module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
          return exports;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
        var exports = {},
            Op = Object.prototype,
            hasOwn = Op.hasOwnProperty,
            $Symbol = "function" == typeof Symbol ? Symbol : {},
            iteratorSymbol = $Symbol.iterator || "@@iterator",
            asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
            toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

        function define(obj, key, value) {
          return Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }), obj[key];
        }

        try {
          define({}, "");
        } catch (err) {
          define = function define(obj, key, value) {
            return obj[key] = value;
          };
        }

        function wrap(innerFn, outerFn, self, tryLocsList) {
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
              generator = Object.create(protoGenerator.prototype),
              context = new Context(tryLocsList || []);
          return generator._invoke = function (innerFn, self, context) {
            var state = "suspendedStart";
            return function (method, arg) {
              if ("executing" === state) throw new Error("Generator is already running");

              if ("completed" === state) {
                if ("throw" === method) throw arg;
                return doneResult();
              }

              for (context.method = method, context.arg = arg;;) {
                var delegate = context.delegate;

                if (delegate) {
                  var delegateResult = maybeInvokeDelegate(delegate, context);

                  if (delegateResult) {
                    if (delegateResult === ContinueSentinel) continue;
                    return delegateResult;
                  }
                }

                if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
                  if ("suspendedStart" === state) throw state = "completed", context.arg;
                  context.dispatchException(context.arg);
                } else "return" === context.method && context.abrupt("return", context.arg);
                state = "executing";
                var record = tryCatch(innerFn, self, context);

                if ("normal" === record.type) {
                  if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                  return {
                    value: record.arg,
                    done: context.done
                  };
                }

                "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
              }
            };
          }(innerFn, self, context), generator;
        }

        function tryCatch(fn, obj, arg) {
          try {
            return {
              type: "normal",
              arg: fn.call(obj, arg)
            };
          } catch (err) {
            return {
              type: "throw",
              arg: err
            };
          }
        }

        exports.wrap = wrap;
        var ContinueSentinel = {};

        function Generator() {}

        function GeneratorFunction() {}

        function GeneratorFunctionPrototype() {}

        var IteratorPrototype = {};
        define(IteratorPrototype, iteratorSymbol, function () {
          return this;
        });
        var getProto = Object.getPrototypeOf,
            NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
        var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function (method) {
            define(prototype, method, function (arg) {
              return this._invoke(method, arg);
            });
          });
        }

        function AsyncIterator(generator, PromiseImpl) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);

            if ("throw" !== record.type) {
              var result = record.arg,
                  value = result.value;
              return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
                invoke("next", value, resolve, reject);
              }, function (err) {
                invoke("throw", err, resolve, reject);
              }) : PromiseImpl.resolve(value).then(function (unwrapped) {
                result.value = unwrapped, resolve(result);
              }, function (error) {
                return invoke("throw", error, resolve, reject);
              });
            }

            reject(record.arg);
          }

          var previousPromise;

          this._invoke = function (method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function (resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }

            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          };
        }

        function maybeInvokeDelegate(delegate, context) {
          var method = delegate.iterator[context.method];

          if (undefined === method) {
            if (context.delegate = null, "throw" === context.method) {
              if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
              context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
            }

            return ContinueSentinel;
          }

          var record = tryCatch(method, delegate.iterator, context.arg);
          if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
          var info = record.arg;
          return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
        }

        function pushTryEntry(locs) {
          var entry = {
            tryLoc: locs[0]
          };
          1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
        }

        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal", delete record.arg, entry.completion = record;
        }

        function Context(tryLocsList) {
          this.tryEntries = [{
            tryLoc: "root"
          }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
        }

        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next) return iterable;

            if (!isNaN(iterable.length)) {
              var i = -1,
                  next = function next() {
                for (; ++i < iterable.length;) {
                  if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                }

                return next.value = undefined, next.done = !0, next;
              };

              return next.next = next;
            }
          }

          return {
            next: doneResult
          };
        }

        function doneResult() {
          return {
            value: undefined,
            done: !0
          };
        }

        return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
          var ctor = "function" == typeof genFun && genFun.constructor;
          return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
        }, exports.mark = function (genFun) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
        }, exports.awrap = function (arg) {
          return {
            __await: arg
          };
        }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
          return this;
        }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
          void 0 === PromiseImpl && (PromiseImpl = Promise);
          var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
          return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
            return result.done ? result.value : iter.next();
          });
        }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
          return this;
        }), define(Gp, "toString", function () {
          return "[object Generator]";
        }), exports.keys = function (object) {
          var keys = [];

          for (var key in object) {
            keys.push(key);
          }

          return keys.reverse(), function next() {
            for (; keys.length;) {
              var key = keys.pop();
              if (key in object) return next.value = key, next.done = !1, next;
            }

            return next.done = !0, next;
          };
        }, exports.values = values, Context.prototype = {
          constructor: Context,
          reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
              "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
            }
          },
          stop: function stop() {
            this.done = !0;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type) throw rootRecord.arg;
            return this.rval;
          },
          dispatchException: function dispatchException(exception) {
            if (this.done) throw exception;
            var context = this;

            function handle(loc, caught) {
              return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
            }

            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i],
                  record = entry.completion;
              if ("root" === entry.tryLoc) return handle("end");

              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc"),
                    hasFinally = hasOwn.call(entry, "finallyLoc");

                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                  if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                } else {
                  if (!hasFinally) throw new Error("try statement without catch or finally");
                  if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                }
              }
            }
          },
          abrupt: function abrupt(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];

              if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }

            finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
          },
          complete: function complete(record, afterLoc) {
            if ("throw" === record.type) throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
          },
          finish: function finish(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
          },
          "catch": function _catch(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];

              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;

                if ("throw" === record.type) {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }

                return thrown;
              }
            }

            throw new Error("illegal catch attempt");
          },
          delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
              iterator: values(iterable),
              resultName: resultName,
              nextLoc: nextLoc
            }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
          }
        }, exports;
      }

      module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(regeneratorRuntime$1);

    return regeneratorRuntime$1.exports;
  }

  var regenerator;
  var hasRequiredRegenerator;

  function requireRegenerator() {
    if (hasRequiredRegenerator) return regenerator;
    hasRequiredRegenerator = 1; // TODO(Babel 8): Remove this file.

    var runtime = requireRegeneratorRuntime()();
    regenerator = runtime; // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=

    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if ((typeof globalThis === "undefined" ? "undefined" : _typeof$1(globalThis)) === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }

    return regenerator;
  }

  var asyncToGenerator = {exports: {}};

  var hasRequiredAsyncToGenerator;

  function requireAsyncToGenerator() {
    if (hasRequiredAsyncToGenerator) return asyncToGenerator.exports;
    hasRequiredAsyncToGenerator = 1;

    (function (module) {
      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }

      function _asyncToGenerator(fn) {
        return function () {
          var self = this,
              args = arguments;
          return new Promise(function (resolve, reject) {
            var gen = fn.apply(self, args);

            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }

            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }

            _next(undefined);
          });
        };
      }

      module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(asyncToGenerator);

    return asyncToGenerator.exports;
  }

  var classCallCheck = {exports: {}};

  var hasRequiredClassCallCheck;

  function requireClassCallCheck() {
    if (hasRequiredClassCallCheck) return classCallCheck.exports;
    hasRequiredClassCallCheck = 1;

    (function (module) {
      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(classCallCheck);

    return classCallCheck.exports;
  }

  var createClass = {exports: {}};

  var hasRequiredCreateClass;

  function requireCreateClass() {
    if (hasRequiredCreateClass) return createClass.exports;
    hasRequiredCreateClass = 1;

    (function (module) {
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        Object.defineProperty(Constructor, "prototype", {
          writable: false
        });
        return Constructor;
      }

      module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(createClass);

    return createClass.exports;
  }

  var inherits = {exports: {}};

  var setPrototypeOf = {exports: {}};

  var hasRequiredSetPrototypeOf;

  function requireSetPrototypeOf() {
    if (hasRequiredSetPrototypeOf) return setPrototypeOf.exports;
    hasRequiredSetPrototypeOf = 1;

    (function (module) {
      function _setPrototypeOf(o, p) {
        module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
        return _setPrototypeOf(o, p);
      }

      module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(setPrototypeOf);

    return setPrototypeOf.exports;
  }

  var hasRequiredInherits;

  function requireInherits() {
    if (hasRequiredInherits) return inherits.exports;
    hasRequiredInherits = 1;

    (function (module) {
      var setPrototypeOf = requireSetPrototypeOf();

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        Object.defineProperty(subClass, "prototype", {
          writable: false
        });
        if (superClass) setPrototypeOf(subClass, superClass);
      }

      module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(inherits);

    return inherits.exports;
  }

  var possibleConstructorReturn = {exports: {}};

  var assertThisInitialized = {exports: {}};

  var hasRequiredAssertThisInitialized;

  function requireAssertThisInitialized() {
    if (hasRequiredAssertThisInitialized) return assertThisInitialized.exports;
    hasRequiredAssertThisInitialized = 1;

    (function (module) {
      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(assertThisInitialized);

    return assertThisInitialized.exports;
  }

  var hasRequiredPossibleConstructorReturn;

  function requirePossibleConstructorReturn() {
    if (hasRequiredPossibleConstructorReturn) return possibleConstructorReturn.exports;
    hasRequiredPossibleConstructorReturn = 1;

    (function (module) {
      var _typeof = require_typeof()["default"];
      var assertThisInitialized = requireAssertThisInitialized();

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof(call) === "object" || typeof call === "function")) {
          return call;
        } else if (call !== void 0) {
          throw new TypeError("Derived constructors may only return object or undefined");
        }

        return assertThisInitialized(self);
      }

      module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(possibleConstructorReturn);

    return possibleConstructorReturn.exports;
  }

  var getPrototypeOf = {exports: {}};

  var hasRequiredGetPrototypeOf;

  function requireGetPrototypeOf() {
    if (hasRequiredGetPrototypeOf) return getPrototypeOf.exports;
    hasRequiredGetPrototypeOf = 1;

    (function (module) {
      function _getPrototypeOf(o) {
        module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
        return _getPrototypeOf(o);
      }

      module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
    })(getPrototypeOf);

    return getPrototypeOf.exports;
  }

  var eventemitter3 = {exports: {}};

  var hasRequiredEventemitter3;

  function requireEventemitter3() {
    if (hasRequiredEventemitter3) return eventemitter3.exports;
    hasRequiredEventemitter3 = 1;

    (function (module) {

      var has = Object.prototype.hasOwnProperty,
          prefix = '~';
      /**
       * Constructor to create a storage for our `EE` objects.
       * An `Events` instance is a plain object whose properties are event names.
       *
       * @constructor
       * @private
       */

      function Events() {} //
      // We try to not inherit from `Object.prototype`. In some engines creating an
      // instance in this way is faster than calling `Object.create(null)` directly.
      // If `Object.create(null)` is not supported we prefix the event names with a
      // character to make sure that the built-in object properties are not
      // overridden or used as an attack vector.
      //


      if (Object.create) {
        Events.prototype = Object.create(null); //
        // This hack is needed because the `__proto__` property is still inherited in
        // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
        //

        if (!new Events().__proto__) prefix = false;
      }
      /**
       * Representation of a single event listener.
       *
       * @param {Function} fn The listener function.
       * @param {*} context The context to invoke the listener with.
       * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
       * @constructor
       * @private
       */


      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      /**
       * Add a listener for a given event.
       *
       * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
       * @param {(String|Symbol)} event The event name.
       * @param {Function} fn The listener function.
       * @param {*} context The context to invoke the listener with.
       * @param {Boolean} once Specify if the listener is a one-time listener.
       * @returns {EventEmitter}
       * @private
       */


      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== 'function') {
          throw new TypeError('The listener must be a function');
        }

        var listener = new EE(fn, context || emitter, once),
            evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      /**
       * Clear event by name.
       *
       * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
       * @param {(String|Symbol)} evt The Event name.
       * @private
       */


      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
      }
      /**
       * Minimal `EventEmitter` interface that is molded against the Node.js
       * `EventEmitter` interface.
       *
       * @constructor
       * @public
       */


      function EventEmitter() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      /**
       * Return an array listing the events for which the emitter has registered
       * listeners.
       *
       * @returns {Array}
       * @public
       */


      EventEmitter.prototype.eventNames = function eventNames() {
        var names = [],
            events,
            name;
        if (this._eventsCount === 0) return names;

        for (name in events = this._events) {
          if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
        }

        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }

        return names;
      };
      /**
       * Return the listeners registered for a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @returns {Array} The registered listeners.
       * @public
       */


      EventEmitter.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event,
            handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];

        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
          ee[i] = handlers[i].fn;
        }

        return ee;
      };
      /**
       * Return the number of listeners listening to a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @returns {Number} The number of listeners.
       * @public
       */


      EventEmitter.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event,
            listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      /**
       * Calls each of the listeners registered for a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @returns {Boolean} `true` if the event had listeners, else `false`.
       * @public
       */


      EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt],
            len = arguments.length,
            args,
            i;

        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

          switch (len) {
            case 1:
              return listeners.fn.call(listeners.context), true;

            case 2:
              return listeners.fn.call(listeners.context, a1), true;

            case 3:
              return listeners.fn.call(listeners.context, a1, a2), true;

            case 4:
              return listeners.fn.call(listeners.context, a1, a2, a3), true;

            case 5:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;

            case 6:
              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
          }

          for (i = 1, args = new Array(len - 1); i < len; i++) {
            args[i - 1] = arguments[i];
          }

          listeners.fn.apply(listeners.context, args);
        } else {
          var length = listeners.length,
              j;

          for (i = 0; i < length; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

            switch (len) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;

              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;

              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a2);
                break;

              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                break;

              default:
                if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }

        return true;
      };
      /**
       * Add a listener for a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @param {Function} fn The listener function.
       * @param {*} [context=this] The context to invoke the listener with.
       * @returns {EventEmitter} `this`.
       * @public
       */


      EventEmitter.prototype.on = function on(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      /**
       * Add a one-time listener for a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @param {Function} fn The listener function.
       * @param {*} [context=this] The context to invoke the listener with.
       * @returns {EventEmitter} `this`.
       * @public
       */


      EventEmitter.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      /**
       * Remove the listeners of a given event.
       *
       * @param {(String|Symbol)} event The event name.
       * @param {Function} fn Only remove the listeners that match this function.
       * @param {*} context Only remove the listeners that have this context.
       * @param {Boolean} once Only remove one-time listeners.
       * @returns {EventEmitter} `this`.
       * @public
       */


      EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;

        if (!fn) {
          clearEvent(this, evt);
          return this;
        }

        var listeners = this._events[evt];

        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length = listeners.length; i < length; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          } //
          // Reset the array, or remove it completely if we have no more listeners.
          //


          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
        }

        return this;
      };
      /**
       * Remove all listeners, or those of the specified event.
       *
       * @param {(String|Symbol)} [event] The event name.
       * @returns {EventEmitter} `this`.
       * @public
       */


      EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;

        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }

        return this;
      }; //
      // Alias methods names because people roll like that.
      //


      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.addListener = EventEmitter.prototype.on; //
      // Expose the prefix.
      //

      EventEmitter.prefixed = prefix; //
      // Allow `EventEmitter` to be imported as module namespace.
      //

      EventEmitter.EventEmitter = EventEmitter; //
      // Expose the module.
      //

      {
        module.exports = EventEmitter;
      }
    })(eventemitter3);

    return eventemitter3.exports;
  }

  (function (exports) {

    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;

    var _regenerator = _interopRequireDefault(requireRegenerator());

    var _asyncToGenerator2 = _interopRequireDefault(requireAsyncToGenerator());

    var _typeof2 = _interopRequireDefault(require_typeof());

    var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());

    var _createClass2 = _interopRequireDefault(requireCreateClass());

    var _inherits2 = _interopRequireDefault(requireInherits());

    var _possibleConstructorReturn2 = _interopRequireDefault(requirePossibleConstructorReturn());

    var _getPrototypeOf2 = _interopRequireDefault(requireGetPrototypeOf());

    var _eventemitter = requireEventemitter3();

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var __rest = function (s, e) {
      var t = {};

      for (var p in s) {
        if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      }

      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    }; // @ts-ignore


    var CommonClient = /*#__PURE__*/function (_EventEmitter) {
      (0, _inherits2["default"])(CommonClient, _EventEmitter);

      var _super = _createSuper(CommonClient);
      /**
       * Instantiate a Client class.
       * @constructor
       * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
       * @param {String} address - url to a websocket server
       * @param {Object} options - ws options object with reconnect parameters
       * @param {Function} generate_request_id - custom generation request Id
       * @return {CommonClient}
       */


      function CommonClient(webSocketFactory) {
        var _this;

        var address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "ws://localhost:8080";

        var _a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        var generate_request_id = arguments.length > 3 ? arguments[3] : undefined;
        (0, _classCallCheck2["default"])(this, CommonClient);

        var _a$autoconnect = _a.autoconnect,
            autoconnect = _a$autoconnect === void 0 ? true : _a$autoconnect,
            _a$reconnect = _a.reconnect,
            reconnect = _a$reconnect === void 0 ? true : _a$reconnect,
            _a$reconnect_interval = _a.reconnect_interval,
            reconnect_interval = _a$reconnect_interval === void 0 ? 1000 : _a$reconnect_interval,
            _a$max_reconnects = _a.max_reconnects,
            max_reconnects = _a$max_reconnects === void 0 ? 5 : _a$max_reconnects,
            rest_options = __rest(_a, ["autoconnect", "reconnect", "reconnect_interval", "max_reconnects"]);

        _this = _super.call(this);
        _this.webSocketFactory = webSocketFactory;
        _this.queue = {};
        _this.rpc_id = 0;
        _this.address = address;
        _this.autoconnect = autoconnect;
        _this.ready = false;
        _this.reconnect = reconnect;
        _this.reconnect_timer_id = undefined;
        _this.reconnect_interval = reconnect_interval;
        _this.max_reconnects = max_reconnects;
        _this.rest_options = rest_options;
        _this.current_reconnects = 0;

        _this.generate_request_id = generate_request_id || function () {
          return ++_this.rpc_id;
        };

        if (_this.autoconnect) _this._connect(_this.address, Object.assign({
          autoconnect: _this.autoconnect,
          reconnect: _this.reconnect,
          reconnect_interval: _this.reconnect_interval,
          max_reconnects: _this.max_reconnects
        }, _this.rest_options));
        return _this;
      }
      /**
       * Connects to a defined server if not connected already.
       * @method
       * @return {Undefined}
       */


      (0, _createClass2["default"])(CommonClient, [{
        key: "connect",
        value: function connect() {
          if (this.socket) return;

          this._connect(this.address, Object.assign({
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects
          }, this.rest_options));
        }
        /**
         * Calls a registered RPC method on server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object|Array} params - optional method parameters
         * @param {Number} timeout - RPC reply timeout value
         * @param {Object} ws_opts - options passed to ws
         * @return {Promise}
         */

      }, {
        key: "call",
        value: function call(method, params, timeout, ws_opts) {
          var _this2 = this;

          if (!ws_opts && "object" === (0, _typeof2["default"])(timeout)) {
            ws_opts = timeout;
            timeout = null;
          }

          return new Promise(function (resolve, reject) {
            if (!_this2.ready) return reject(new Error("socket not ready"));

            var rpc_id = _this2.generate_request_id(method, params);

            var message = {
              jsonrpc: "2.0",
              method: method,
              params: params || null,
              id: rpc_id
            };

            _this2.socket.send(JSON.stringify(message), ws_opts, function (error) {
              if (error) return reject(error);
              _this2.queue[rpc_id] = {
                promise: [resolve, reject]
              };

              if (timeout) {
                _this2.queue[rpc_id].timeout = setTimeout(function () {
                  delete _this2.queue[rpc_id];
                  reject(new Error("reply timeout"));
                }, timeout);
              }
            });
          });
        }
        /**
         * Logins with the other side of the connection.
         * @method
         * @param {Object} params - Login credentials object
         * @return {Promise}
         */

      }, {
        key: "login",
        value: function () {
          var _login = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(params) {
            var resp;
            return _regenerator["default"].wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return this.call("rpc.login", params);

                  case 2:
                    resp = _context.sent;

                    if (resp) {
                      _context.next = 5;
                      break;
                    }

                    throw new Error("authentication failed");

                  case 5:
                    return _context.abrupt("return", resp);

                  case 6:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));

          function login(_x) {
            return _login.apply(this, arguments);
          }

          return login;
        }()
        /**
         * Fetches a list of client's methods registered on server.
         * @method
         * @return {Array}
         */

      }, {
        key: "listMethods",
        value: function () {
          var _listMethods = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
            return _regenerator["default"].wrap(function _callee2$(_context2) {
              while (1) {
                switch (_context2.prev = _context2.next) {
                  case 0:
                    _context2.next = 2;
                    return this.call("__listMethods");

                  case 2:
                    return _context2.abrupt("return", _context2.sent);

                  case 3:
                  case "end":
                    return _context2.stop();
                }
              }
            }, _callee2, this);
          }));

          function listMethods() {
            return _listMethods.apply(this, arguments);
          }

          return listMethods;
        }()
        /**
         * Sends a JSON-RPC 2.0 notification to server.
         * @method
         * @param {String} method - RPC method name
         * @param {Object} params - optional method parameters
         * @return {Promise}
         */

      }, {
        key: "notify",
        value: function notify(method, params) {
          var _this3 = this;

          return new Promise(function (resolve, reject) {
            if (!_this3.ready) return reject(new Error("socket not ready"));
            var message = {
              jsonrpc: "2.0",
              method: method,
              params: params || null
            };

            _this3.socket.send(JSON.stringify(message), function (error) {
              if (error) return reject(error);
              resolve();
            });
          });
        }
        /**
         * Subscribes for a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */

      }, {
        key: "subscribe",
        value: function () {
          var _subscribe = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(event) {
            var result;
            return _regenerator["default"].wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    if (typeof event === "string") event = [event];
                    _context3.next = 3;
                    return this.call("rpc.on", event);

                  case 3:
                    result = _context3.sent;

                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context3.next = 6;
                      break;
                    }

                    throw new Error("Failed subscribing to an event '" + event + "' with: " + result[event]);

                  case 6:
                    return _context3.abrupt("return", result);

                  case 7:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3, this);
          }));

          function subscribe(_x2) {
            return _subscribe.apply(this, arguments);
          }

          return subscribe;
        }()
        /**
         * Unsubscribes from a defined event.
         * @method
         * @param {String|Array} event - event name
         * @return {Undefined}
         * @throws {Error}
         */

      }, {
        key: "unsubscribe",
        value: function () {
          var _unsubscribe = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4(event) {
            var result;
            return _regenerator["default"].wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (typeof event === "string") event = [event];
                    _context4.next = 3;
                    return this.call("rpc.off", event);

                  case 3:
                    result = _context4.sent;

                    if (!(typeof event === "string" && result[event] !== "ok")) {
                      _context4.next = 6;
                      break;
                    }

                    throw new Error("Failed unsubscribing from an event with: " + result);

                  case 6:
                    return _context4.abrupt("return", result);

                  case 7:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4, this);
          }));

          function unsubscribe(_x3) {
            return _unsubscribe.apply(this, arguments);
          }

          return unsubscribe;
        }()
        /**
         * Closes a WebSocket connection gracefully.
         * @method
         * @param {Number} code - socket close code
         * @param {String} data - optional data to be sent before closing
         * @return {Undefined}
         */

      }, {
        key: "close",
        value: function close(code, data) {
          this.socket.close(code || 1000, data);
        }
        /**
         * Connection/Message handler.
         * @method
         * @private
         * @param {String} address - WebSocket API address
         * @param {Object} options - ws options object
         * @return {Undefined}
         */

      }, {
        key: "_connect",
        value: function _connect(address, options) {
          var _this4 = this;

          clearTimeout(this.reconnect_timer_id);
          this.socket = this.webSocketFactory(address, options);
          this.socket.addEventListener("open", function () {
            _this4.ready = true;

            _this4.emit("open");

            _this4.current_reconnects = 0;
          });
          this.socket.addEventListener("message", function (_ref) {
            var message = _ref.data;
            if (message instanceof ArrayBuffer) message = Buffer$1.from(message).toString();

            try {
              message = JSON.parse(message);
            } catch (error) {
              return;
            } // check if any listeners are attached and forward event


            if (message.notification && _this4.listeners(message.notification).length) {
              if (!Object.keys(message.params).length) return _this4.emit(message.notification);
              var args = [message.notification];
              if (message.params.constructor === Object) args.push(message.params);else // using for-loop instead of unshift/spread because performance is better
                for (var i = 0; i < message.params.length; i++) {
                  args.push(message.params[i]);
                } // run as microtask so that pending queue messages are resolved first
              // eslint-disable-next-line prefer-spread

              return Promise.resolve().then(function () {
                _this4.emit.apply(_this4, args);
              });
            }

            if (!_this4.queue[message.id]) {
              // general JSON RPC 2.0 events
              if (message.method && message.params) {
                // run as microtask so that pending queue messages are resolved first
                return Promise.resolve().then(function () {
                  _this4.emit(message.method, message.params);
                });
              }

              return;
            } // reject early since server's response is invalid


            if ("error" in message === "result" in message) _this4.queue[message.id].promise[1](new Error("Server response malformed. Response must include either \"result\"" + " or \"error\", but not both."));
            if (_this4.queue[message.id].timeout) clearTimeout(_this4.queue[message.id].timeout);
            if (message.error) _this4.queue[message.id].promise[1](message.error);else _this4.queue[message.id].promise[0](message.result);
            delete _this4.queue[message.id];
          });
          this.socket.addEventListener("error", function (error) {
            return _this4.emit("error", error);
          });
          this.socket.addEventListener("close", function (_ref2) {
            var code = _ref2.code,
                reason = _ref2.reason;
            if (_this4.ready) // Delay close event until internal state is updated
              setTimeout(function () {
                return _this4.emit("close", code, reason);
              }, 0);
            _this4.ready = false;
            _this4.socket = undefined;
            if (code === 1000) return;
            _this4.current_reconnects++;
            if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0)) _this4.reconnect_timer_id = setTimeout(function () {
              return _this4._connect(address, options);
            }, _this4.reconnect_interval);
          });
        }
      }]);
      return CommonClient;
    }(_eventemitter.EventEmitter);

    exports["default"] = CommonClient;
  })(client);

  var RpcWebSocketCommonClient = /*@__PURE__*/getDefaultExportFromCjs(client);

  var websocket_browser = {};

  /**
   * WebSocket implements a browser-side WebSocket specification.
   * @module Client
   */

  (function (exports) {

    var _interopRequireDefault = interopRequireDefault.exports;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = _default;

    var _classCallCheck2 = _interopRequireDefault(requireClassCallCheck());

    var _createClass2 = _interopRequireDefault(requireCreateClass());

    var _inherits2 = _interopRequireDefault(requireInherits());

    var _possibleConstructorReturn2 = _interopRequireDefault(requirePossibleConstructorReturn());

    var _getPrototypeOf2 = _interopRequireDefault(requireGetPrototypeOf());

    var _eventemitter = requireEventemitter3();

    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();

      return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2["default"])(Derived),
            result;

        if (hasNativeReflectConstruct) {
          var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }

        return (0, _possibleConstructorReturn2["default"])(this, result);
      };
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    var WebSocketBrowserImpl = /*#__PURE__*/function (_EventEmitter) {
      (0, _inherits2["default"])(WebSocketBrowserImpl, _EventEmitter);

      var _super = _createSuper(WebSocketBrowserImpl);
      /** Instantiate a WebSocket class
       * @constructor
       * @param {String} address - url to a websocket server
       * @param {(Object)} options - websocket options
       * @param {(String|Array)} protocols - a list of protocols
       * @return {WebSocketBrowserImpl} - returns a WebSocket instance
       */


      function WebSocketBrowserImpl(address, options, protocols) {
        var _this;

        (0, _classCallCheck2["default"])(this, WebSocketBrowserImpl);
        _this = _super.call(this);
        _this.socket = new window.WebSocket(address, protocols);

        _this.socket.onopen = function () {
          return _this.emit("open");
        };

        _this.socket.onmessage = function (event) {
          return _this.emit("message", event.data);
        };

        _this.socket.onerror = function (error) {
          return _this.emit("error", error);
        };

        _this.socket.onclose = function (event) {
          _this.emit("close", event.code, event.reason);
        };

        return _this;
      }
      /**
       * Sends data through a websocket connection
       * @method
       * @param {(String|Object)} data - data to be sent via websocket
       * @param {Object} optionsOrCallback - ws options
       * @param {Function} callback - a callback called once the data is sent
       * @return {Undefined}
       */


      (0, _createClass2["default"])(WebSocketBrowserImpl, [{
        key: "send",
        value: function send(data, optionsOrCallback, callback) {
          var cb = callback || optionsOrCallback;

          try {
            this.socket.send(data);
            cb();
          } catch (error) {
            cb(error);
          }
        }
        /**
         * Closes an underlying socket
         * @method
         * @param {Number} code - status code explaining why the connection is being closed
         * @param {String} reason - a description why the connection is closing
         * @return {Undefined}
         * @throws {Error}
         */

      }, {
        key: "close",
        value: function close(code, reason) {
          this.socket.close(code, reason);
        }
      }, {
        key: "addEventListener",
        value: function addEventListener(type, listener, options) {
          this.socket.addEventListener(type, listener, options);
        }
      }]);
      return WebSocketBrowserImpl;
    }(_eventemitter.EventEmitter);
    /**
     * factory method for common WebSocket instance
     * @method
     * @param {String} address - url to a websocket server
     * @param {(Object)} options - websocket options
     * @return {Undefined}
     */


    function _default(address, options) {
      return new WebSocketBrowserImpl(address, options);
    }
  })(websocket_browser);

  var createRpc = /*@__PURE__*/getDefaultExportFromCjs(websocket_browser);

  var SHA3_PI = [],
      SHA3_ROTL = [],
      _SHA3_IOTA = [];

  var _0n$1 = BigInt(0);

  var _1n$1 = BigInt(1);

  var _2n$1 = BigInt(2);

  var _7n = BigInt(7);

  var _256n = BigInt(256);

  var _0x71n = BigInt(0x71);

  for (var round = 0, R = _1n$1, x = 1, y = 0; round < 24; round++) {
    // Pi
    var _ref = [y, (2 * x + 3 * y) % 5];
    x = _ref[0];
    y = _ref[1];
    SHA3_PI.push(2 * (5 * y + x)); // Rotational

    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64); // Iota

    var t = _0n$1;

    for (var j = 0; j < 7; j++) {
      R = (R << _1n$1 ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n$1) t ^= _1n$1 << (_1n$1 << BigInt(j)) - _1n$1;
    }

    _SHA3_IOTA.push(t);
  }

  var _u64$split = u64$2.split(_SHA3_IOTA, true),
      _u64$split2 = _slicedToArray(_u64$split, 2),
      SHA3_IOTA_H = _u64$split2[0],
      SHA3_IOTA_L = _u64$split2[1]; // Left rotation (without 0, 32, 64)


  var rotlH = function rotlH(h, l, s) {
    return s > 32 ? u64$2.rotlBH(h, l, s) : u64$2.rotlSH(h, l, s);
  };

  var rotlL = function rotlL(h, l, s) {
    return s > 32 ? u64$2.rotlBL(h, l, s) : u64$2.rotlSL(h, l, s);
  }; // Same as keccakf1600, but allows to skip some rounds


  function keccakP(s) {
    var rounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24;
    var B = new Uint32Array(5 * 2); // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)

    for (var _round2 = 24 - rounds; _round2 < 24; _round2++) {
      // Theta θ
      for (var _x2 = 0; _x2 < 10; _x2++) B[_x2] = s[_x2] ^ s[_x2 + 10] ^ s[_x2 + 20] ^ s[_x2 + 30] ^ s[_x2 + 40];

      for (var _x4 = 0; _x4 < 10; _x4 += 2) {
        var idx1 = (_x4 + 8) % 10;
        var idx0 = (_x4 + 2) % 10;
        var B0 = B[idx0];
        var B1 = B[idx0 + 1];
        var Th = rotlH(B0, B1, 1) ^ B[idx1];
        var Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];

        for (var _y2 = 0; _y2 < 50; _y2 += 10) {
          s[_x4 + _y2] ^= Th;
          s[_x4 + _y2 + 1] ^= Tl;
        }
      } // Rho (ρ) and Pi (π)


      var curH = s[2];
      var curL = s[3];

      for (var _t2 = 0; _t2 < 24; _t2++) {
        var shift = SHA3_ROTL[_t2];

        var _Th = rotlH(curH, curL, shift);

        var _Tl = rotlL(curH, curL, shift);

        var PI = SHA3_PI[_t2];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = _Th;
        s[PI + 1] = _Tl;
      } // Chi (χ)


      for (var _y4 = 0; _y4 < 50; _y4 += 10) {
        for (var _x6 = 0; _x6 < 10; _x6++) B[_x6] = s[_y4 + _x6];

        for (var _x8 = 0; _x8 < 10; _x8++) s[_y4 + _x8] ^= ~B[(_x8 + 2) % 10] & B[(_x8 + 4) % 10];
      } // Iota (ι)


      s[0] ^= SHA3_IOTA_H[_round2];
      s[1] ^= SHA3_IOTA_L[_round2];
    }

    B.fill(0);
  }
  var Keccak = /*#__PURE__*/function (_Hash) {
    _inherits(Keccak, _Hash);

    var _super = _createSuper(Keccak);

    // NOTE: we accept arguments in bytes instead of bits here.
    function Keccak(blockLen, suffix, outputLen) {
      var _this;

      var enableXOF = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var rounds = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 24;

      _classCallCheck(this, Keccak);

      _this = _super.call(this);
      _this.blockLen = blockLen;
      _this.suffix = suffix;
      _this.outputLen = outputLen;
      _this.enableXOF = enableXOF;
      _this.rounds = rounds;
      _this.pos = 0;
      _this.posOut = 0;
      _this.finished = false;
      _this.destroyed = false; // Can be passed from user as dkLen

      assert$2.number(outputLen); // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes

      if (0 >= _this.blockLen || _this.blockLen >= 200) throw new Error('Sha3 supports only keccak-f1600 function');
      _this.state = new Uint8Array(200);
      _this.state32 = u32$1(_this.state);
      return _this;
    }

    _createClass(Keccak, [{
      key: "keccak",
      value: function keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
    }, {
      key: "update",
      value: function update(data) {
        assert$2.exists(this);
        var blockLen = this.blockLen,
            state = this.state;
        data = toBytes(data);
        var len = data.length;

        for (var pos = 0; pos < len;) {
          var take = Math.min(blockLen - this.pos, len - pos);

          for (var i = 0; i < take; i++) state[this.pos++] ^= data[pos++];

          if (this.pos === blockLen) this.keccak();
        }

        return this;
      }
    }, {
      key: "finish",
      value: function finish() {
        if (this.finished) return;
        this.finished = true;
        var state = this.state,
            suffix = this.suffix,
            pos = this.pos,
            blockLen = this.blockLen; // Do the padding

        state[pos] ^= suffix;
        if ((suffix & 0x80) !== 0 && pos === blockLen - 1) this.keccak();
        state[blockLen - 1] ^= 0x80;
        this.keccak();
      }
    }, {
      key: "writeInto",
      value: function writeInto(out) {
        assert$2.exists(this, false);
        assert$2.bytes(out);
        this.finish();
        var bufferOut = this.state;
        var blockLen = this.blockLen;

        for (var pos = 0, len = out.length; pos < len;) {
          if (this.posOut >= blockLen) this.keccak();
          var take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }

        return out;
      }
    }, {
      key: "xofInto",
      value: function xofInto(out) {
        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF
        if (!this.enableXOF) throw new Error('XOF is not possible for this instance');
        return this.writeInto(out);
      }
    }, {
      key: "xof",
      value: function xof(bytes) {
        assert$2.number(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
    }, {
      key: "digestInto",
      value: function digestInto(out) {
        assert$2.output(out, this);
        if (this.finished) throw new Error('digest() was already called');
        this.writeInto(out);
        this.destroy();
        return out;
      }
    }, {
      key: "digest",
      value: function digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
    }, {
      key: "_cloneInto",
      value: function _cloneInto(to) {
        var blockLen = this.blockLen,
            suffix = this.suffix,
            outputLen = this.outputLen,
            rounds = this.rounds,
            enableXOF = this.enableXOF;
        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds; // Suffix can change in cSHAKE

        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    }]);

    return Keccak;
  }(Hash);

  var gen = function gen(suffix, blockLen, outputLen) {
    return wrapConstructor(function () {
      return new Keccak(blockLen, suffix, outputLen);
    });
  };

  gen(0x06, 144, 224 / 8);
  /**
   * SHA3-256 hash function
   * @param message - that would be hashed
   */

  gen(0x06, 136, 256 / 8);
  gen(0x06, 104, 384 / 8);
  gen(0x06, 72, 512 / 8);
  gen(0x01, 144, 224 / 8);
  /**
   * keccak-256 hash function. Different from SHA3-256.
   * @param message - that would be hashed
   */

  var keccak_256 = gen(0x01, 136, 256 / 8);
  gen(0x01, 104, 384 / 8);
  gen(0x01, 72, 512 / 8);

  var genShake = function genShake(suffix, blockLen, outputLen) {
    return wrapConstructorWithOpts(function () {
      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true);
    });
  };

  genShake(0x1f, 168, 128 / 8);
  genShake(0x1f, 136, 256 / 8);

  var HMAC = /*#__PURE__*/function (_Hash) {
    _inherits(HMAC, _Hash);

    var _super = _createSuper(HMAC);

    function HMAC(hash, _key) {
      var _this;

      _classCallCheck(this, HMAC);

      _this = _super.call(this);
      _this.finished = false;
      _this.destroyed = false;
      assert$2.hash(hash);
      var key = toBytes(_key);
      _this.iHash = hash.create();
      if (typeof _this.iHash.update !== 'function') throw new TypeError('Expected instance of class which extends utils.Hash');
      _this.blockLen = _this.iHash.blockLen;
      _this.outputLen = _this.iHash.outputLen;
      var blockLen = _this.blockLen;
      var pad = new Uint8Array(blockLen); // blockLen can be bigger than outputLen

      pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);

      for (var i = 0; i < pad.length; i++) pad[i] ^= 0x36;

      _this.iHash.update(pad); // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone


      _this.oHash = hash.create(); // Undo internal XOR && apply outer XOR

      for (var _i2 = 0; _i2 < pad.length; _i2++) pad[_i2] ^= 0x36 ^ 0x5c;

      _this.oHash.update(pad);

      pad.fill(0);
      return _this;
    }

    _createClass(HMAC, [{
      key: "update",
      value: function update(buf) {
        assert$2.exists(this);
        this.iHash.update(buf);
        return this;
      }
    }, {
      key: "digestInto",
      value: function digestInto(out) {
        assert$2.exists(this);
        assert$2.bytes(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
    }, {
      key: "digest",
      value: function digest() {
        var out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
    }, {
      key: "_cloneInto",
      value: function _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        var oHash = this.oHash,
            iHash = this.iHash,
            finished = this.finished,
            destroyed = this.destroyed,
            blockLen = this.blockLen,
            outputLen = this.outputLen;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    }]);

    return HMAC;
  }(Hash);
  /**
   * HMAC: RFC2104 message authentication code.
   * @param hash - function that would be used e.g. sha256
   * @param key - message key
   * @param message - message data
   */


  var hmac = function hmac(hash, key, message) {
    return new HMAC(hash, key).update(message).digest();
  };

  hmac.create = function (hash, key) {
    return new HMAC(hash, key);
  };

  var _0n = BigInt(0);

  var _1n = BigInt(1);

  var _2n = BigInt(2);

  var _3n = BigInt(3);

  var _8n = BigInt(8);

  var CURVE = Object.freeze({
    a: _0n,
    b: BigInt(7),
    P: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),
    n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),
    h: _1n,
    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),
    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee')
  });

  var divNearest = function divNearest(a, b) {
    return (a + b / _2n) / b;
  };

  var endo = {
    beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),
    splitScalar: function splitScalar(k) {
      var n = CURVE.n;
      var a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');
      var b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');
      var a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');
      var b2 = a1;
      var POW_2_128 = BigInt('0x100000000000000000000000000000000');
      var c1 = divNearest(b2 * k, n);
      var c2 = divNearest(-b1 * k, n);
      var k1 = mod(k - c1 * a1 - c2 * a2, n);
      var k2 = mod(-c1 * b1 - c2 * b2, n);
      var k1neg = k1 > POW_2_128;
      var k2neg = k2 > POW_2_128;
      if (k1neg) k1 = n - k1;
      if (k2neg) k2 = n - k2;

      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error('splitScalarEndo: Endomorphism failed, k=' + k);
      }

      return {
        k1neg: k1neg,
        k1: k1,
        k2neg: k2neg,
        k2: k2
      };
    }
  };
  var fieldLen = 32;
  var groupLen = 32;
  var hashLen = 32;
  var compressedLen = fieldLen + 1;
  var uncompressedLen = 2 * fieldLen + 1;

  function weierstrass(x) {
    var a = CURVE.a,
        b = CURVE.b;
    var x2 = mod(x * x);
    var x3 = mod(x2 * x);
    return mod(x3 + a * x + b);
  }

  var USE_ENDOMORPHISM = CURVE.a === _0n;

  var ShaError = /*#__PURE__*/function (_Error) {
    _inherits(ShaError, _Error);

    var _super = _createSuper(ShaError);

    function ShaError(message) {
      _classCallCheck(this, ShaError);

      return _super.call(this, message);
    }

    return _createClass(ShaError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  function assertJacPoint(other) {
    if (!(other instanceof JacobianPoint)) throw new TypeError('JacobianPoint expected');
  }

  var JacobianPoint = /*#__PURE__*/function () {
    function JacobianPoint(x, y, z) {
      _classCallCheck(this, JacobianPoint);

      this.x = x;
      this.y = y;
      this.z = z;
    }

    _createClass(JacobianPoint, [{
      key: "equals",
      value: function equals(other) {
        assertJacPoint(other);
        var X1 = this.x,
            Y1 = this.y,
            Z1 = this.z;
        var X2 = other.x,
            Y2 = other.y,
            Z2 = other.z;
        var Z1Z1 = mod(Z1 * Z1);
        var Z2Z2 = mod(Z2 * Z2);
        var U1 = mod(X1 * Z2Z2);
        var U2 = mod(X2 * Z1Z1);
        var S1 = mod(mod(Y1 * Z2) * Z2Z2);
        var S2 = mod(mod(Y2 * Z1) * Z1Z1);
        return U1 === U2 && S1 === S2;
      }
    }, {
      key: "negate",
      value: function negate() {
        return new JacobianPoint(this.x, mod(-this.y), this.z);
      }
    }, {
      key: "double",
      value: function double() {
        var X1 = this.x,
            Y1 = this.y,
            Z1 = this.z;
        var A = mod(X1 * X1);
        var B = mod(Y1 * Y1);
        var C = mod(B * B);
        var x1b = X1 + B;
        var D = mod(_2n * (mod(x1b * x1b) - A - C));
        var E = mod(_3n * A);
        var F = mod(E * E);
        var X3 = mod(F - _2n * D);
        var Y3 = mod(E * (D - X3) - _8n * C);
        var Z3 = mod(_2n * Y1 * Z1);
        return new JacobianPoint(X3, Y3, Z3);
      }
    }, {
      key: "add",
      value: function add(other) {
        assertJacPoint(other);
        var X1 = this.x,
            Y1 = this.y,
            Z1 = this.z;
        var X2 = other.x,
            Y2 = other.y,
            Z2 = other.z;
        if (X2 === _0n || Y2 === _0n) return this;
        if (X1 === _0n || Y1 === _0n) return other;
        var Z1Z1 = mod(Z1 * Z1);
        var Z2Z2 = mod(Z2 * Z2);
        var U1 = mod(X1 * Z2Z2);
        var U2 = mod(X2 * Z1Z1);
        var S1 = mod(mod(Y1 * Z2) * Z2Z2);
        var S2 = mod(mod(Y2 * Z1) * Z1Z1);
        var H = mod(U2 - U1);
        var r = mod(S2 - S1);

        if (H === _0n) {
          if (r === _0n) {
            return this["double"]();
          } else {
            return JacobianPoint.ZERO;
          }
        }

        var HH = mod(H * H);
        var HHH = mod(H * HH);
        var V = mod(U1 * HH);
        var X3 = mod(r * r - HHH - _2n * V);
        var Y3 = mod(r * (V - X3) - S1 * HHH);
        var Z3 = mod(Z1 * Z2 * H);
        return new JacobianPoint(X3, Y3, Z3);
      }
    }, {
      key: "subtract",
      value: function subtract(other) {
        return this.add(other.negate());
      }
    }, {
      key: "multiplyUnsafe",
      value: function multiplyUnsafe(scalar) {
        var P0 = JacobianPoint.ZERO;
        if (typeof scalar === 'bigint' && scalar === _0n) return P0;
        var n = normalizeScalar(scalar);
        if (n === _1n) return this;

        if (!USE_ENDOMORPHISM) {
          var p = P0;

          var _d = this;

          while (n > _0n) {
            if (n & _1n) p = p.add(_d);
            _d = _d["double"]();
            n >>= _1n;
          }

          return p;
        }

        var _endo$splitScalar = endo.splitScalar(n),
            k1neg = _endo$splitScalar.k1neg,
            k1 = _endo$splitScalar.k1,
            k2neg = _endo$splitScalar.k2neg,
            k2 = _endo$splitScalar.k2;

        var k1p = P0;
        var k2p = P0;
        var d = this;

        while (k1 > _0n || k2 > _0n) {
          if (k1 & _1n) k1p = k1p.add(d);
          if (k2 & _1n) k2p = k2p.add(d);
          d = d["double"]();
          k1 >>= _1n;
          k2 >>= _1n;
        }

        if (k1neg) k1p = k1p.negate();
        if (k2neg) k2p = k2p.negate();
        k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
        return k1p.add(k2p);
      }
    }, {
      key: "precomputeWindow",
      value: function precomputeWindow(W) {
        var windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
        var points = [];
        var p = this;
        var base = p;

        for (var window = 0; window < windows; window++) {
          base = p;
          points.push(base);

          for (var i = 1; i < Math.pow(2, W - 1); i++) {
            base = base.add(p);
            points.push(base);
          }

          p = base["double"]();
        }

        return points;
      }
    }, {
      key: "wNAF",
      value: function wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(JacobianPoint.BASE)) affinePoint = Point.BASE;
        var W = affinePoint && affinePoint._WINDOW_SIZE || 1;

        if (256 % W) {
          throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
        }

        var precomputes = affinePoint && pointPrecomputes.get(affinePoint);

        if (!precomputes) {
          precomputes = this.precomputeWindow(W);

          if (affinePoint && W !== 1) {
            precomputes = JacobianPoint.normalizeZ(precomputes);
            pointPrecomputes.set(affinePoint, precomputes);
          }
        }

        var p = JacobianPoint.ZERO;
        var f = JacobianPoint.BASE;
        var windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
        var windowSize = Math.pow(2, W - 1);
        var mask = BigInt(Math.pow(2, W) - 1);
        var maxNumber = Math.pow(2, W);
        var shiftBy = BigInt(W);

        for (var window = 0; window < windows; window++) {
          var offset = window * windowSize;
          var wbits = Number(n & mask);
          n >>= shiftBy;

          if (wbits > windowSize) {
            wbits -= maxNumber;
            n += _1n;
          }

          var offset1 = offset;
          var offset2 = offset + Math.abs(wbits) - 1;
          var cond1 = window % 2 !== 0;
          var cond2 = wbits < 0;

          if (wbits === 0) {
            f = f.add(constTimeNegate(cond1, precomputes[offset1]));
          } else {
            p = p.add(constTimeNegate(cond2, precomputes[offset2]));
          }
        }

        return {
          p: p,
          f: f
        };
      }
    }, {
      key: "multiply",
      value: function multiply(scalar, affinePoint) {
        var n = normalizeScalar(scalar);
        var point;
        var fake;

        if (USE_ENDOMORPHISM) {
          var _endo$splitScalar3 = endo.splitScalar(n),
              k1neg = _endo$splitScalar3.k1neg,
              k1 = _endo$splitScalar3.k1,
              k2neg = _endo$splitScalar3.k2neg,
              k2 = _endo$splitScalar3.k2;

          var _this$wNAF2 = this.wNAF(k1, affinePoint),
              k1p = _this$wNAF2.p,
              f1p = _this$wNAF2.f;

          var _this$wNAF4 = this.wNAF(k2, affinePoint),
              k2p = _this$wNAF4.p,
              f2p = _this$wNAF4.f;

          k1p = constTimeNegate(k1neg, k1p);
          k2p = constTimeNegate(k2neg, k2p);
          k2p = new JacobianPoint(mod(k2p.x * endo.beta), k2p.y, k2p.z);
          point = k1p.add(k2p);
          fake = f1p.add(f2p);
        } else {
          var _this$wNAF6 = this.wNAF(n, affinePoint),
              p = _this$wNAF6.p,
              f = _this$wNAF6.f;

          point = p;
          fake = f;
        }

        return JacobianPoint.normalizeZ([point, fake])[0];
      }
    }, {
      key: "toAffine",
      value: function toAffine(invZ) {
        var x = this.x,
            y = this.y,
            z = this.z;
        var is0 = this.equals(JacobianPoint.ZERO);
        if (invZ == null) invZ = is0 ? _8n : invert(z);
        var iz1 = invZ;
        var iz2 = mod(iz1 * iz1);
        var iz3 = mod(iz2 * iz1);
        var ax = mod(x * iz2);
        var ay = mod(y * iz3);
        var zz = mod(z * iz1);
        if (is0) return Point.ZERO;
        if (zz !== _1n) throw new Error('invZ was invalid');
        return new Point(ax, ay);
      }
    }], [{
      key: "fromAffine",
      value: function fromAffine(p) {
        if (!(p instanceof Point)) {
          throw new TypeError('JacobianPoint#fromAffine: expected Point');
        }

        if (p.equals(Point.ZERO)) return JacobianPoint.ZERO;
        return new JacobianPoint(p.x, p.y, _1n);
      }
    }, {
      key: "toAffineBatch",
      value: function toAffineBatch(points) {
        var toInv = invertBatch(points.map(function (p) {
          return p.z;
        }));
        return points.map(function (p, i) {
          return p.toAffine(toInv[i]);
        });
      }
    }, {
      key: "normalizeZ",
      value: function normalizeZ(points) {
        return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
      }
    }]);

    return JacobianPoint;
  }();

  JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n);
  JacobianPoint.ZERO = new JacobianPoint(_0n, _1n, _0n);

  function constTimeNegate(condition, item) {
    var neg = item.negate();
    return condition ? neg : item;
  }

  var pointPrecomputes = new WeakMap();
  var Point = /*#__PURE__*/function () {
    function Point(x, y) {
      _classCallCheck(this, Point);

      this.x = x;
      this.y = y;
    }

    _createClass(Point, [{
      key: "_setWindowSize",
      value: function _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes["delete"](this);
      }
    }, {
      key: "hasEvenY",
      value: function hasEvenY() {
        return this.y % _2n === _0n;
      }
    }, {
      key: "toRawBytes",
      value: function toRawBytes() {
        var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return hexToBytes(this.toHex(isCompressed));
      }
    }, {
      key: "toHex",
      value: function toHex() {
        var isCompressed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var x = numTo32bStr(this.x);

        if (isCompressed) {
          var prefix = this.hasEvenY() ? '02' : '03';
          return "".concat(prefix).concat(x);
        } else {
          return "04".concat(x).concat(numTo32bStr(this.y));
        }
      }
    }, {
      key: "toHexX",
      value: function toHexX() {
        return this.toHex(true).slice(2);
      }
    }, {
      key: "toRawX",
      value: function toRawX() {
        return this.toRawBytes(true).slice(1);
      }
    }, {
      key: "assertValidity",
      value: function assertValidity() {
        var msg = 'Point is not on elliptic curve';
        var x = this.x,
            y = this.y;
        if (!isValidFieldElement(x) || !isValidFieldElement(y)) throw new Error(msg);
        var left = mod(y * y);
        var right = weierstrass(x);
        if (mod(left - right) !== _0n) throw new Error(msg);
      }
    }, {
      key: "equals",
      value: function equals(other) {
        return this.x === other.x && this.y === other.y;
      }
    }, {
      key: "negate",
      value: function negate() {
        return new Point(this.x, mod(-this.y));
      }
    }, {
      key: "double",
      value: function double() {
        return JacobianPoint.fromAffine(this)["double"]().toAffine();
      }
    }, {
      key: "add",
      value: function add(other) {
        return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
      }
    }, {
      key: "subtract",
      value: function subtract(other) {
        return this.add(other.negate());
      }
    }, {
      key: "multiply",
      value: function multiply(scalar) {
        return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
      }
    }, {
      key: "multiplyAndAddUnsafe",
      value: function multiplyAndAddUnsafe(Q, a, b) {
        var P = JacobianPoint.fromAffine(this);
        var aP = a === _0n || a === _1n || this !== Point.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
        var bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
        var sum = aP.add(bQ);
        return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
      }
    }], [{
      key: "fromCompressedHex",
      value: function fromCompressedHex(bytes) {
        var isShort = bytes.length === 32;
        var x = bytesToNumber(isShort ? bytes : bytes.subarray(1));
        if (!isValidFieldElement(x)) throw new Error('Point is not on curve');
        var y2 = weierstrass(x);
        var y = sqrtMod(y2);
        var isYOdd = (y & _1n) === _1n;

        if (isShort) {
          if (isYOdd) y = mod(-y);
        } else {
          var isFirstByteOdd = (bytes[0] & 1) === 1;
          if (isFirstByteOdd !== isYOdd) y = mod(-y);
        }

        var point = new Point(x, y);
        point.assertValidity();
        return point;
      }
    }, {
      key: "fromUncompressedHex",
      value: function fromUncompressedHex(bytes) {
        var x = bytesToNumber(bytes.subarray(1, fieldLen + 1));
        var y = bytesToNumber(bytes.subarray(fieldLen + 1, fieldLen * 2 + 1));
        var point = new Point(x, y);
        point.assertValidity();
        return point;
      }
    }, {
      key: "fromHex",
      value: function fromHex(hex) {
        var bytes = ensureBytes(hex);
        var len = bytes.length;
        var header = bytes[0];
        if (len === fieldLen) return this.fromCompressedHex(bytes);

        if (len === compressedLen && (header === 0x02 || header === 0x03)) {
          return this.fromCompressedHex(bytes);
        }

        if (len === uncompressedLen && header === 0x04) return this.fromUncompressedHex(bytes);
        throw new Error("Point.fromHex: received invalid point. Expected 32-".concat(compressedLen, " compressed bytes or ").concat(uncompressedLen, " uncompressed bytes, not ").concat(len));
      }
    }, {
      key: "fromPrivateKey",
      value: function fromPrivateKey(privateKey) {
        return Point.BASE.multiply(normalizePrivateKey(privateKey));
      }
    }, {
      key: "fromSignature",
      value: function fromSignature(msgHash, signature, recovery) {
        var _normalizeSignature = normalizeSignature(signature),
            r = _normalizeSignature.r,
            s = _normalizeSignature.s;

        if (![0, 1, 2, 3].includes(recovery)) throw new Error('Cannot recover: invalid recovery bit');
        var h = truncateHash(ensureBytes(msgHash));
        var n = CURVE.n;
        var radj = recovery === 2 || recovery === 3 ? r + n : r;
        var rinv = invert(radj, n);
        var u1 = mod(-h * rinv, n);
        var u2 = mod(s * rinv, n);
        var prefix = recovery & 1 ? '03' : '02';
        var R = Point.fromHex(prefix + numTo32bStr(radj));
        var Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
        if (!Q) throw new Error('Cannot recover signature: point at infinify');
        Q.assertValidity();
        return Q;
      }
    }]);

    return Point;
  }();
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
  Point.ZERO = new Point(_0n, _0n);

  function sliceDER(s) {
    return Number.parseInt(s[0], 16) >= 8 ? '00' + s : s;
  }

  function parseDERInt(data) {
    if (data.length < 2 || data[0] !== 0x02) {
      throw new Error("Invalid signature integer tag: ".concat(bytesToHex(data)));
    }

    var len = data[1];
    var res = data.subarray(2, len + 2);

    if (!len || res.length !== len) {
      throw new Error("Invalid signature integer: wrong length");
    }

    if (res[0] === 0x00 && res[1] <= 0x7f) {
      throw new Error('Invalid signature integer: trailing length');
    }

    return {
      data: bytesToNumber(res),
      left: data.subarray(len + 2)
    };
  }

  function parseDERSignature(data) {
    if (data.length < 2 || data[0] != 0x30) {
      throw new Error("Invalid signature tag: ".concat(bytesToHex(data)));
    }

    if (data[1] !== data.length - 2) {
      throw new Error('Invalid signature: incorrect length');
    }

    var _parseDERInt = parseDERInt(data.subarray(2)),
        r = _parseDERInt.data,
        sBytes = _parseDERInt.left;

    var _parseDERInt2 = parseDERInt(sBytes),
        s = _parseDERInt2.data,
        rBytesLeft = _parseDERInt2.left;

    if (rBytesLeft.length) {
      throw new Error("Invalid signature: left bytes after parsing: ".concat(bytesToHex(rBytesLeft)));
    }

    return {
      r: r,
      s: s
    };
  }

  var Signature = /*#__PURE__*/function () {
    function Signature(r, s) {
      _classCallCheck(this, Signature);

      this.r = r;
      this.s = s;
      this.assertValidity();
    }

    _createClass(Signature, [{
      key: "assertValidity",
      value: function assertValidity() {
        var r = this.r,
            s = this.s;
        if (!isWithinCurveOrder(r)) throw new Error('Invalid Signature: r must be 0 < r < n');
        if (!isWithinCurveOrder(s)) throw new Error('Invalid Signature: s must be 0 < s < n');
      }
    }, {
      key: "hasHighS",
      value: function hasHighS() {
        var HALF = CURVE.n >> _1n;
        return this.s > HALF;
      }
    }, {
      key: "normalizeS",
      value: function normalizeS() {
        return this.hasHighS() ? new Signature(this.r, mod(-this.s, CURVE.n)) : this;
      }
    }, {
      key: "toDERRawBytes",
      value: function toDERRawBytes() {
        return hexToBytes(this.toDERHex());
      }
    }, {
      key: "toDERHex",
      value: function toDERHex() {
        var sHex = sliceDER(numberToHexUnpadded(this.s));
        var rHex = sliceDER(numberToHexUnpadded(this.r));
        var sHexL = sHex.length / 2;
        var rHexL = rHex.length / 2;
        var sLen = numberToHexUnpadded(sHexL);
        var rLen = numberToHexUnpadded(rHexL);
        var length = numberToHexUnpadded(rHexL + sHexL + 4);
        return "30".concat(length, "02").concat(rLen).concat(rHex, "02").concat(sLen).concat(sHex);
      }
    }, {
      key: "toRawBytes",
      value: function toRawBytes() {
        return this.toDERRawBytes();
      }
    }, {
      key: "toHex",
      value: function toHex() {
        return this.toDERHex();
      }
    }, {
      key: "toCompactRawBytes",
      value: function toCompactRawBytes() {
        return hexToBytes(this.toCompactHex());
      }
    }, {
      key: "toCompactHex",
      value: function toCompactHex() {
        return numTo32bStr(this.r) + numTo32bStr(this.s);
      }
    }], [{
      key: "fromCompact",
      value: function fromCompact(hex) {
        var arr = hex instanceof Uint8Array;
        var name = 'Signature.fromCompact';
        if (typeof hex !== 'string' && !arr) throw new TypeError("".concat(name, ": Expected string or Uint8Array"));
        var str = arr ? bytesToHex(hex) : hex;
        if (str.length !== 128) throw new Error("".concat(name, ": Expected 64-byte hex"));
        return new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
      }
    }, {
      key: "fromDER",
      value: function fromDER(hex) {
        var arr = hex instanceof Uint8Array;
        if (typeof hex !== 'string' && !arr) throw new TypeError("Signature.fromDER: Expected string or Uint8Array");

        var _parseDERSignature = parseDERSignature(arr ? hex : hexToBytes(hex)),
            r = _parseDERSignature.r,
            s = _parseDERSignature.s;

        return new Signature(r, s);
      }
    }, {
      key: "fromHex",
      value: function fromHex(hex) {
        return this.fromDER(hex);
      }
    }]);

    return Signature;
  }();

  function concatBytes() {
    for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
      arrays[_key] = arguments[_key];
    }

    if (!arrays.every(function (b) {
      return b instanceof Uint8Array;
    })) throw new Error('Uint8Array list expected');
    if (arrays.length === 1) return arrays[0];
    var length = arrays.reduce(function (a, arr) {
      return a + arr.length;
    }, 0);
    var result = new Uint8Array(length);

    for (var i = 0, pad = 0; i < arrays.length; i++) {
      var arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }

    return result;
  }

  var hexes = Array.from({
    length: 256
  }, function (v, i) {
    return i.toString(16).padStart(2, '0');
  });

  function bytesToHex(uint8a) {
    if (!(uint8a instanceof Uint8Array)) throw new Error('Expected Uint8Array');
    var hex = '';

    for (var i = 0; i < uint8a.length; i++) {
      hex += hexes[uint8a[i]];
    }

    return hex;
  }

  var POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');

  function numTo32bStr(num) {
    if (typeof num !== 'bigint') throw new Error('Expected bigint');
    if (!(_0n <= num && num < POW_2_256)) throw new Error('Expected number 0 <= n < 2^256');
    return num.toString(16).padStart(64, '0');
  }

  function numTo32b(num) {
    var b = hexToBytes(numTo32bStr(num));
    if (b.length !== 32) throw new Error('Error: expected 32 bytes');
    return b;
  }

  function numberToHexUnpadded(num) {
    var hex = num.toString(16);
    return hex.length & 1 ? "0".concat(hex) : hex;
  }

  function hexToNumber(hex) {
    if (typeof hex !== 'string') {
      throw new TypeError('hexToNumber: expected string, got ' + _typeof$1(hex));
    }

    return BigInt("0x".concat(hex));
  }

  function hexToBytes(hex) {
    if (typeof hex !== 'string') {
      throw new TypeError('hexToBytes: expected string, got ' + _typeof$1(hex));
    }

    if (hex.length % 2) throw new Error('hexToBytes: received invalid unpadded hex' + hex.length);
    var array = new Uint8Array(hex.length / 2);

    for (var i = 0; i < array.length; i++) {
      var j = i * 2;
      var hexByte = hex.slice(j, j + 2);

      var _byte = Number.parseInt(hexByte, 16);

      if (Number.isNaN(_byte) || _byte < 0) throw new Error('Invalid byte sequence');
      array[i] = _byte;
    }

    return array;
  }

  function bytesToNumber(bytes) {
    return hexToNumber(bytesToHex(bytes));
  }

  function ensureBytes(hex) {
    return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes(hex);
  }

  function normalizeScalar(num) {
    if (typeof num === 'number' && Number.isSafeInteger(num) && num > 0) return BigInt(num);
    if (typeof num === 'bigint' && isWithinCurveOrder(num)) return num;
    throw new TypeError('Expected valid private scalar: 0 < scalar < curve.n');
  }

  function mod(a) {
    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;
    var result = a % b;
    return result >= _0n ? result : b + result;
  }

  function pow2(x, power) {
    var P = CURVE.P;
    var res = x;

    while (power-- > _0n) {
      res *= res;
      res %= P;
    }

    return res;
  }

  function sqrtMod(x) {
    var P = CURVE.P;

    var _6n = BigInt(6);

    var _11n = BigInt(11);

    var _22n = BigInt(22);

    var _23n = BigInt(23);

    var _44n = BigInt(44);

    var _88n = BigInt(88);

    var b2 = x * x * x % P;
    var b3 = b2 * b2 * x % P;
    var b6 = pow2(b3, _3n) * b3 % P;
    var b9 = pow2(b6, _3n) * b3 % P;
    var b11 = pow2(b9, _2n) * b2 % P;
    var b22 = pow2(b11, _11n) * b11 % P;
    var b44 = pow2(b22, _22n) * b22 % P;
    var b88 = pow2(b44, _44n) * b44 % P;
    var b176 = pow2(b88, _88n) * b88 % P;
    var b220 = pow2(b176, _44n) * b44 % P;
    var b223 = pow2(b220, _3n) * b3 % P;
    var t1 = pow2(b223, _23n) * b22 % P;
    var t2 = pow2(t1, _6n) * b2 % P;
    var rt = pow2(t2, _2n);
    var xc = rt * rt % P;
    if (xc !== x) throw new Error('Cannot find square root');
    return rt;
  }

  function invert(number) {
    var modulo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;

    if (number === _0n || modulo <= _0n) {
      throw new Error("invert: expected positive integers, got n=".concat(number, " mod=").concat(modulo));
    }

    var a = mod(number, modulo);
    var b = modulo;
    var x = _0n,
        u = _1n;

    while (a !== _0n) {
      var q = b / a;
      var r = b % a;
      var m = x - u * q;
      b = a, a = r, x = u, u = m;
    }

    var gcd = b;
    if (gcd !== _1n) throw new Error('invert: does not exist');
    return mod(x, modulo);
  }

  function invertBatch(nums) {
    var p = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CURVE.P;
    var scratch = new Array(nums.length);
    var lastMultiplied = nums.reduce(function (acc, num, i) {
      if (num === _0n) return acc;
      scratch[i] = acc;
      return mod(acc * num, p);
    }, _1n);
    var inverted = invert(lastMultiplied, p);
    nums.reduceRight(function (acc, num, i) {
      if (num === _0n) return acc;
      scratch[i] = mod(acc * scratch[i], p);
      return mod(acc * num, p);
    }, inverted);
    return scratch;
  }

  function bits2int_2(bytes) {
    var delta = bytes.length * 8 - groupLen * 8;
    var num = bytesToNumber(bytes);
    return delta > 0 ? num >> BigInt(delta) : num;
  }

  function truncateHash(hash) {
    var truncateOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var h = bits2int_2(hash);
    if (truncateOnly) return h;
    var n = CURVE.n;
    return h >= n ? h - n : h;
  }

  var _sha256Sync;

  var _hmacSha256Sync;

  var HmacDrbg = /*#__PURE__*/function () {
    function HmacDrbg(hashLen, qByteLen) {
      _classCallCheck(this, HmacDrbg);

      this.hashLen = hashLen;
      this.qByteLen = qByteLen;
      if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');
      if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');
      this.v = new Uint8Array(hashLen).fill(1);
      this.k = new Uint8Array(hashLen).fill(0);
      this.counter = 0;
    }

    _createClass(HmacDrbg, [{
      key: "hmac",
      value: function hmac() {
        for (var _len2 = arguments.length, values = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          values[_key2] = arguments[_key2];
        }

        return utils.hmacSha256.apply(utils, [this.k].concat(values));
      }
    }, {
      key: "hmacSync",
      value: function hmacSync() {
        for (var _len3 = arguments.length, values = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          values[_key3] = arguments[_key3];
        }

        return _hmacSha256Sync.apply(void 0, [this.k].concat(values));
      }
    }, {
      key: "checkSync",
      value: function checkSync() {
        if (typeof _hmacSha256Sync !== 'function') throw new ShaError('hmacSha256Sync needs to be set');
      }
    }, {
      key: "incr",
      value: function incr() {
        if (this.counter >= 1000) throw new Error('Tried 1,000 k values for sign(), all were invalid');
        this.counter += 1;
      }
    }, {
      key: "reseed",
      value: function () {
        var _reseed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
          var seed,
              _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                seed = _args.length > 0 && _args[0] !== undefined ? _args[0] : new Uint8Array();
                _context.next = 3;
                return this.hmac(this.v, Uint8Array.from([0x00]), seed);

              case 3:
                this.k = _context.sent;
                _context.next = 6;
                return this.hmac(this.v);

              case 6:
                this.v = _context.sent;

                if (!(seed.length === 0)) {
                  _context.next = 9;
                  break;
                }

                return _context.abrupt("return");

              case 9:
                _context.next = 11;
                return this.hmac(this.v, Uint8Array.from([0x01]), seed);

              case 11:
                this.k = _context.sent;
                _context.next = 14;
                return this.hmac(this.v);

              case 14:
                this.v = _context.sent;

              case 15:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));

        function reseed() {
          return _reseed.apply(this, arguments);
        }

        return reseed;
      }()
    }, {
      key: "reseedSync",
      value: function reseedSync() {
        var seed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Uint8Array();
        this.checkSync();
        this.k = this.hmacSync(this.v, Uint8Array.from([0x00]), seed);
        this.v = this.hmacSync(this.v);
        if (seed.length === 0) return;
        this.k = this.hmacSync(this.v, Uint8Array.from([0x01]), seed);
        this.v = this.hmacSync(this.v);
      }
    }, {
      key: "generate",
      value: function () {
        var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
          var len, out, sl;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                this.incr();
                len = 0;
                out = [];

              case 3:
                if (!(len < this.qByteLen)) {
                  _context2.next = 12;
                  break;
                }

                _context2.next = 6;
                return this.hmac(this.v);

              case 6:
                this.v = _context2.sent;
                sl = this.v.slice();
                out.push(sl);
                len += this.v.length;
                _context2.next = 3;
                break;

              case 12:
                return _context2.abrupt("return", concatBytes.apply(void 0, out));

              case 13:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));

        function generate() {
          return _generate.apply(this, arguments);
        }

        return generate;
      }()
    }, {
      key: "generateSync",
      value: function generateSync() {
        this.checkSync();
        this.incr();
        var len = 0;
        var out = [];

        while (len < this.qByteLen) {
          this.v = this.hmacSync(this.v);
          var sl = this.v.slice();
          out.push(sl);
          len += this.v.length;
        }

        return concatBytes.apply(void 0, out);
      }
    }]);

    return HmacDrbg;
  }();

  function isWithinCurveOrder(num) {
    return _0n < num && num < CURVE.n;
  }

  function isValidFieldElement(num) {
    return _0n < num && num < CURVE.P;
  }

  function kmdToSig(kBytes, m, d) {
    var lowS = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
    var n = CURVE.n;
    var k = truncateHash(kBytes, true);
    if (!isWithinCurveOrder(k)) return;
    var kinv = invert(k, n);
    var q = Point.BASE.multiply(k);
    var r = mod(q.x, n);
    if (r === _0n) return;
    var s = mod(kinv * mod(m + d * r, n), n);
    if (s === _0n) return;
    var sig = new Signature(r, s);
    var recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n);

    if (lowS && sig.hasHighS()) {
      sig = sig.normalizeS();
      recovery ^= 1;
    }

    return {
      sig: sig,
      recovery: recovery
    };
  }

  function normalizePrivateKey(key) {
    var num;

    if (typeof key === 'bigint') {
      num = key;
    } else if (typeof key === 'number' && Number.isSafeInteger(key) && key > 0) {
      num = BigInt(key);
    } else if (typeof key === 'string') {
      if (key.length !== 2 * groupLen) throw new Error('Expected 32 bytes of private key');
      num = hexToNumber(key);
    } else if (key instanceof Uint8Array) {
      if (key.length !== groupLen) throw new Error('Expected 32 bytes of private key');
      num = bytesToNumber(key);
    } else {
      throw new TypeError('Expected valid private key');
    }

    if (!isWithinCurveOrder(num)) throw new Error('Expected private key: 0 < key < n');
    return num;
  }

  function normalizeSignature(signature) {
    if (signature instanceof Signature) {
      signature.assertValidity();
      return signature;
    }

    try {
      return Signature.fromDER(signature);
    } catch (error) {
      return Signature.fromCompact(signature);
    }
  }

  function getPublicKey$1(privateKey) {
    var isCompressed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }

  function bits2int(bytes) {
    var slice = bytes.length > fieldLen ? bytes.slice(0, fieldLen) : bytes;
    return bytesToNumber(slice);
  }

  function bits2octets(bytes) {
    var z1 = bits2int(bytes);
    var z2 = mod(z1, CURVE.n);
    return int2octets(z2 < _0n ? z1 : z2);
  }

  function int2octets(num) {
    return numTo32b(num);
  }

  function initSigArgs(msgHash, privateKey, extraEntropy) {
    if (msgHash == null) throw new Error("sign: expected valid message hash, not \"".concat(msgHash, "\""));
    var h1 = ensureBytes(msgHash);
    var d = normalizePrivateKey(privateKey);
    var seedArgs = [int2octets(d), bits2octets(h1)];

    if (extraEntropy != null) {
      if (extraEntropy === true) extraEntropy = utils.randomBytes(fieldLen);
      var e = ensureBytes(extraEntropy);
      if (e.length !== fieldLen) throw new Error("sign: Expected ".concat(fieldLen, " bytes of extra data"));
      seedArgs.push(e);
    }

    var seed = concatBytes.apply(void 0, seedArgs);
    var m = bits2int(h1);
    return {
      seed: seed,
      m: m,
      d: d
    };
  }

  function finalizeSig(recSig, opts) {
    var sig = recSig.sig,
        recovery = recSig.recovery;

    var _Object$assign = Object.assign({
      canonical: true,
      der: true
    }, opts),
        der = _Object$assign.der,
        recovered = _Object$assign.recovered;

    var hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
    return recovered ? [hashed, recovery] : hashed;
  }

  function signSync(msgHash, privKey) {
    var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var _initSigArgs = initSigArgs(msgHash, privKey, opts.extraEntropy),
        seed = _initSigArgs.seed,
        m = _initSigArgs.m,
        d = _initSigArgs.d;

    var drbg = new HmacDrbg(hashLen, groupLen);
    drbg.reseedSync(seed);
    var sig;

    while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical))) drbg.reseedSync();

    return finalizeSig(sig, opts);
  }

  Point.BASE._setWindowSize(8);

  var crypto$1 = {
    node: nodeCrypto,
    web: (typeof self === "undefined" ? "undefined" : _typeof$1(self)) === 'object' && 'crypto' in self ? self.crypto : undefined
  };
  var TAGGED_HASH_PREFIXES = {};
  var utils = {
    bytesToHex: bytesToHex,
    hexToBytes: hexToBytes,
    concatBytes: concatBytes,
    mod: mod,
    invert: invert,
    isValidPrivateKey: function isValidPrivateKey(privateKey) {
      try {
        normalizePrivateKey(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    _bigintTo32Bytes: numTo32b,
    _normalizePrivateKey: normalizePrivateKey,
    hashToPrivateKey: function hashToPrivateKey(hash) {
      hash = ensureBytes(hash);
      var minLen = groupLen + 8;

      if (hash.length < minLen || hash.length > 1024) {
        throw new Error("Expected valid bytes of private key as per FIPS 186");
      }

      var num = mod(bytesToNumber(hash), CURVE.n - _1n) + _1n;

      return numTo32b(num);
    },
    randomBytes: function randomBytes() {
      var bytesLength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 32;

      if (crypto$1.web) {
        return crypto$1.web.getRandomValues(new Uint8Array(bytesLength));
      } else if (crypto$1.node) {
        var randomBytes = crypto$1.node.randomBytes;
        return Uint8Array.from(randomBytes(bytesLength));
      } else {
        throw new Error("The environment doesn't have randomBytes function");
      }
    },
    randomPrivateKey: function randomPrivateKey() {
      return utils.hashToPrivateKey(utils.randomBytes(groupLen + 8));
    },
    precompute: function precompute() {
      var windowSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;
      var point = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Point.BASE;
      var cached = point === Point.BASE ? point : new Point(point.x, point.y);

      cached._setWindowSize(windowSize);

      cached.multiply(_3n);
      return cached;
    },
    sha256: function () {
      var _sha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
        var _len4,
            messages,
            _key4,
            buffer,
            createHash,
            hash,
            _args4 = arguments;

        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              for (_len4 = _args4.length, messages = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
                messages[_key4] = _args4[_key4];
              }

              if (!crypto$1.web) {
                _context4.next = 8;
                break;
              }

              _context4.next = 4;
              return crypto$1.web.subtle.digest('SHA-256', concatBytes.apply(void 0, messages));

            case 4:
              buffer = _context4.sent;
              return _context4.abrupt("return", new Uint8Array(buffer));

            case 8:
              if (!crypto$1.node) {
                _context4.next = 15;
                break;
              }

              createHash = crypto$1.node.createHash;
              hash = createHash('sha256');
              messages.forEach(function (m) {
                return hash.update(m);
              });
              return _context4.abrupt("return", Uint8Array.from(hash.digest()));

            case 15:
              throw new Error("The environment doesn't have sha256 function");

            case 16:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));

      function sha256() {
        return _sha.apply(this, arguments);
      }

      return sha256;
    }(),
    hmacSha256: function () {
      var _hmacSha = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(key) {
        var _len5,
            messages,
            _key5,
            ckey,
            message,
            buffer,
            createHmac,
            hash,
            _args5 = arguments;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              for (_len5 = _args5.length, messages = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
                messages[_key5 - 1] = _args5[_key5];
              }

              if (!crypto$1.web) {
                _context5.next = 12;
                break;
              }

              _context5.next = 4;
              return crypto$1.web.subtle.importKey('raw', key, {
                name: 'HMAC',
                hash: {
                  name: 'SHA-256'
                }
              }, false, ['sign']);

            case 4:
              ckey = _context5.sent;
              message = concatBytes.apply(void 0, messages);
              _context5.next = 8;
              return crypto$1.web.subtle.sign('HMAC', ckey, message);

            case 8:
              buffer = _context5.sent;
              return _context5.abrupt("return", new Uint8Array(buffer));

            case 12:
              if (!crypto$1.node) {
                _context5.next = 19;
                break;
              }

              createHmac = crypto$1.node.createHmac;
              hash = createHmac('sha256', key);
              messages.forEach(function (m) {
                return hash.update(m);
              });
              return _context5.abrupt("return", Uint8Array.from(hash.digest()));

            case 19:
              throw new Error("The environment doesn't have hmac-sha256 function");

            case 20:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));

      function hmacSha256(_x9) {
        return _hmacSha.apply(this, arguments);
      }

      return hmacSha256;
    }(),
    sha256Sync: undefined,
    hmacSha256Sync: undefined,
    taggedHash: function () {
      var _taggedHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(tag) {
        var tagP,
            tagH,
            _len6,
            messages,
            _key6,
            _args6 = arguments;

        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              tagP = TAGGED_HASH_PREFIXES[tag];

              if (!(tagP === undefined)) {
                _context6.next = 7;
                break;
              }

              _context6.next = 4;
              return utils.sha256(Uint8Array.from(tag, function (c) {
                return c.charCodeAt(0);
              }));

            case 4:
              tagH = _context6.sent;
              tagP = concatBytes(tagH, tagH);
              TAGGED_HASH_PREFIXES[tag] = tagP;

            case 7:
              for (_len6 = _args6.length, messages = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
                messages[_key6 - 1] = _args6[_key6];
              }

              return _context6.abrupt("return", utils.sha256.apply(utils, [tagP].concat(messages)));

            case 9:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));

      function taggedHash(_x10) {
        return _taggedHash.apply(this, arguments);
      }

      return taggedHash;
    }(),
    taggedHashSync: function taggedHashSync(tag) {
      if (typeof _sha256Sync !== 'function') throw new ShaError('sha256Sync is undefined, you need to set it');
      var tagP = TAGGED_HASH_PREFIXES[tag];

      if (tagP === undefined) {
        var tagH = _sha256Sync(Uint8Array.from(tag, function (c) {
          return c.charCodeAt(0);
        }));

        tagP = concatBytes(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }

      for (var _len7 = arguments.length, messages = new Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
        messages[_key7 - 1] = arguments[_key7];
      }

      return _sha256Sync.apply(void 0, [tagP].concat(messages));
    },
    _JacobianPoint: JacobianPoint
  };
  Object.defineProperties(utils, {
    sha256Sync: {
      configurable: false,
      get: function get() {
        return _sha256Sync;
      },
      set: function set(val) {
        if (!_sha256Sync) _sha256Sync = val;
      }
    },
    hmacSha256Sync: {
      configurable: false,
      get: function get() {
        return _hmacSha256Sync;
      },
      set: function set(val) {
        if (!_hmacSha256Sync) _hmacSha256Sync = val;
      }
    }
  });

  var _excluded = ["commitment"],
      _excluded2 = ["encoding"],
      _excluded3 = ["commitment"],
      _excluded4 = ["commitment"];
  /**
   * A 64 byte secret key, the first 32 bytes of which is the
   * private scalar and the last 32 bytes is the public key.
   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
   */

  utils$1.sha512Sync = function () {
    var _ed25519$utils;

    return sha512((_ed25519$utils = utils$1).concatBytes.apply(_ed25519$utils, arguments));
  };

  var generatePrivateKey = utils$1.randomPrivateKey;

  var generateKeypair = function generateKeypair() {
    var privateScalar = utils$1.randomPrivateKey();
    var publicKey = getPublicKey(privateScalar);
    var secretKey = new Uint8Array(64);
    secretKey.set(privateScalar);
    secretKey.set(publicKey, 32);
    return {
      publicKey: publicKey,
      secretKey: secretKey
    };
  };

  var getPublicKey = sync.getPublicKey;

  function _isOnCurve(publicKey) {
    try {
      Point$1.fromHex(publicKey, true
      /* strict */
      );
      return true;
    } catch (_unused) {
      return false;
    }
  }

  var _sign = function sign(message, secretKey) {
    return sync.sign(message, secretKey.slice(0, 32));
  };

  var verify = sync.verify;

  var toBuffer = function toBuffer(arr) {
    if (Buffer$1.isBuffer(arr)) {
      return arr;
    } else if (arr instanceof Uint8Array) {
      return Buffer$1.from(arr.buffer, arr.byteOffset, arr.byteLength);
    } else {
      return Buffer$1.from(arr);
    }
  }; // Class wrapping a plain object


  var Struct = /*#__PURE__*/function () {
    function Struct(properties) {
      _classCallCheck(this, Struct);

      Object.assign(this, properties);
    }

    _createClass(Struct, [{
      key: "encode",
      value: function encode() {
        return Buffer$1.from(serialize_1(SOLANA_SCHEMA, this));
      }
    }], [{
      key: "decode",
      value: function decode(data) {
        return deserialize_1(SOLANA_SCHEMA, this, data);
      }
    }, {
      key: "decodeUnchecked",
      value: function decodeUnchecked(data) {
        return deserializeUnchecked_1(SOLANA_SCHEMA, this, data);
      }
    }]);

    return Struct;
  }(); // Class representing a Rust-compatible enum, since enums are only strings or
  // numbers in pure JS


  var Enum = /*#__PURE__*/function (_Struct) {
    _inherits(Enum, _Struct);

    var _super = _createSuper(Enum);

    function Enum(properties) {
      var _this;

      _classCallCheck(this, Enum);

      _this = _super.call(this, properties);
      _this["enum"] = '';

      if (Object.keys(properties).length !== 1) {
        throw new Error('Enum can only take single value');
      }

      Object.keys(properties).map(function (key) {
        _this["enum"] = key;
      });
      return _this;
    }

    return _createClass(Enum);
  }(Struct);

  var SOLANA_SCHEMA = new Map();

  var _Symbol$toStringTag;
  /**
   * Maximum length of derived pubkey seed
   */


  var MAX_SEED_LENGTH = 32;
  /**
   * Size of public key in bytes
   */

  var PUBLIC_KEY_LENGTH = 32;
  /**
   * Value to be converted into public key
   */

  function isPublicKeyData(value) {
    return value._bn !== undefined;
  } // local counter used by PublicKey.unique()


  var uniquePublicKeyCounter = 1;
  /**
   * A public key
   */

  _Symbol$toStringTag = Symbol.toStringTag;

  var PublicKey = /*#__PURE__*/function (_Struct2, _Symbol$toStringTag2) {
    _inherits(PublicKey, _Struct2);

    var _super2 = _createSuper(PublicKey);

    /** @internal */

    /**
     * Create a new PublicKey object
     * @param value ed25519 public key as buffer or base-58 encoded string
     */
    function PublicKey(value) {
      var _this2;

      _classCallCheck(this, PublicKey);

      _this2 = _super2.call(this, {});
      _this2._bn = void 0;

      if (isPublicKeyData(value)) {
        _this2._bn = value._bn;
      } else {
        if (typeof value === 'string') {
          // assume base 58 encoding by default
          var decoded = bs58$1.decode(value);

          if (decoded.length != PUBLIC_KEY_LENGTH) {
            throw new Error("Invalid public key input");
          }

          _this2._bn = new BN$1(decoded);
        } else {
          _this2._bn = new BN$1(value);
        }

        if (_this2._bn.byteLength() > PUBLIC_KEY_LENGTH) {
          throw new Error("Invalid public key input");
        }
      }

      return _this2;
    }
    /**
     * Returns a unique PublicKey for tests and benchmarks using a counter
     */


    _createClass(PublicKey, [{
      key: "equals",
      value:
      /**
       * Default public key value. The base58-encoded string representation is all ones (as seen below)
       * The underlying BN number is 32 bytes that are all zeros
       */

      /**
       * Checks if two publicKeys are equal
       */
      function equals(publicKey) {
        return this._bn.eq(publicKey._bn);
      }
      /**
       * Return the base-58 representation of the public key
       */

    }, {
      key: "toBase58",
      value: function toBase58() {
        return bs58$1.encode(this.toBytes());
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.toBase58();
      }
      /**
       * Return the byte array representation of the public key in big endian
       */

    }, {
      key: "toBytes",
      value: function toBytes() {
        var buf = this.toBuffer();
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      /**
       * Return the Buffer representation of the public key in big endian
       */

    }, {
      key: "toBuffer",
      value: function toBuffer() {
        var b = this._bn.toArrayLike(Buffer$1);

        if (b.length === PUBLIC_KEY_LENGTH) {
          return b;
        }

        var zeroPad = Buffer$1.alloc(32);
        b.copy(zeroPad, 32 - b.length);
        return zeroPad;
      }
    }, {
      key: _Symbol$toStringTag2,
      get: function get() {
        return "PublicKey(".concat(this.toString(), ")");
      }
      /**
       * Return the base-58 representation of the public key
       */

    }, {
      key: "toString",
      value: function toString() {
        return this.toBase58();
      }
      /**
       * Derive a public key from another key, a seed, and a program ID.
       * The program ID will also serve as the owner of the public key, giving
       * it permission to write data to the account.
       */

      /* eslint-disable require-await */

    }], [{
      key: "unique",
      value: function unique() {
        var key = new PublicKey(uniquePublicKeyCounter);
        uniquePublicKeyCounter += 1;
        return new PublicKey(key.toBuffer());
      }
    }, {
      key: "createWithSeed",
      value: function () {
        var _createWithSeed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(fromPublicKey, seed, programId) {
          var buffer, publicKeyBytes;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                buffer = Buffer$1.concat([fromPublicKey.toBuffer(), Buffer$1.from(seed), programId.toBuffer()]);
                publicKeyBytes = sha256(buffer);
                return _context.abrupt("return", new PublicKey(publicKeyBytes));

              case 3:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));

        function createWithSeed(_x, _x2, _x3) {
          return _createWithSeed.apply(this, arguments);
        }

        return createWithSeed;
      }()
      /**
       * Derive a program address from seeds and a program ID.
       */

      /* eslint-disable require-await */

    }, {
      key: "createProgramAddressSync",
      value: function createProgramAddressSync(seeds, programId) {
        var buffer = Buffer$1.alloc(0);
        seeds.forEach(function (seed) {
          if (seed.length > MAX_SEED_LENGTH) {
            throw new TypeError("Max seed length exceeded");
          }

          buffer = Buffer$1.concat([buffer, toBuffer(seed)]);
        });
        buffer = Buffer$1.concat([buffer, programId.toBuffer(), Buffer$1.from('ProgramDerivedAddress')]);
        var publicKeyBytes = sha256(buffer);

        if (_isOnCurve(publicKeyBytes)) {
          throw new Error("Invalid seeds, address must fall off the curve");
        }

        return new PublicKey(publicKeyBytes);
      }
      /**
       * Async version of createProgramAddressSync
       * For backwards compatibility
       *
       * @deprecated Use {@link createProgramAddressSync} instead
       */

      /* eslint-disable require-await */

    }, {
      key: "createProgramAddress",
      value: function () {
        var _createProgramAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(seeds, programId) {
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.createProgramAddressSync(seeds, programId));

              case 1:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));

        function createProgramAddress(_x4, _x5) {
          return _createProgramAddress.apply(this, arguments);
        }

        return createProgramAddress;
      }()
      /**
       * Find a valid program address
       *
       * Valid program addresses must fall off the ed25519 curve.  This function
       * iterates a nonce until it finds one that when combined with the seeds
       * results in a valid program address.
       */

    }, {
      key: "findProgramAddressSync",
      value: function findProgramAddressSync(seeds, programId) {
        var nonce = 255;
        var address;

        while (nonce != 0) {
          try {
            var seedsWithNonce = seeds.concat(Buffer$1.from([nonce]));
            address = this.createProgramAddressSync(seedsWithNonce, programId);
          } catch (err) {
            if (err instanceof TypeError) {
              throw err;
            }

            nonce--;
            continue;
          }

          return [address, nonce];
        }

        throw new Error("Unable to find a viable program address nonce");
      }
      /**
       * Async version of findProgramAddressSync
       * For backwards compatibility
       *
       * @deprecated Use {@link findProgramAddressSync} instead
       */

    }, {
      key: "findProgramAddress",
      value: function () {
        var _findProgramAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(seeds, programId) {
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                return _context3.abrupt("return", this.findProgramAddressSync(seeds, programId));

              case 1:
              case "end":
                return _context3.stop();
            }
          }, _callee3, this);
        }));

        function findProgramAddress(_x6, _x7) {
          return _findProgramAddress.apply(this, arguments);
        }

        return findProgramAddress;
      }()
      /**
       * Check that a pubkey is on the ed25519 curve.
       */

    }, {
      key: "isOnCurve",
      value: function isOnCurve(pubkeyData) {
        var pubkey = new PublicKey(pubkeyData);
        return _isOnCurve(pubkey.toBytes());
      }
    }]);

    return PublicKey;
  }(Struct, _Symbol$toStringTag);

  PublicKey["default"] = new PublicKey('11111111111111111111111111111111');
  SOLANA_SCHEMA.set(PublicKey, {
    kind: 'struct',
    fields: [['_bn', 'u256']]
  });
  /**
   * An account key pair (public and secret keys).
   *
   * @deprecated since v1.10.0, please use {@link Keypair} instead.
   */

  var Account = /*#__PURE__*/function () {
    /** @internal */

    /** @internal */

    /**
     * Create a new Account object
     *
     * If the secretKey parameter is not provided a new key pair is randomly
     * created for the account
     *
     * @param secretKey Secret key for the account
     */
    function Account(secretKey) {
      _classCallCheck(this, Account);

      this._publicKey = void 0;
      this._secretKey = void 0;

      if (secretKey) {
        var secretKeyBuffer = toBuffer(secretKey);

        if (secretKey.length !== 64) {
          throw new Error('bad secret key size');
        }

        this._publicKey = secretKeyBuffer.slice(32, 64);
        this._secretKey = secretKeyBuffer.slice(0, 32);
      } else {
        this._secretKey = toBuffer(generatePrivateKey());
        this._publicKey = toBuffer(getPublicKey(this._secretKey));
      }
    }
    /**
     * The public key for this account
     */


    _createClass(Account, [{
      key: "publicKey",
      get: function get() {
        return new PublicKey(this._publicKey);
      }
      /**
       * The **unencrypted** secret key for this account. The first 32 bytes
       * is the private scalar and the last 32 bytes is the public key.
       * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/
       */

    }, {
      key: "secretKey",
      get: function get() {
        return Buffer$1.concat([this._secretKey, this._publicKey], 64);
      }
    }]);

    return Account;
  }();

  var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');
  /**
   * Maximum over-the-wire size of a Transaction
   *
   * 1280 is IPv6 minimum MTU
   * 40 bytes is the size of the IPv6 header
   * 8 bytes is the size of the fragment header
   */

  var PACKET_DATA_SIZE = 1280 - 40 - 8;
  var VERSION_PREFIX_MASK = 0x7f;
  var SIGNATURE_LENGTH_IN_BYTES = 64;

  var TransactionExpiredBlockheightExceededError = /*#__PURE__*/function (_Error) {
    _inherits(TransactionExpiredBlockheightExceededError, _Error);

    var _super3 = _createSuper(TransactionExpiredBlockheightExceededError);

    function TransactionExpiredBlockheightExceededError(signature) {
      var _this3;

      _classCallCheck(this, TransactionExpiredBlockheightExceededError);

      _this3 = _super3.call(this, "Signature ".concat(signature, " has expired: block height exceeded."));
      _this3.signature = void 0;
      _this3.signature = signature;
      return _this3;
    }

    return _createClass(TransactionExpiredBlockheightExceededError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {
    value: 'TransactionExpiredBlockheightExceededError'
  });

  var TransactionExpiredTimeoutError = /*#__PURE__*/function (_Error2) {
    _inherits(TransactionExpiredTimeoutError, _Error2);

    var _super4 = _createSuper(TransactionExpiredTimeoutError);

    function TransactionExpiredTimeoutError(signature, timeoutSeconds) {
      var _this4;

      _classCallCheck(this, TransactionExpiredTimeoutError);

      _this4 = _super4.call(this, "Transaction was not confirmed in ".concat(timeoutSeconds.toFixed(2), " seconds. It is ") + 'unknown if it succeeded or failed. Check signature ' + "".concat(signature, " using the Solana Explorer or CLI tools."));
      _this4.signature = void 0;
      _this4.signature = signature;
      return _this4;
    }

    return _createClass(TransactionExpiredTimeoutError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  Object.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {
    value: 'TransactionExpiredTimeoutError'
  });

  var TransactionExpiredNonceInvalidError = /*#__PURE__*/function (_Error3) {
    _inherits(TransactionExpiredNonceInvalidError, _Error3);

    var _super5 = _createSuper(TransactionExpiredNonceInvalidError);

    function TransactionExpiredNonceInvalidError(signature) {
      var _this5;

      _classCallCheck(this, TransactionExpiredNonceInvalidError);

      _this5 = _super5.call(this, "Signature ".concat(signature, " has expired: the nonce is no longer valid."));
      _this5.signature = void 0;
      _this5.signature = signature;
      return _this5;
    }

    return _createClass(TransactionExpiredNonceInvalidError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {
    value: 'TransactionExpiredNonceInvalidError'
  });

  var MessageAccountKeys = /*#__PURE__*/function () {
    function MessageAccountKeys(staticAccountKeys, accountKeysFromLookups) {
      _classCallCheck(this, MessageAccountKeys);

      this.staticAccountKeys = void 0;
      this.accountKeysFromLookups = void 0;
      this.staticAccountKeys = staticAccountKeys;
      this.accountKeysFromLookups = accountKeysFromLookups;
    }

    _createClass(MessageAccountKeys, [{
      key: "keySegments",
      value: function keySegments() {
        var keySegments = [this.staticAccountKeys];

        if (this.accountKeysFromLookups) {
          keySegments.push(this.accountKeysFromLookups.writable);
          keySegments.push(this.accountKeysFromLookups.readonly);
        }

        return keySegments;
      }
    }, {
      key: "get",
      value: function get(index) {
        var _iterator = _createForOfIteratorHelper(this.keySegments()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var keySegment = _step.value;

            if (index < keySegment.length) {
              return keySegment[index];
            } else {
              index -= keySegment.length;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        return;
      }
    }, {
      key: "length",
      get: function get() {
        return this.keySegments().flat().length;
      }
    }, {
      key: "compileInstructions",
      value: function compileInstructions(instructions) {
        // Bail early if any account indexes would overflow a u8
        var U8_MAX = 255;

        if (this.length > U8_MAX + 1) {
          throw new Error('Account index overflow encountered during compilation');
        }

        var keyIndexMap = new Map();
        this.keySegments().flat().forEach(function (key, index) {
          keyIndexMap.set(key.toBase58(), index);
        });

        var findKeyIndex = function findKeyIndex(key) {
          var keyIndex = keyIndexMap.get(key.toBase58());
          if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');
          return keyIndex;
        };

        return instructions.map(function (instruction) {
          return {
            programIdIndex: findKeyIndex(instruction.programId),
            accountKeyIndexes: instruction.keys.map(function (meta) {
              return findKeyIndex(meta.pubkey);
            }),
            data: instruction.data
          };
        });
      }
    }]);

    return MessageAccountKeys;
  }();
  /**
   * Layout for a public key
   */


  var publicKey = function publicKey() {
    var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';
    return blob$1(32, property);
  };
  /**
   * Layout for a signature
   */


  var signature = function signature() {
    var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'signature';
    return blob$1(64, property);
  };
  /**
   * Layout for a Rust String type
   */


  var rustString = function rustString() {
    var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'string';
    var rsl = struct([u32('length'), u32('lengthPadding'), blob$1(offset(u32(), -8), 'chars')], property);

    var _decode = rsl.decode.bind(rsl);

    var _encode = rsl.encode.bind(rsl);

    var rslShim = rsl;

    rslShim.decode = function (b, offset) {
      var data = _decode(b, offset);

      return data['chars'].toString();
    };

    rslShim.encode = function (str, b, offset) {
      var data = {
        chars: Buffer$1.from(str, 'utf8')
      };
      return _encode(data, b, offset);
    };

    rslShim.alloc = function (str) {
      return u32().span + u32().span + Buffer$1.from(str, 'utf8').length;
    };

    return rslShim;
  };
  /**
   * Layout for an Authorized object
   */


  var authorized = function authorized() {
    var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'authorized';
    return struct([publicKey('staker'), publicKey('withdrawer')], property);
  };
  /**
   * Layout for a Lockup object
   */


  var lockup = function lockup() {
    var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'lockup';
    return struct([ns64('unixTimestamp'), ns64('epoch'), publicKey('custodian')], property);
  };
  /**
   *  Layout for a VoteInit object
   */


  var voteInit = function voteInit() {
    var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteInit';
    return struct([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), u8('commission')], property);
  };
  /**
   *  Layout for a VoteAuthorizeWithSeedArgs object
   */


  var voteAuthorizeWithSeedArgs = function voteAuthorizeWithSeedArgs() {
    var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteAuthorizeWithSeedArgs';
    return struct([u32('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);
  };

  function getAlloc(type, fields) {
    var getItemAlloc = function getItemAlloc(item) {
      if (item.span >= 0) {
        return item.span;
      } else if (typeof item.alloc === 'function') {
        return item.alloc(fields[item.property]);
      } else if ('count' in item && 'elementLayout' in item) {
        var field = fields[item.property];

        if (Array.isArray(field)) {
          return field.length * getItemAlloc(item.elementLayout);
        }
      } else if ('fields' in item) {
        // This is a `Structure` whose size needs to be recursively measured.
        return getAlloc({
          layout: item
        }, fields[item.property]);
      } // Couldn't determine allocated size of layout


      return 0;
    };

    var alloc = 0;
    type.layout.fields.forEach(function (item) {
      alloc += getItemAlloc(item);
    });
    return alloc;
  }

  function decodeLength(bytes) {
    var len = 0;
    var size = 0;

    for (;;) {
      var elem = bytes.shift();
      len |= (elem & 0x7f) << size * 7;
      size += 1;

      if ((elem & 0x80) === 0) {
        break;
      }
    }

    return len;
  }

  function encodeLength(bytes, len) {
    var rem_len = len;

    for (;;) {
      var elem = rem_len & 0x7f;
      rem_len >>= 7;

      if (rem_len == 0) {
        bytes.push(elem);
        break;
      } else {
        elem |= 0x80;
        bytes.push(elem);
      }
    }
  }

  function assert(condition, message) {
    if (!condition) {
      throw new Error(message || 'Assertion failed');
    }
  }

  var CompiledKeys = /*#__PURE__*/function () {
    function CompiledKeys(payer, keyMetaMap) {
      _classCallCheck(this, CompiledKeys);

      this.payer = void 0;
      this.keyMetaMap = void 0;
      this.payer = payer;
      this.keyMetaMap = keyMetaMap;
    }

    _createClass(CompiledKeys, [{
      key: "getMessageComponents",
      value: function getMessageComponents() {
        var mapEntries = _toConsumableArray(this.keyMetaMap.entries());

        assert(mapEntries.length <= 256, 'Max static account keys length exceeded');
        var writableSigners = mapEntries.filter(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
              meta = _ref2[1];

          return meta.isSigner && meta.isWritable;
        });
        var readonlySigners = mapEntries.filter(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
              meta = _ref4[1];

          return meta.isSigner && !meta.isWritable;
        });
        var writableNonSigners = mapEntries.filter(function (_ref5) {
          var _ref6 = _slicedToArray(_ref5, 2),
              meta = _ref6[1];

          return !meta.isSigner && meta.isWritable;
        });
        var readonlyNonSigners = mapEntries.filter(function (_ref7) {
          var _ref8 = _slicedToArray(_ref7, 2),
              meta = _ref8[1];

          return !meta.isSigner && !meta.isWritable;
        });
        var header = {
          numRequiredSignatures: writableSigners.length + readonlySigners.length,
          numReadonlySignedAccounts: readonlySigners.length,
          numReadonlyUnsignedAccounts: readonlyNonSigners.length
        }; // sanity checks

        {
          assert(writableSigners.length > 0, 'Expected at least one writable signer key');

          var _writableSigners$2 = _slicedToArray(writableSigners[0], 1),
              payerAddress = _writableSigners$2[0];

          assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');
        }
        var staticAccountKeys = [].concat(_toConsumableArray(writableSigners.map(function (_ref9) {
          var _ref10 = _slicedToArray(_ref9, 1),
              address = _ref10[0];

          return new PublicKey(address);
        })), _toConsumableArray(readonlySigners.map(function (_ref11) {
          var _ref12 = _slicedToArray(_ref11, 1),
              address = _ref12[0];

          return new PublicKey(address);
        })), _toConsumableArray(writableNonSigners.map(function (_ref13) {
          var _ref14 = _slicedToArray(_ref13, 1),
              address = _ref14[0];

          return new PublicKey(address);
        })), _toConsumableArray(readonlyNonSigners.map(function (_ref15) {
          var _ref16 = _slicedToArray(_ref15, 1),
              address = _ref16[0];

          return new PublicKey(address);
        })));
        return [header, staticAccountKeys];
      }
    }, {
      key: "extractTableLookup",
      value: function extractTableLookup(lookupTable) {
        var _this$drainKeysFoundI = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, function (keyMeta) {
          return !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable;
        }),
            _this$drainKeysFoundI2 = _slicedToArray(_this$drainKeysFoundI, 2),
            writableIndexes = _this$drainKeysFoundI2[0],
            drainedWritableKeys = _this$drainKeysFoundI2[1];

        var _this$drainKeysFoundI3 = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, function (keyMeta) {
          return !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable;
        }),
            _this$drainKeysFoundI4 = _slicedToArray(_this$drainKeysFoundI3, 2),
            readonlyIndexes = _this$drainKeysFoundI4[0],
            drainedReadonlyKeys = _this$drainKeysFoundI4[1]; // Don't extract lookup if no keys were found


        if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {
          return;
        }

        return [{
          accountKey: lookupTable.key,
          writableIndexes: writableIndexes,
          readonlyIndexes: readonlyIndexes
        }, {
          writable: drainedWritableKeys,
          readonly: drainedReadonlyKeys
        }];
      }
      /** @internal */

    }, {
      key: "drainKeysFoundInLookupTable",
      value: function drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {
        var _this6 = this;

        var lookupTableIndexes = new Array();
        var drainedKeys = new Array();

        var _iterator2 = _createForOfIteratorHelper(this.keyMetaMap.entries()),
            _step2;

        try {
          var _loop = function _loop() {
            var _step2$value = _slicedToArray(_step2.value, 2),
                address = _step2$value[0],
                keyMeta = _step2$value[1];

            if (keyMetaFilter(keyMeta)) {
              var key = new PublicKey(address);
              var lookupTableIndex = lookupTableEntries.findIndex(function (entry) {
                return entry.equals(key);
              });

              if (lookupTableIndex >= 0) {
                assert(lookupTableIndex < 256, 'Max lookup table index exceeded');
                lookupTableIndexes.push(lookupTableIndex);
                drainedKeys.push(key);

                _this6.keyMetaMap["delete"](address);
              }
            }
          };

          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return [lookupTableIndexes, drainedKeys];
      }
    }], [{
      key: "compile",
      value: function compile(instructions, payer) {
        var keyMetaMap = new Map();

        var getOrInsertDefault = function getOrInsertDefault(pubkey) {
          var address = pubkey.toBase58();
          var keyMeta = keyMetaMap.get(address);

          if (keyMeta === undefined) {
            keyMeta = {
              isSigner: false,
              isWritable: false,
              isInvoked: false
            };
            keyMetaMap.set(address, keyMeta);
          }

          return keyMeta;
        };

        var payerKeyMeta = getOrInsertDefault(payer);
        payerKeyMeta.isSigner = true;
        payerKeyMeta.isWritable = true;

        var _iterator3 = _createForOfIteratorHelper(instructions),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var ix = _step3.value;
            getOrInsertDefault(ix.programId).isInvoked = true;

            var _iterator4 = _createForOfIteratorHelper(ix.keys),
                _step4;

            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var accountMeta = _step4.value;
                var keyMeta = getOrInsertDefault(accountMeta.pubkey);
                keyMeta.isSigner || (keyMeta.isSigner = accountMeta.isSigner);
                keyMeta.isWritable || (keyMeta.isWritable = accountMeta.isWritable);
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return new CompiledKeys(payer, keyMetaMap);
      }
    }]);

    return CompiledKeys;
  }();
  /**
   * An instruction to execute by a program
   *
   * @property {number} programIdIndex
   * @property {number[]} accounts
   * @property {string} data
   */

  /**
   * List of instructions to be processed atomically
   */


  var Message = /*#__PURE__*/function () {
    function Message(args) {
      var _this7 = this;

      _classCallCheck(this, Message);

      this.header = void 0;
      this.accountKeys = void 0;
      this.recentBlockhash = void 0;
      this.instructions = void 0;
      this.indexToProgramIds = new Map();
      this.header = args.header;
      this.accountKeys = args.accountKeys.map(function (account) {
        return new PublicKey(account);
      });
      this.recentBlockhash = args.recentBlockhash;
      this.instructions = args.instructions;
      this.instructions.forEach(function (ix) {
        return _this7.indexToProgramIds.set(ix.programIdIndex, _this7.accountKeys[ix.programIdIndex]);
      });
    }

    _createClass(Message, [{
      key: "version",
      get: function get() {
        return 'legacy';
      }
    }, {
      key: "staticAccountKeys",
      get: function get() {
        return this.accountKeys;
      }
    }, {
      key: "compiledInstructions",
      get: function get() {
        return this.instructions.map(function (ix) {
          return {
            programIdIndex: ix.programIdIndex,
            accountKeyIndexes: ix.accounts,
            data: bs58$1.decode(ix.data)
          };
        });
      }
    }, {
      key: "addressTableLookups",
      get: function get() {
        return [];
      }
    }, {
      key: "getAccountKeys",
      value: function getAccountKeys() {
        return new MessageAccountKeys(this.staticAccountKeys);
      }
    }, {
      key: "isAccountSigner",
      value: function isAccountSigner(index) {
        return index < this.header.numRequiredSignatures;
      }
    }, {
      key: "isAccountWritable",
      value: function isAccountWritable(index) {
        var numSignedAccounts = this.header.numRequiredSignatures;

        if (index >= this.header.numRequiredSignatures) {
          var unsignedAccountIndex = index - numSignedAccounts;
          var numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;
          var numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
          return unsignedAccountIndex < numWritableUnsignedAccounts;
        } else {
          var numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
          return index < numWritableSignedAccounts;
        }
      }
    }, {
      key: "isProgramId",
      value: function isProgramId(index) {
        return this.indexToProgramIds.has(index);
      }
    }, {
      key: "programIds",
      value: function programIds() {
        return _toConsumableArray(this.indexToProgramIds.values());
      }
    }, {
      key: "nonProgramIds",
      value: function nonProgramIds() {
        var _this8 = this;

        return this.accountKeys.filter(function (_, index) {
          return !_this8.isProgramId(index);
        });
      }
    }, {
      key: "serialize",
      value: function serialize() {
        var numKeys = this.accountKeys.length;
        var keyCount = [];
        encodeLength(keyCount, numKeys);
        var instructions = this.instructions.map(function (instruction) {
          var accounts = instruction.accounts,
              programIdIndex = instruction.programIdIndex;
          var data = Array.from(bs58$1.decode(instruction.data));
          var keyIndicesCount = [];
          encodeLength(keyIndicesCount, accounts.length);
          var dataCount = [];
          encodeLength(dataCount, data.length);
          return {
            programIdIndex: programIdIndex,
            keyIndicesCount: Buffer$1.from(keyIndicesCount),
            keyIndices: accounts,
            dataLength: Buffer$1.from(dataCount),
            data: data
          };
        });
        var instructionCount = [];
        encodeLength(instructionCount, instructions.length);
        var instructionBuffer = Buffer$1.alloc(PACKET_DATA_SIZE);
        Buffer$1.from(instructionCount).copy(instructionBuffer);
        var instructionBufferLength = instructionCount.length;
        instructions.forEach(function (instruction) {
          var instructionLayout = struct([u8('programIdIndex'), blob$1(instruction.keyIndicesCount.length, 'keyIndicesCount'), seq$1(u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), blob$1(instruction.dataLength.length, 'dataLength'), seq$1(u8('userdatum'), instruction.data.length, 'data')]);
          var length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);
          instructionBufferLength += length;
        });
        instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);
        var signDataLayout = struct([blob$1(1, 'numRequiredSignatures'), blob$1(1, 'numReadonlySignedAccounts'), blob$1(1, 'numReadonlyUnsignedAccounts'), blob$1(keyCount.length, 'keyCount'), seq$1(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);
        var transaction = {
          numRequiredSignatures: Buffer$1.from([this.header.numRequiredSignatures]),
          numReadonlySignedAccounts: Buffer$1.from([this.header.numReadonlySignedAccounts]),
          numReadonlyUnsignedAccounts: Buffer$1.from([this.header.numReadonlyUnsignedAccounts]),
          keyCount: Buffer$1.from(keyCount),
          keys: this.accountKeys.map(function (key) {
            return toBuffer(key.toBytes());
          }),
          recentBlockhash: bs58$1.decode(this.recentBlockhash)
        };
        var signData = Buffer$1.alloc(2048);
        var length = signDataLayout.encode(transaction, signData);
        instructionBuffer.copy(signData, length);
        return signData.slice(0, length + instructionBuffer.length);
      }
      /**
       * Decode a compiled message into a Message object.
       */

    }], [{
      key: "compile",
      value: function compile(args) {
        var compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);

        var _compiledKeys$getMess = compiledKeys.getMessageComponents(),
            _compiledKeys$getMess2 = _slicedToArray(_compiledKeys$getMess, 2),
            header = _compiledKeys$getMess2[0],
            staticAccountKeys = _compiledKeys$getMess2[1];

        var accountKeys = new MessageAccountKeys(staticAccountKeys);
        var instructions = accountKeys.compileInstructions(args.instructions).map(function (ix) {
          return {
            programIdIndex: ix.programIdIndex,
            accounts: ix.accountKeyIndexes,
            data: bs58$1.encode(ix.data)
          };
        });
        return new Message({
          header: header,
          accountKeys: staticAccountKeys,
          recentBlockhash: args.recentBlockhash,
          instructions: instructions
        });
      }
    }, {
      key: "from",
      value: function from(buffer) {
        // Slice up wire data
        var byteArray = _toConsumableArray(buffer);

        var numRequiredSignatures = byteArray.shift();

        if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {
          throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');
        }

        var numReadonlySignedAccounts = byteArray.shift();
        var numReadonlyUnsignedAccounts = byteArray.shift();
        var accountCount = decodeLength(byteArray);
        var accountKeys = [];

        for (var i = 0; i < accountCount; i++) {
          var account = byteArray.slice(0, PUBLIC_KEY_LENGTH);
          byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
          accountKeys.push(new PublicKey(Buffer$1.from(account)));
        }

        var recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);
        byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
        var instructionCount = decodeLength(byteArray);
        var instructions = [];

        for (var _i2 = 0; _i2 < instructionCount; _i2++) {
          var programIdIndex = byteArray.shift();

          var _accountCount = decodeLength(byteArray);

          var accounts = byteArray.slice(0, _accountCount);
          byteArray = byteArray.slice(_accountCount);
          var dataLength = decodeLength(byteArray);
          var dataSlice = byteArray.slice(0, dataLength);
          var data = bs58$1.encode(Buffer$1.from(dataSlice));
          byteArray = byteArray.slice(dataLength);
          instructions.push({
            programIdIndex: programIdIndex,
            accounts: accounts,
            data: data
          });
        }

        var messageArgs = {
          header: {
            numRequiredSignatures: numRequiredSignatures,
            numReadonlySignedAccounts: numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts
          },
          recentBlockhash: bs58$1.encode(Buffer$1.from(recentBlockhash)),
          accountKeys: accountKeys,
          instructions: instructions
        };
        return new Message(messageArgs);
      }
    }]);

    return Message;
  }();
  /**
   * Message constructor arguments
   */


  var MessageV0 = /*#__PURE__*/function () {
    function MessageV0(args) {
      _classCallCheck(this, MessageV0);

      this.header = void 0;
      this.staticAccountKeys = void 0;
      this.recentBlockhash = void 0;
      this.compiledInstructions = void 0;
      this.addressTableLookups = void 0;
      this.header = args.header;
      this.staticAccountKeys = args.staticAccountKeys;
      this.recentBlockhash = args.recentBlockhash;
      this.compiledInstructions = args.compiledInstructions;
      this.addressTableLookups = args.addressTableLookups;
    }

    _createClass(MessageV0, [{
      key: "version",
      get: function get() {
        return 0;
      }
    }, {
      key: "numAccountKeysFromLookups",
      get: function get() {
        var count = 0;

        var _iterator5 = _createForOfIteratorHelper(this.addressTableLookups),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var lookup = _step5.value;
            count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        return count;
      }
    }, {
      key: "getAccountKeys",
      value: function getAccountKeys(args) {
        var accountKeysFromLookups;

        if (args && 'accountKeysFromLookups' in args && args.accountKeysFromLookups) {
          if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {
            throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');
          }

          accountKeysFromLookups = args.accountKeysFromLookups;
        } else if (args && 'addressLookupTableAccounts' in args && args.addressLookupTableAccounts) {
          accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);
        } else if (this.addressTableLookups.length > 0) {
          throw new Error('Failed to get account keys because address table lookups were not resolved');
        }

        return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);
      }
    }, {
      key: "isAccountSigner",
      value: function isAccountSigner(index) {
        return index < this.header.numRequiredSignatures;
      }
    }, {
      key: "isAccountWritable",
      value: function isAccountWritable(index) {
        var numSignedAccounts = this.header.numRequiredSignatures;
        var numStaticAccountKeys = this.staticAccountKeys.length;

        if (index >= numStaticAccountKeys) {
          var lookupAccountKeysIndex = index - numStaticAccountKeys;
          var numWritableLookupAccountKeys = this.addressTableLookups.reduce(function (count, lookup) {
            return count + lookup.writableIndexes.length;
          }, 0);
          return lookupAccountKeysIndex < numWritableLookupAccountKeys;
        } else if (index >= this.header.numRequiredSignatures) {
          var unsignedAccountIndex = index - numSignedAccounts;
          var numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;
          var numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;
          return unsignedAccountIndex < numWritableUnsignedAccounts;
        } else {
          var numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;
          return index < numWritableSignedAccounts;
        }
      }
    }, {
      key: "resolveAddressTableLookups",
      value: function resolveAddressTableLookups(addressLookupTableAccounts) {
        var accountKeysFromLookups = {
          writable: [],
          readonly: []
        };

        var _iterator6 = _createForOfIteratorHelper(this.addressTableLookups),
            _step6;

        try {
          var _loop2 = function _loop2() {
            var tableLookup = _step6.value;
            var tableAccount = addressLookupTableAccounts.find(function (account) {
              return account.key.equals(tableLookup.accountKey);
            });

            if (!tableAccount) {
              throw new Error("Failed to find address lookup table account for table key ".concat(tableLookup.accountKey.toBase58()));
            }

            var _iterator7 = _createForOfIteratorHelper(tableLookup.writableIndexes),
                _step7;

            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var index = _step7.value;

                if (index < tableAccount.state.addresses.length) {
                  accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);
                } else {
                  throw new Error("Failed to find address for index ".concat(index, " in address lookup table ").concat(tableLookup.accountKey.toBase58()));
                }
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }

            var _iterator8 = _createForOfIteratorHelper(tableLookup.readonlyIndexes),
                _step8;

            try {
              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                var _index = _step8.value;

                if (_index < tableAccount.state.addresses.length) {
                  accountKeysFromLookups.readonly.push(tableAccount.state.addresses[_index]);
                } else {
                  throw new Error("Failed to find address for index ".concat(_index, " in address lookup table ").concat(tableLookup.accountKey.toBase58()));
                }
              }
            } catch (err) {
              _iterator8.e(err);
            } finally {
              _iterator8.f();
            }
          };

          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            _loop2();
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }

        return accountKeysFromLookups;
      }
    }, {
      key: "serialize",
      value: function serialize() {
        var encodedStaticAccountKeysLength = Array();
        encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);
        var serializedInstructions = this.serializeInstructions();
        var encodedInstructionsLength = Array();
        encodeLength(encodedInstructionsLength, this.compiledInstructions.length);
        var serializedAddressTableLookups = this.serializeAddressTableLookups();
        var encodedAddressTableLookupsLength = Array();
        encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);
        var messageLayout = struct([u8('prefix'), struct([u8('numRequiredSignatures'), u8('numReadonlySignedAccounts'), u8('numReadonlyUnsignedAccounts')], 'header'), blob$1(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), seq$1(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), blob$1(encodedInstructionsLength.length, 'instructionsLength'), blob$1(serializedInstructions.length, 'serializedInstructions'), blob$1(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), blob$1(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);
        var serializedMessage = new Uint8Array(PACKET_DATA_SIZE);
        var MESSAGE_VERSION_0_PREFIX = 1 << 7;
        var serializedMessageLength = messageLayout.encode({
          prefix: MESSAGE_VERSION_0_PREFIX,
          header: this.header,
          staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),
          staticAccountKeys: this.staticAccountKeys.map(function (key) {
            return key.toBytes();
          }),
          recentBlockhash: bs58$1.decode(this.recentBlockhash),
          instructionsLength: new Uint8Array(encodedInstructionsLength),
          serializedInstructions: serializedInstructions,
          addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),
          serializedAddressTableLookups: serializedAddressTableLookups
        }, serializedMessage);
        return serializedMessage.slice(0, serializedMessageLength);
      }
    }, {
      key: "serializeInstructions",
      value: function serializeInstructions() {
        var serializedLength = 0;
        var serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);

        var _iterator9 = _createForOfIteratorHelper(this.compiledInstructions),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var instruction = _step9.value;
            var encodedAccountKeyIndexesLength = Array();
            encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);
            var encodedDataLength = Array();
            encodeLength(encodedDataLength, instruction.data.length);
            var instructionLayout = struct([u8('programIdIndex'), blob$1(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), seq$1(u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), blob$1(encodedDataLength.length, 'encodedDataLength'), blob$1(instruction.data.length, 'data')]);
            serializedLength += instructionLayout.encode({
              programIdIndex: instruction.programIdIndex,
              encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),
              accountKeyIndexes: instruction.accountKeyIndexes,
              encodedDataLength: new Uint8Array(encodedDataLength),
              data: instruction.data
            }, serializedInstructions, serializedLength);
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }

        return serializedInstructions.slice(0, serializedLength);
      }
    }, {
      key: "serializeAddressTableLookups",
      value: function serializeAddressTableLookups() {
        var serializedLength = 0;
        var serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);

        var _iterator10 = _createForOfIteratorHelper(this.addressTableLookups),
            _step10;

        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var lookup = _step10.value;
            var encodedWritableIndexesLength = Array();
            encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);
            var encodedReadonlyIndexesLength = Array();
            encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);
            var addressTableLookupLayout = struct([publicKey('accountKey'), blob$1(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), seq$1(u8(), lookup.writableIndexes.length, 'writableIndexes'), blob$1(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), seq$1(u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);
            serializedLength += addressTableLookupLayout.encode({
              accountKey: lookup.accountKey.toBytes(),
              encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),
              writableIndexes: lookup.writableIndexes,
              encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),
              readonlyIndexes: lookup.readonlyIndexes
            }, serializedAddressTableLookups, serializedLength);
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }

        return serializedAddressTableLookups.slice(0, serializedLength);
      }
    }], [{
      key: "compile",
      value: function compile(args) {
        var compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);
        var addressTableLookups = new Array();
        var accountKeysFromLookups = {
          writable: new Array(),
          readonly: new Array()
        };
        var lookupTableAccounts = args.addressLookupTableAccounts || [];

        var _iterator11 = _createForOfIteratorHelper(lookupTableAccounts),
            _step11;

        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var lookupTable = _step11.value;
            var extractResult = compiledKeys.extractTableLookup(lookupTable);

            if (extractResult !== undefined) {
              var _accountKeysFromLooku, _accountKeysFromLooku2;

              var _extractResult2 = _slicedToArray(extractResult, 2),
                  addressTableLookup = _extractResult2[0],
                  _extractResult$2 = _extractResult2[1],
                  writable = _extractResult$2.writable,
                  readonly = _extractResult$2.readonly;

              addressTableLookups.push(addressTableLookup);

              (_accountKeysFromLooku = accountKeysFromLookups.writable).push.apply(_accountKeysFromLooku, _toConsumableArray(writable));

              (_accountKeysFromLooku2 = accountKeysFromLookups.readonly).push.apply(_accountKeysFromLooku2, _toConsumableArray(readonly));
            }
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }

        var _compiledKeys$getMess3 = compiledKeys.getMessageComponents(),
            _compiledKeys$getMess4 = _slicedToArray(_compiledKeys$getMess3, 2),
            header = _compiledKeys$getMess4[0],
            staticAccountKeys = _compiledKeys$getMess4[1];

        var accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);
        var compiledInstructions = accountKeys.compileInstructions(args.instructions);
        return new MessageV0({
          header: header,
          staticAccountKeys: staticAccountKeys,
          recentBlockhash: args.recentBlockhash,
          compiledInstructions: compiledInstructions,
          addressTableLookups: addressTableLookups
        });
      }
    }, {
      key: "deserialize",
      value: function deserialize(serializedMessage) {
        var byteArray = _toConsumableArray(serializedMessage);

        var prefix = byteArray.shift();
        var maskedPrefix = prefix & VERSION_PREFIX_MASK;
        assert(prefix !== maskedPrefix, "Expected versioned message but received legacy message");
        var version = maskedPrefix;
        assert(version === 0, "Expected versioned message with version 0 but found version ".concat(version));
        var header = {
          numRequiredSignatures: byteArray.shift(),
          numReadonlySignedAccounts: byteArray.shift(),
          numReadonlyUnsignedAccounts: byteArray.shift()
        };
        var staticAccountKeys = [];
        var staticAccountKeysLength = decodeLength(byteArray);

        for (var i = 0; i < staticAccountKeysLength; i++) {
          staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));
        }

        var recentBlockhash = bs58$1.encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));
        var instructionCount = decodeLength(byteArray);
        var compiledInstructions = [];

        for (var _i4 = 0; _i4 < instructionCount; _i4++) {
          var programIdIndex = byteArray.shift();
          var accountKeyIndexesLength = decodeLength(byteArray);
          var accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);
          var dataLength = decodeLength(byteArray);
          var data = new Uint8Array(byteArray.splice(0, dataLength));
          compiledInstructions.push({
            programIdIndex: programIdIndex,
            accountKeyIndexes: accountKeyIndexes,
            data: data
          });
        }

        var addressTableLookupsCount = decodeLength(byteArray);
        var addressTableLookups = [];

        for (var _i6 = 0; _i6 < addressTableLookupsCount; _i6++) {
          var accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));
          var writableIndexesLength = decodeLength(byteArray);
          var writableIndexes = byteArray.splice(0, writableIndexesLength);
          var readonlyIndexesLength = decodeLength(byteArray);
          var readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);
          addressTableLookups.push({
            accountKey: accountKey,
            writableIndexes: writableIndexes,
            readonlyIndexes: readonlyIndexes
          });
        }

        return new MessageV0({
          header: header,
          staticAccountKeys: staticAccountKeys,
          recentBlockhash: recentBlockhash,
          compiledInstructions: compiledInstructions,
          addressTableLookups: addressTableLookups
        });
      }
    }]);

    return MessageV0;
  }(); // eslint-disable-next-line no-redeclare


  var VersionedMessage = {
    deserializeMessageVersion: function deserializeMessageVersion(serializedMessage) {
      var prefix = serializedMessage[0];
      var maskedPrefix = prefix & VERSION_PREFIX_MASK; // if the highest bit of the prefix is not set, the message is not versioned

      if (maskedPrefix === prefix) {
        return 'legacy';
      } // the lower 7 bits of the prefix indicate the message version


      return maskedPrefix;
    },
    deserialize: function deserialize(serializedMessage) {
      var version = VersionedMessage.deserializeMessageVersion(serializedMessage);

      if (version === 'legacy') {
        return Message.from(serializedMessage);
      }

      if (version === 0) {
        return MessageV0.deserialize(serializedMessage);
      } else {
        throw new Error("Transaction message version ".concat(version, " deserialization is not supported"));
      }
    }
  };
  /**
   * Transaction signature as base-58 encoded string
   */

  var TransactionStatus;
  /**
   * Default (empty) signature
   */

  (function (TransactionStatus) {
    TransactionStatus[TransactionStatus["BLOCKHEIGHT_EXCEEDED"] = 0] = "BLOCKHEIGHT_EXCEEDED";
    TransactionStatus[TransactionStatus["PROCESSED"] = 1] = "PROCESSED";
    TransactionStatus[TransactionStatus["TIMED_OUT"] = 2] = "TIMED_OUT";
    TransactionStatus[TransactionStatus["NONCE_INVALID"] = 3] = "NONCE_INVALID";
  })(TransactionStatus || (TransactionStatus = {}));

  var DEFAULT_SIGNATURE = Buffer$1.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
  /**
   * Account metadata used to define instructions
   */

  /**
   * Transaction Instruction class
   */

  var TransactionInstruction = /*#__PURE__*/function () {
    /**
     * Public keys to include in this transaction
     * Boolean represents whether this pubkey needs to sign the transaction
     */

    /**
     * Program Id to execute
     */

    /**
     * Program input
     */
    function TransactionInstruction(opts) {
      _classCallCheck(this, TransactionInstruction);

      this.keys = void 0;
      this.programId = void 0;
      this.data = Buffer$1.alloc(0);
      this.programId = opts.programId;
      this.keys = opts.keys;

      if (opts.data) {
        this.data = opts.data;
      }
    }
    /**
     * @internal
     */


    _createClass(TransactionInstruction, [{
      key: "toJSON",
      value: function toJSON() {
        return {
          keys: this.keys.map(function (_ref17) {
            var pubkey = _ref17.pubkey,
                isSigner = _ref17.isSigner,
                isWritable = _ref17.isWritable;
            return {
              pubkey: pubkey.toJSON(),
              isSigner: isSigner,
              isWritable: isWritable
            };
          }),
          programId: this.programId.toJSON(),
          data: _toConsumableArray(this.data)
        };
      }
    }]);

    return TransactionInstruction;
  }();
  /**
   * Pair of signature and corresponding public key
   */

  /**
   * Transaction class
   */


  var Transaction$1 = /*#__PURE__*/function () {
    /**
     * The transaction fee payer
     */

    /**
     * Construct an empty Transaction
     */
    function Transaction(opts) {
      _classCallCheck(this, Transaction);

      this.signatures = [];
      this.feePayer = void 0;
      this.instructions = [];
      this.recentBlockhash = void 0;
      this.lastValidBlockHeight = void 0;
      this.nonceInfo = void 0;
      this.minNonceContextSlot = void 0;
      this._message = void 0;
      this._json = void 0;

      if (!opts) {
        return;
      }

      if (opts.feePayer) {
        this.feePayer = opts.feePayer;
      }

      if (opts.signatures) {
        this.signatures = opts.signatures;
      }

      if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {
        var minContextSlot = opts.minContextSlot,
            nonceInfo = opts.nonceInfo;
        this.minNonceContextSlot = minContextSlot;
        this.nonceInfo = nonceInfo;
      } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {
        var blockhash = opts.blockhash,
            lastValidBlockHeight = opts.lastValidBlockHeight;
        this.recentBlockhash = blockhash;
        this.lastValidBlockHeight = lastValidBlockHeight;
      } else {
        var recentBlockhash = opts.recentBlockhash,
            _nonceInfo = opts.nonceInfo;

        if (_nonceInfo) {
          this.nonceInfo = _nonceInfo;
        }

        this.recentBlockhash = recentBlockhash;
      }
    }
    /**
     * @internal
     */


    _createClass(Transaction, [{
      key: "signature",
      get:
      /**
       * Signatures for the transaction.  Typically created by invoking the
       * `sign()` method
       */

      /**
       * The first (payer) Transaction signature
       */
      function get() {
        if (this.signatures.length > 0) {
          return this.signatures[0].signature;
        }

        return null;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          recentBlockhash: this.recentBlockhash || null,
          feePayer: this.feePayer ? this.feePayer.toJSON() : null,
          nonceInfo: this.nonceInfo ? {
            nonce: this.nonceInfo.nonce,
            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
          } : null,
          instructions: this.instructions.map(function (instruction) {
            return instruction.toJSON();
          }),
          signers: this.signatures.map(function (_ref18) {
            var publicKey = _ref18.publicKey;
            return publicKey.toJSON();
          })
        };
      }
      /**
       * Add one or more instructions to this Transaction
       */

    }, {
      key: "add",
      value: function add() {
        var _this9 = this;

        for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {
          items[_key] = arguments[_key];
        }

        if (items.length === 0) {
          throw new Error('No instructions');
        }

        items.forEach(function (item) {
          if ('instructions' in item) {
            _this9.instructions = _this9.instructions.concat(item.instructions);
          } else if ('data' in item && 'programId' in item && 'keys' in item) {
            _this9.instructions.push(item);
          } else {
            _this9.instructions.push(new TransactionInstruction(item));
          }
        });
        return this;
      }
      /**
       * Compile transaction data
       */

    }, {
      key: "compileMessage",
      value: function compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {
          return this._message;
        }

        var recentBlockhash;
        var instructions;

        if (this.nonceInfo) {
          recentBlockhash = this.nonceInfo.nonce;

          if (this.instructions[0] != this.nonceInfo.nonceInstruction) {
            instructions = [this.nonceInfo.nonceInstruction].concat(_toConsumableArray(this.instructions));
          } else {
            instructions = this.instructions;
          }
        } else {
          recentBlockhash = this.recentBlockhash;
          instructions = this.instructions;
        }

        if (!recentBlockhash) {
          throw new Error('Transaction recentBlockhash required');
        }

        if (instructions.length < 1) {
          console.warn('No instructions provided');
        }

        var feePayer;

        if (this.feePayer) {
          feePayer = this.feePayer;
        } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {
          // Use implicit fee payer
          feePayer = this.signatures[0].publicKey;
        } else {
          throw new Error('Transaction fee payer required');
        }

        for (var i = 0; i < instructions.length; i++) {
          if (instructions[i].programId === undefined) {
            throw new Error("Transaction instruction index ".concat(i, " has undefined program id"));
          }
        }

        var programIds = [];
        var accountMetas = [];
        instructions.forEach(function (instruction) {
          instruction.keys.forEach(function (accountMeta) {
            accountMetas.push(_objectSpread2({}, accountMeta));
          });
          var programId = instruction.programId.toString();

          if (!programIds.includes(programId)) {
            programIds.push(programId);
          }
        }); // Append programID account metas

        programIds.forEach(function (programId) {
          accountMetas.push({
            pubkey: new PublicKey(programId),
            isSigner: false,
            isWritable: false
          });
        }); // Cull duplicate account metas

        var uniqueMetas = [];
        accountMetas.forEach(function (accountMeta) {
          var pubkeyString = accountMeta.pubkey.toString();
          var uniqueIndex = uniqueMetas.findIndex(function (x) {
            return x.pubkey.toString() === pubkeyString;
          });

          if (uniqueIndex > -1) {
            uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;
            uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;
          } else {
            uniqueMetas.push(accountMeta);
          }
        }); // Sort. Prioritizing first by signer, then by writable

        uniqueMetas.sort(function (x, y) {
          if (x.isSigner !== y.isSigner) {
            // Signers always come before non-signers
            return x.isSigner ? -1 : 1;
          }

          if (x.isWritable !== y.isWritable) {
            // Writable accounts always come before read-only accounts
            return x.isWritable ? -1 : 1;
          } // Otherwise, sort by pubkey, stringwise.


          return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58());
        }); // Move fee payer to the front

        var feePayerIndex = uniqueMetas.findIndex(function (x) {
          return x.pubkey.equals(feePayer);
        });

        if (feePayerIndex > -1) {
          var _uniqueMetas$splice3 = uniqueMetas.splice(feePayerIndex, 1),
              _uniqueMetas$splice4 = _slicedToArray(_uniqueMetas$splice3, 1),
              payerMeta = _uniqueMetas$splice4[0];

          payerMeta.isSigner = true;
          payerMeta.isWritable = true;
          uniqueMetas.unshift(payerMeta);
        } else {
          uniqueMetas.unshift({
            pubkey: feePayer,
            isSigner: true,
            isWritable: true
          });
        } // Disallow unknown signers


        var _iterator12 = _createForOfIteratorHelper(this.signatures),
            _step12;

        try {
          var _loop3 = function _loop3() {
            var signature = _step12.value;
            var uniqueIndex = uniqueMetas.findIndex(function (x) {
              return x.pubkey.equals(signature.publicKey);
            });

            if (uniqueIndex > -1) {
              if (!uniqueMetas[uniqueIndex].isSigner) {
                uniqueMetas[uniqueIndex].isSigner = true;
                console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');
              }
            } else {
              throw new Error("unknown signer: ".concat(signature.publicKey.toString()));
            }
          };

          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            _loop3();
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }

        var numRequiredSignatures = 0;
        var numReadonlySignedAccounts = 0;
        var numReadonlyUnsignedAccounts = 0; // Split out signing from non-signing keys and count header values

        var signedKeys = [];
        var unsignedKeys = [];
        uniqueMetas.forEach(function (_ref19) {
          var pubkey = _ref19.pubkey,
              isSigner = _ref19.isSigner,
              isWritable = _ref19.isWritable;

          if (isSigner) {
            signedKeys.push(pubkey.toString());
            numRequiredSignatures += 1;

            if (!isWritable) {
              numReadonlySignedAccounts += 1;
            }
          } else {
            unsignedKeys.push(pubkey.toString());

            if (!isWritable) {
              numReadonlyUnsignedAccounts += 1;
            }
          }
        });
        var accountKeys = signedKeys.concat(unsignedKeys);
        var compiledInstructions = instructions.map(function (instruction) {
          var data = instruction.data,
              programId = instruction.programId;
          return {
            programIdIndex: accountKeys.indexOf(programId.toString()),
            accounts: instruction.keys.map(function (meta) {
              return accountKeys.indexOf(meta.pubkey.toString());
            }),
            data: bs58$1.encode(data)
          };
        });
        compiledInstructions.forEach(function (instruction) {
          assert(instruction.programIdIndex >= 0);
          instruction.accounts.forEach(function (keyIndex) {
            return assert(keyIndex >= 0);
          });
        });
        return new Message({
          header: {
            numRequiredSignatures: numRequiredSignatures,
            numReadonlySignedAccounts: numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts
          },
          accountKeys: accountKeys,
          recentBlockhash: recentBlockhash,
          instructions: compiledInstructions
        });
      }
      /**
       * @internal
       */

    }, {
      key: "_compile",
      value: function _compile() {
        var message = this.compileMessage();
        var signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);

        if (this.signatures.length === signedKeys.length) {
          var valid = this.signatures.every(function (pair, index) {
            return signedKeys[index].equals(pair.publicKey);
          });
          if (valid) return message;
        }

        this.signatures = signedKeys.map(function (publicKey) {
          return {
            signature: null,
            publicKey: publicKey
          };
        });
        return message;
      }
      /**
       * Get a buffer of the Transaction data that need to be covered by signatures
       */

    }, {
      key: "serializeMessage",
      value: function serializeMessage() {
        return this._compile().serialize();
      }
      /**
       * Get the estimated fee associated with a transaction
       */

    }, {
      key: "getEstimatedFee",
      value: function () {
        var _getEstimatedFee = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(connection) {
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return connection.getFeeForMessage(this.compileMessage());

              case 2:
                return _context4.abrupt("return", _context4.sent.value);

              case 3:
              case "end":
                return _context4.stop();
            }
          }, _callee4, this);
        }));

        function getEstimatedFee(_x8) {
          return _getEstimatedFee.apply(this, arguments);
        }

        return getEstimatedFee;
      }()
      /**
       * Specify the public keys which will be used to sign the Transaction.
       * The first signer will be used as the transaction fee payer account.
       *
       * Signatures can be added with either `partialSign` or `addSignature`
       *
       * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be
       * specified and it can be set in the Transaction constructor or with the
       * `feePayer` property.
       */

    }, {
      key: "setSigners",
      value: function setSigners() {
        for (var _len2 = arguments.length, signers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          signers[_key2] = arguments[_key2];
        }

        if (signers.length === 0) {
          throw new Error('No signers');
        }

        var seen = new Set();
        this.signatures = signers.filter(function (publicKey) {
          var key = publicKey.toString();

          if (seen.has(key)) {
            return false;
          } else {
            seen.add(key);
            return true;
          }
        }).map(function (publicKey) {
          return {
            signature: null,
            publicKey: publicKey
          };
        });
      }
      /**
       * Sign the Transaction with the specified signers. Multiple signatures may
       * be applied to a Transaction. The first signature is considered "primary"
       * and is used identify and confirm transactions.
       *
       * If the Transaction `feePayer` is not set, the first signer will be used
       * as the transaction fee payer account.
       *
       * Transaction fields should not be modified after the first call to `sign`,
       * as doing so may invalidate the signature and cause the Transaction to be
       * rejected.
       *
       * The Transaction must be assigned a valid `recentBlockhash` before invoking this method
       */

    }, {
      key: "sign",
      value: function sign() {
        for (var _len3 = arguments.length, signers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          signers[_key3] = arguments[_key3];
        }

        if (signers.length === 0) {
          throw new Error('No signers');
        } // Dedupe signers


        var seen = new Set();
        var uniqueSigners = [];

        for (var _i7 = 0, _signers = signers; _i7 < _signers.length; _i7++) {
          var signer = _signers[_i7];
          var key = signer.publicKey.toString();

          if (seen.has(key)) {
            continue;
          } else {
            seen.add(key);
            uniqueSigners.push(signer);
          }
        }

        this.signatures = uniqueSigners.map(function (signer) {
          return {
            signature: null,
            publicKey: signer.publicKey
          };
        });

        var message = this._compile();

        this._partialSign.apply(this, [message].concat(uniqueSigners));
      }
      /**
       * Partially sign a transaction with the specified accounts. All accounts must
       * correspond to either the fee payer or a signer account in the transaction
       * instructions.
       *
       * All the caveats from the `sign` method apply to `partialSign`
       */

    }, {
      key: "partialSign",
      value: function partialSign() {
        for (var _len4 = arguments.length, signers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          signers[_key4] = arguments[_key4];
        }

        if (signers.length === 0) {
          throw new Error('No signers');
        } // Dedupe signers


        var seen = new Set();
        var uniqueSigners = [];

        for (var _i8 = 0, _signers2 = signers; _i8 < _signers2.length; _i8++) {
          var signer = _signers2[_i8];
          var key = signer.publicKey.toString();

          if (seen.has(key)) {
            continue;
          } else {
            seen.add(key);
            uniqueSigners.push(signer);
          }
        }

        var message = this._compile();

        this._partialSign.apply(this, [message].concat(uniqueSigners));
      }
      /**
       * @internal
       */

    }, {
      key: "_partialSign",
      value: function _partialSign(message) {
        var _this10 = this;

        var signData = message.serialize();

        for (var _len5 = arguments.length, signers = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
          signers[_key5 - 1] = arguments[_key5];
        }

        signers.forEach(function (signer) {
          var signature = _sign(signData, signer.secretKey);

          _this10._addSignature(signer.publicKey, toBuffer(signature));
        });
      }
      /**
       * Add an externally created signature to a transaction. The public key
       * must correspond to either the fee payer or a signer account in the transaction
       * instructions.
       */

    }, {
      key: "addSignature",
      value: function addSignature(pubkey, signature) {
        this._compile(); // Ensure signatures array is populated


        this._addSignature(pubkey, signature);
      }
      /**
       * @internal
       */

    }, {
      key: "_addSignature",
      value: function _addSignature(pubkey, signature) {
        assert(signature.length === 64);
        var index = this.signatures.findIndex(function (sigpair) {
          return pubkey.equals(sigpair.publicKey);
        });

        if (index < 0) {
          throw new Error("unknown signer: ".concat(pubkey.toString()));
        }

        this.signatures[index].signature = Buffer$1.from(signature);
      }
      /**
       * Verify signatures of a Transaction
       * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.
       * If no boolean is provided, we expect a fully signed Transaction by default.
       */

    }, {
      key: "verifySignatures",
      value: function verifySignatures(requireAllSignatures) {
        return this._verifySignatures(this.serializeMessage(), requireAllSignatures === undefined ? true : requireAllSignatures);
      }
      /**
       * @internal
       */

    }, {
      key: "_verifySignatures",
      value: function _verifySignatures(signData, requireAllSignatures) {
        var _iterator13 = _createForOfIteratorHelper(this.signatures),
            _step13;

        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var _step13$value2 = _step13.value,
                _signature = _step13$value2.signature,
                _publicKey = _step13$value2.publicKey;

            if (_signature === null) {
              if (requireAllSignatures) {
                return false;
              }
            } else {
              if (!verify(_signature, signData, _publicKey.toBytes())) {
                return false;
              }
            }
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }

        return true;
      }
      /**
       * Serialize the Transaction in the wire format.
       */

    }, {
      key: "serialize",
      value: function serialize(config) {
        var _Object$assign = Object.assign({
          requireAllSignatures: true,
          verifySignatures: true
        }, config),
            requireAllSignatures = _Object$assign.requireAllSignatures,
            verifySignatures = _Object$assign.verifySignatures;

        var signData = this.serializeMessage();

        if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {
          throw new Error('Signature verification failed');
        }

        return this._serialize(signData);
      }
      /**
       * @internal
       */

    }, {
      key: "_serialize",
      value: function _serialize(signData) {
        var signatures = this.signatures;
        var signatureCount = [];
        encodeLength(signatureCount, signatures.length);
        var transactionLength = signatureCount.length + signatures.length * 64 + signData.length;
        var wireTransaction = Buffer$1.alloc(transactionLength);
        assert(signatures.length < 256);
        Buffer$1.from(signatureCount).copy(wireTransaction, 0);
        signatures.forEach(function (_ref20, index) {
          var signature = _ref20.signature;

          if (signature !== null) {
            assert(signature.length === 64, "signature has invalid length");
            Buffer$1.from(signature).copy(wireTransaction, signatureCount.length + index * 64);
          }
        });
        signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);
        assert(wireTransaction.length <= PACKET_DATA_SIZE, "Transaction too large: ".concat(wireTransaction.length, " > ").concat(PACKET_DATA_SIZE));
        return wireTransaction;
      }
      /**
       * Deprecated method
       * @internal
       */

    }, {
      key: "keys",
      get: function get() {
        assert(this.instructions.length === 1);
        return this.instructions[0].keys.map(function (keyObj) {
          return keyObj.pubkey;
        });
      }
      /**
       * Deprecated method
       * @internal
       */

    }, {
      key: "programId",
      get: function get() {
        assert(this.instructions.length === 1);
        return this.instructions[0].programId;
      }
      /**
       * Deprecated method
       * @internal
       */

    }, {
      key: "data",
      get: function get() {
        assert(this.instructions.length === 1);
        return this.instructions[0].data;
      }
      /**
       * Parse a wire transaction into a Transaction object.
       */

    }], [{
      key: "from",
      value: function from(buffer) {
        // Slice up wire data
        var byteArray = _toConsumableArray(buffer);

        var signatureCount = decodeLength(byteArray);
        var signatures = [];

        for (var i = 0; i < signatureCount; i++) {
          var _signature2 = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);

          byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);
          signatures.push(bs58$1.encode(Buffer$1.from(_signature2)));
        }

        return Transaction.populate(Message.from(byteArray), signatures);
      }
      /**
       * Populate Transaction object from message and signatures
       */

    }, {
      key: "populate",
      value: function populate(message) {
        var signatures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var transaction = new Transaction();
        transaction.recentBlockhash = message.recentBlockhash;

        if (message.header.numRequiredSignatures > 0) {
          transaction.feePayer = message.accountKeys[0];
        }

        signatures.forEach(function (signature, index) {
          var sigPubkeyPair = {
            signature: signature == bs58$1.encode(DEFAULT_SIGNATURE) ? null : bs58$1.decode(signature),
            publicKey: message.accountKeys[index]
          };
          transaction.signatures.push(sigPubkeyPair);
        });
        message.instructions.forEach(function (instruction) {
          var keys = instruction.accounts.map(function (account) {
            var pubkey = message.accountKeys[account];
            return {
              pubkey: pubkey,
              isSigner: transaction.signatures.some(function (keyObj) {
                return keyObj.publicKey.toString() === pubkey.toString();
              }) || message.isAccountSigner(account),
              isWritable: message.isAccountWritable(account)
            };
          });
          transaction.instructions.push(new TransactionInstruction({
            keys: keys,
            programId: message.accountKeys[instruction.programIdIndex],
            data: bs58$1.decode(instruction.data)
          }));
        });
        transaction._message = message;
        transaction._json = transaction.toJSON();
        return transaction;
      }
    }]);

    return Transaction;
  }();

  var TransactionMessage = /*#__PURE__*/function () {
    function TransactionMessage(args) {
      _classCallCheck(this, TransactionMessage);

      this.payerKey = void 0;
      this.instructions = void 0;
      this.recentBlockhash = void 0;
      this.payerKey = args.payerKey;
      this.instructions = args.instructions;
      this.recentBlockhash = args.recentBlockhash;
    }

    _createClass(TransactionMessage, [{
      key: "compileToLegacyMessage",
      value: function compileToLegacyMessage() {
        return Message.compile({
          payerKey: this.payerKey,
          recentBlockhash: this.recentBlockhash,
          instructions: this.instructions
        });
      }
    }, {
      key: "compileToV0Message",
      value: function compileToV0Message(addressLookupTableAccounts) {
        return MessageV0.compile({
          payerKey: this.payerKey,
          recentBlockhash: this.recentBlockhash,
          instructions: this.instructions,
          addressLookupTableAccounts: addressLookupTableAccounts
        });
      }
    }], [{
      key: "decompile",
      value: function decompile(message, args) {
        var header = message.header,
            compiledInstructions = message.compiledInstructions,
            recentBlockhash = message.recentBlockhash;
        var numRequiredSignatures = header.numRequiredSignatures,
            numReadonlySignedAccounts = header.numReadonlySignedAccounts,
            numReadonlyUnsignedAccounts = header.numReadonlyUnsignedAccounts;
        var numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;
        assert(numWritableSignedAccounts > 0, 'Message header is invalid');
        var numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;
        assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');
        var accountKeys = message.getAccountKeys(args);
        var payerKey = accountKeys.get(0);

        if (payerKey === undefined) {
          throw new Error('Failed to decompile message because no account keys were found');
        }

        var instructions = [];

        var _iterator14 = _createForOfIteratorHelper(compiledInstructions),
            _step14;

        try {
          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
            var compiledIx = _step14.value;
            var keys = [];

            var _iterator15 = _createForOfIteratorHelper(compiledIx.accountKeyIndexes),
                _step15;

            try {
              for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
                var keyIndex = _step15.value;
                var pubkey = accountKeys.get(keyIndex);

                if (pubkey === undefined) {
                  throw new Error("Failed to find key for account key index ".concat(keyIndex));
                }

                var isSigner = keyIndex < numRequiredSignatures;
                var isWritable = void 0;

                if (isSigner) {
                  isWritable = keyIndex < numWritableSignedAccounts;
                } else if (keyIndex < accountKeys.staticAccountKeys.length) {
                  isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;
                } else {
                  isWritable = keyIndex - accountKeys.staticAccountKeys.length < // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above
                  accountKeys.accountKeysFromLookups.writable.length;
                }

                keys.push({
                  pubkey: pubkey,
                  isSigner: keyIndex < header.numRequiredSignatures,
                  isWritable: isWritable
                });
              }
            } catch (err) {
              _iterator15.e(err);
            } finally {
              _iterator15.f();
            }

            var programId = accountKeys.get(compiledIx.programIdIndex);

            if (programId === undefined) {
              throw new Error("Failed to find program id for program id index ".concat(compiledIx.programIdIndex));
            }

            instructions.push(new TransactionInstruction({
              programId: programId,
              data: toBuffer(compiledIx.data),
              keys: keys
            }));
          }
        } catch (err) {
          _iterator14.e(err);
        } finally {
          _iterator14.f();
        }

        return new TransactionMessage({
          payerKey: payerKey,
          instructions: instructions,
          recentBlockhash: recentBlockhash
        });
      }
    }]);

    return TransactionMessage;
  }();
  /**
   * Versioned transaction class
   */


  var VersionedTransaction = /*#__PURE__*/function () {
    function VersionedTransaction(message, signatures) {
      _classCallCheck(this, VersionedTransaction);

      this.signatures = void 0;
      this.message = void 0;

      if (signatures !== undefined) {
        assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');
        this.signatures = signatures;
      } else {
        var defaultSignatures = [];

        for (var i = 0; i < message.header.numRequiredSignatures; i++) {
          defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
        }

        this.signatures = defaultSignatures;
      }

      this.message = message;
    }

    _createClass(VersionedTransaction, [{
      key: "version",
      get: function get() {
        return this.message.version;
      }
    }, {
      key: "serialize",
      value: function serialize() {
        var serializedMessage = this.message.serialize();
        var encodedSignaturesLength = Array();
        encodeLength(encodedSignaturesLength, this.signatures.length);
        var transactionLayout = struct([blob$1(encodedSignaturesLength.length, 'encodedSignaturesLength'), seq$1(signature(), this.signatures.length, 'signatures'), blob$1(serializedMessage.length, 'serializedMessage')]);
        var serializedTransaction = new Uint8Array(2048);
        var serializedTransactionLength = transactionLayout.encode({
          encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),
          signatures: this.signatures,
          serializedMessage: serializedMessage
        }, serializedTransaction);
        return serializedTransaction.slice(0, serializedTransactionLength);
      }
    }, {
      key: "sign",
      value: function sign(signers) {
        var _this11 = this;

        var messageData = this.message.serialize();
        var signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);

        var _iterator16 = _createForOfIteratorHelper(signers),
            _step16;

        try {
          var _loop4 = function _loop4() {
            var signer = _step16.value;
            var signerIndex = signerPubkeys.findIndex(function (pubkey) {
              return pubkey.equals(signer.publicKey);
            });
            assert(signerIndex >= 0, "Cannot sign with non signer key ".concat(signer.publicKey.toBase58()));
            _this11.signatures[signerIndex] = _sign(messageData, signer.secretKey);
          };

          for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
            _loop4();
          }
        } catch (err) {
          _iterator16.e(err);
        } finally {
          _iterator16.f();
        }
      }
    }, {
      key: "addSignature",
      value: function addSignature(publicKey, signature) {
        assert(signature.byteLength === 64, 'Signature must be 64 bytes long');
        var signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        var signerIndex = signerPubkeys.findIndex(function (pubkey) {
          return pubkey.equals(publicKey);
        });
        assert(signerIndex >= 0, "Can not add signature; `".concat(publicKey.toBase58(), "` is not required to sign this transaction"));
        this.signatures[signerIndex] = signature;
      }
    }], [{
      key: "deserialize",
      value: function deserialize(serializedTransaction) {
        var byteArray = _toConsumableArray(serializedTransaction);

        var signatures = [];
        var signaturesLength = decodeLength(byteArray);

        for (var i = 0; i < signaturesLength; i++) {
          signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));
        }

        var message = VersionedMessage.deserialize(new Uint8Array(byteArray));
        return new VersionedTransaction(message, signatures);
      }
    }]);

    return VersionedTransaction;
  }();

  var SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');
  var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');
  var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');
  var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');
  var SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');
  var SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');
  var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');
  var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');
  var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');
  /**
   * Sign, send and confirm a transaction.
   *
   * If `commitment` option is not specified, defaults to 'max' commitment.
   *
   * @param {Connection} connection
   * @param {Transaction} transaction
   * @param {Array<Signer>} signers
   * @param {ConfirmOptions} [options]
   * @returns {Promise<TransactionSignature>}
   */

  function sendAndConfirmTransaction(_x9, _x10, _x11, _x12) {
    return _sendAndConfirmTransaction.apply(this, arguments);
  } // zzz


  function _sendAndConfirmTransaction() {
    _sendAndConfirmTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee108(connection, transaction, signers, options) {
      var sendOptions, signature, status, nonceInstruction, nonceAccountPubkey;
      return _regeneratorRuntime().wrap(function _callee108$(_context108) {
        while (1) switch (_context108.prev = _context108.next) {
          case 0:
            sendOptions = options && {
              skipPreflight: options.skipPreflight,
              preflightCommitment: options.preflightCommitment || options.commitment,
              maxRetries: options.maxRetries,
              minContextSlot: options.minContextSlot
            };
            _context108.next = 3;
            return connection.sendTransaction(transaction, signers, sendOptions);

          case 3:
            signature = _context108.sent;

            if (!(transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null)) {
              _context108.next = 10;
              break;
            }

            _context108.next = 7;
            return connection.confirmTransaction({
              abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
              signature: signature,
              blockhash: transaction.recentBlockhash,
              lastValidBlockHeight: transaction.lastValidBlockHeight
            }, options && options.commitment);

          case 7:
            status = _context108.sent.value;
            _context108.next = 22;
            break;

          case 10:
            if (!(transaction.minNonceContextSlot != null && transaction.nonceInfo != null)) {
              _context108.next = 18;
              break;
            }

            nonceInstruction = transaction.nonceInfo.nonceInstruction;
            nonceAccountPubkey = nonceInstruction.keys[0].pubkey;
            _context108.next = 15;
            return connection.confirmTransaction({
              abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,
              minContextSlot: transaction.minNonceContextSlot,
              nonceAccountPubkey: nonceAccountPubkey,
              nonceValue: transaction.nonceInfo.nonce,
              signature: signature
            }, options && options.commitment);

          case 15:
            status = _context108.sent.value;
            _context108.next = 22;
            break;

          case 18:
            if ((options === null || options === void 0 ? void 0 : options.abortSignal) != null) {
              console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');
            }

            _context108.next = 21;
            return connection.confirmTransaction(signature, options && options.commitment);

          case 21:
            status = _context108.sent.value;

          case 22:
            if (!status.err) {
              _context108.next = 24;
              break;
            }

            throw new Error("Transaction ".concat(signature, " failed (").concat(JSON.stringify(status), ")"));

          case 24:
            return _context108.abrupt("return", signature);

          case 25:
          case "end":
            return _context108.stop();
        }
      }, _callee108);
    }));
    return _sendAndConfirmTransaction.apply(this, arguments);
  }

  function sleep(ms) {
    return new Promise(function (resolve) {
      return setTimeout(resolve, ms);
    });
  }
  /**
   * Populate a buffer of instruction data using an InstructionType
   * @internal
   */


  function encodeData(type, fields) {
    var allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);
    var data = Buffer$1.alloc(allocLength);
    var layoutFields = Object.assign({
      instruction: type.index
    }, fields);
    type.layout.encode(layoutFields, data);
    return data;
  }
  /**
   * Decode instruction data buffer using an InstructionType
   * @internal
   */


  function decodeData$1(type, buffer) {
    var data;

    try {
      data = type.layout.decode(buffer);
    } catch (err) {
      throw new Error('invalid instruction; ' + err);
    }

    if (data.instruction !== type.index) {
      throw new Error("invalid instruction; instruction index mismatch ".concat(data.instruction, " != ").concat(type.index));
    }

    return data;
  }
  /**
   * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11
   *
   * @internal
   */


  var FeeCalculatorLayout = nu64('lamportsPerSignature');
  /**
   * Calculator for transaction fees.
   *
   * @deprecated Deprecated since Solana v1.8.0.
   */

  /**
   * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32
   *
   * @internal
   */

  var NonceAccountLayout = struct([u32('version'), u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), struct([FeeCalculatorLayout], 'feeCalculator')]);
  var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
  /**
   * A durable nonce is a 32 byte value encoded as a base58 string.
   */

  /**
   * NonceAccount class
   */

  var NonceAccount = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function NonceAccount(args) {
      _classCallCheck(this, NonceAccount);

      this.authorizedPubkey = void 0;
      this.nonce = void 0;
      this.feeCalculator = void 0;
      this.authorizedPubkey = args.authorizedPubkey;
      this.nonce = args.nonce;
      this.feeCalculator = args.feeCalculator;
    }
    /**
     * Deserialize NonceAccount from the account data.
     *
     * @param buffer account data
     * @return NonceAccount
     */


    _createClass(NonceAccount, null, [{
      key: "fromAccountData",
      value: function fromAccountData(buffer) {
        var nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);
        return new NonceAccount({
          authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),
          nonce: new PublicKey(nonceAccount.nonce).toString(),
          feeCalculator: nonceAccount.feeCalculator
        });
      }
    }]);

    return NonceAccount;
  }();

  var encodeDecode = function encodeDecode(layout) {
    var decode = layout.decode.bind(layout);
    var encode = layout.encode.bind(layout);
    return {
      decode: decode,
      encode: encode
    };
  };

  var bigInt = function bigInt(length) {
    return function (property) {
      var layout = blob$1(length, property);

      var _encodeDecode = encodeDecode(layout),
          encode = _encodeDecode.encode,
          decode = _encodeDecode.decode;

      var bigIntLayout = layout;

      bigIntLayout.decode = function (buffer, offset) {
        var src = decode(buffer, offset);
        return toBigIntLE_1(Buffer$1.from(src));
      };

      bigIntLayout.encode = function (bigInt, buffer, offset) {
        var src = toBufferLE_1(bigInt, length);
        return encode(src, buffer, offset);
      };

      return bigIntLayout;
    };
  };

  var u64 = bigInt(8);
  /**
   * Create account system transaction params
   */

  /**
   * System Instruction class
   */

  var SystemInstruction = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function SystemInstruction() {
      _classCallCheck(this, SystemInstruction);
    }
    /**
     * Decode a system instruction and retrieve the instruction type.
     */


    _createClass(SystemInstruction, null, [{
      key: "decodeInstructionType",
      value: function decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        var instructionTypeLayout = u32('instruction');
        var typeIndex = instructionTypeLayout.decode(instruction.data);
        var type;

        for (var _i9 = 0, _Object$entries = Object.entries(SYSTEM_INSTRUCTION_LAYOUTS); _i9 < _Object$entries.length; _i9++) {
          var _Object$entries$_i2 = _slicedToArray(_Object$entries[_i9], 2),
              ixType = _Object$entries$_i2[0],
              layout = _Object$entries$_i2[1];

          if (layout.index == typeIndex) {
            type = ixType;
            break;
          }
        }

        if (!type) {
          throw new Error('Instruction type incorrect; not a SystemInstruction');
        }

        return type;
      }
      /**
       * Decode a create account system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeCreateAccount",
      value: function decodeCreateAccount(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);

        var _decodeData$ = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data),
            lamports = _decodeData$.lamports,
            space = _decodeData$.space,
            programId = _decodeData$.programId;

        return {
          fromPubkey: instruction.keys[0].pubkey,
          newAccountPubkey: instruction.keys[1].pubkey,
          lamports: lamports,
          space: space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a transfer system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeTransfer",
      value: function decodeTransfer(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);

        var _decodeData$2 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data),
            lamports = _decodeData$2.lamports;

        return {
          fromPubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          lamports: lamports
        };
      }
      /**
       * Decode a transfer with seed system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeTransferWithSeed",
      value: function decodeTransferWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);

        var _decodeData$3 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data),
            lamports = _decodeData$3.lamports,
            seed = _decodeData$3.seed,
            programId = _decodeData$3.programId;

        return {
          fromPubkey: instruction.keys[0].pubkey,
          basePubkey: instruction.keys[1].pubkey,
          toPubkey: instruction.keys[2].pubkey,
          lamports: lamports,
          seed: seed,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an allocate system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeAllocate",
      value: function decodeAllocate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);

        var _decodeData$4 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data),
            space = _decodeData$4.space;

        return {
          accountPubkey: instruction.keys[0].pubkey,
          space: space
        };
      }
      /**
       * Decode an allocate with seed system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeAllocateWithSeed",
      value: function decodeAllocateWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);

        var _decodeData$5 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data),
            base = _decodeData$5.base,
            seed = _decodeData$5.seed,
            space = _decodeData$5.space,
            programId = _decodeData$5.programId;

        return {
          accountPubkey: instruction.keys[0].pubkey,
          basePubkey: new PublicKey(base),
          seed: seed,
          space: space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an assign system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeAssign",
      value: function decodeAssign(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);

        var _decodeData$6 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data),
            programId = _decodeData$6.programId;

        return {
          accountPubkey: instruction.keys[0].pubkey,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode an assign with seed system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeAssignWithSeed",
      value: function decodeAssignWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 1);

        var _decodeData$7 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data),
            base = _decodeData$7.base,
            seed = _decodeData$7.seed,
            programId = _decodeData$7.programId;

        return {
          accountPubkey: instruction.keys[0].pubkey,
          basePubkey: new PublicKey(base),
          seed: seed,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a create account with seed system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeCreateWithSeed",
      value: function decodeCreateWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);

        var _decodeData$8 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data),
            base = _decodeData$8.base,
            seed = _decodeData$8.seed,
            lamports = _decodeData$8.lamports,
            space = _decodeData$8.space,
            programId = _decodeData$8.programId;

        return {
          fromPubkey: instruction.keys[0].pubkey,
          newAccountPubkey: instruction.keys[1].pubkey,
          basePubkey: new PublicKey(base),
          seed: seed,
          lamports: lamports,
          space: space,
          programId: new PublicKey(programId)
        };
      }
      /**
       * Decode a nonce initialize system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeNonceInitialize",
      value: function decodeNonceInitialize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);

        var _decodeData$9 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data),
            authorized = _decodeData$9.authorized;

        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: new PublicKey(authorized)
        };
      }
      /**
       * Decode a nonce advance system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeNonceAdvance",
      value: function decodeNonceAdvance(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);
        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey
        };
      }
      /**
       * Decode a nonce withdraw system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeNonceWithdraw",
      value: function decodeNonceWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 5);

        var _decodeData$10 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data),
            lamports = _decodeData$10.lamports;

        return {
          noncePubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey,
          lamports: lamports
        };
      }
      /**
       * Decode a nonce authorize system instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeNonceAuthorize",
      value: function decodeNonceAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);

        var _decodeData$11 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data),
            authorized = _decodeData$11.authorized;

        return {
          noncePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[1].pubkey,
          newAuthorizedPubkey: new PublicKey(authorized)
        };
      }
      /**
       * @internal
       */

    }, {
      key: "checkProgramId",
      value: function checkProgramId(programId) {
        if (!programId.equals(SystemProgram.programId)) {
          throw new Error('invalid instruction; programId is not SystemProgram');
        }
      }
      /**
       * @internal
       */

    }, {
      key: "checkKeyLength",
      value: function checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
        }
      }
    }]);

    return SystemInstruction;
  }();
  /**
   * An enumeration of valid SystemInstructionType's
   */

  /**
   * An enumeration of valid system InstructionType's
   * @internal
   */


  var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
    Create: {
      index: 0,
      layout: struct([u32('instruction'), ns64('lamports'), ns64('space'), publicKey('programId')])
    },
    Assign: {
      index: 1,
      layout: struct([u32('instruction'), publicKey('programId')])
    },
    Transfer: {
      index: 2,
      layout: struct([u32('instruction'), u64('lamports')])
    },
    CreateWithSeed: {
      index: 3,
      layout: struct([u32('instruction'), publicKey('base'), rustString('seed'), ns64('lamports'), ns64('space'), publicKey('programId')])
    },
    AdvanceNonceAccount: {
      index: 4,
      layout: struct([u32('instruction')])
    },
    WithdrawNonceAccount: {
      index: 5,
      layout: struct([u32('instruction'), ns64('lamports')])
    },
    InitializeNonceAccount: {
      index: 6,
      layout: struct([u32('instruction'), publicKey('authorized')])
    },
    AuthorizeNonceAccount: {
      index: 7,
      layout: struct([u32('instruction'), publicKey('authorized')])
    },
    Allocate: {
      index: 8,
      layout: struct([u32('instruction'), ns64('space')])
    },
    AllocateWithSeed: {
      index: 9,
      layout: struct([u32('instruction'), publicKey('base'), rustString('seed'), ns64('space'), publicKey('programId')])
    },
    AssignWithSeed: {
      index: 10,
      layout: struct([u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])
    },
    TransferWithSeed: {
      index: 11,
      layout: struct([u32('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])
    },
    UpgradeNonceAccount: {
      index: 12,
      layout: struct([u32('instruction')])
    }
  });
  /**
   * Factory class for transactions to interact with the System program
   */

  var SystemProgram = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function SystemProgram() {
      _classCallCheck(this, SystemProgram);
    }
    /**
     * Public key that identifies the System program
     */

    /**
     * Generate a transaction instruction that creates a new account
     */


    _createClass(SystemProgram, null, [{
      key: "createAccount",
      value: function createAccount(params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.Create;
        var data = encodeData(type, {
          lamports: params.lamports,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.newAccountPubkey,
            isSigner: true,
            isWritable: true
          }],
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a transaction instruction that transfers lamports from one account to another
       */

    }, {
      key: "transfer",
      value: function transfer(params) {
        var data;
        var keys;

        if ('basePubkey' in params) {
          var _type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
          data = encodeData(_type, {
            lamports: BigInt(params.lamports),
            seed: params.seed,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.fromPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }];
        } else {
          var _type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
          data = encodeData(_type2, {
            lamports: BigInt(params.lamports)
          });
          keys = [{
            pubkey: params.fromPubkey,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }];
        }

        return new TransactionInstruction({
          keys: keys,
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a transaction instruction that assigns an account to a program
       */

    }, {
      key: "assign",
      value: function assign(params) {
        var data;
        var keys;

        if ('basePubkey' in params) {
          var _type3 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
          data = encodeData(_type3, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }];
        } else {
          var _type4 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
          data = encodeData(_type4, {
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: true,
            isWritable: true
          }];
        }

        return new TransactionInstruction({
          keys: keys,
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a transaction instruction that creates a new account at
       *   an address generated with `from`, a seed, and programId
       */

    }, {
      key: "createAccountWithSeed",
      value: function createAccountWithSeed(params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;
        var data = encodeData(type, {
          base: toBuffer(params.basePubkey.toBuffer()),
          seed: params.seed,
          lamports: params.lamports,
          space: params.space,
          programId: toBuffer(params.programId.toBuffer())
        });
        var keys = [{
          pubkey: params.fromPubkey,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: params.newAccountPubkey,
          isSigner: false,
          isWritable: true
        }];

        if (params.basePubkey != params.fromPubkey) {
          keys.push({
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          });
        }

        return new TransactionInstruction({
          keys: keys,
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a transaction that creates a new Nonce account
       */

    }, {
      key: "createNonceAccount",
      value: function createNonceAccount(params) {
        var transaction = new Transaction$1();

        if ('basePubkey' in params && 'seed' in params) {
          transaction.add(SystemProgram.createAccountWithSeed({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.noncePubkey,
            basePubkey: params.basePubkey,
            seed: params.seed,
            lamports: params.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
          }));
        } else {
          transaction.add(SystemProgram.createAccount({
            fromPubkey: params.fromPubkey,
            newAccountPubkey: params.noncePubkey,
            lamports: params.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
          }));
        }

        var initParams = {
          noncePubkey: params.noncePubkey,
          authorizedPubkey: params.authorizedPubkey
        };
        transaction.add(this.nonceInitialize(initParams));
        return transaction;
      }
      /**
       * Generate an instruction to initialize a Nonce account
       */

    }, {
      key: "nonceInitialize",
      value: function nonceInitialize(params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;
        var data = encodeData(type, {
          authorized: toBuffer(params.authorizedPubkey.toBuffer())
        });
        var instructionData = {
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }],
          programId: this.programId,
          data: data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate an instruction to advance the nonce in a Nonce account
       */

    }, {
      key: "nonceAdvance",
      value: function nonceAdvance(params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;
        var data = encodeData(type);
        var instructionData = {
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data: data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a transaction instruction that withdraws lamports from a Nonce account
       */

    }, {
      key: "nonceWithdraw",
      value: function nonceWithdraw(params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;
        var data = encodeData(type, {
          lamports: params.lamports
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.toPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a transaction instruction that authorizes a new PublicKey as the authority
       * on a Nonce account.
       */

    }, {
      key: "nonceAuthorize",
      value: function nonceAuthorize(params) {
        var type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;
        var data = encodeData(type, {
          authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: params.noncePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a transaction instruction that allocates space in an account without funding
       */

    }, {
      key: "allocate",
      value: function allocate(params) {
        var data;
        var keys;

        if ('basePubkey' in params) {
          var _type5 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
          data = encodeData(_type5, {
            base: toBuffer(params.basePubkey.toBuffer()),
            seed: params.seed,
            space: params.space,
            programId: toBuffer(params.programId.toBuffer())
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: params.basePubkey,
            isSigner: true,
            isWritable: false
          }];
        } else {
          var _type6 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
          data = encodeData(_type6, {
            space: params.space
          });
          keys = [{
            pubkey: params.accountPubkey,
            isSigner: true,
            isWritable: true
          }];
        }

        return new TransactionInstruction({
          keys: keys,
          programId: this.programId,
          data: data
        });
      }
    }]);

    return SystemProgram;
  }();

  SystemProgram.programId = new PublicKey('11111111111111111111111111111111'); // Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the
  // rest of the Transaction fields
  //
  // TODO: replace 300 with a proper constant for the size of the other
  // Transaction fields

  var CHUNK_SIZE$2 = PACKET_DATA_SIZE - 300;
  /**
   * Program loader interface
   */

  var Loader = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function Loader() {
      _classCallCheck(this, Loader);
    }
    /**
     * Amount of program data placed in each load Transaction
     */

    /**
     * Minimum number of signatures required to load a program not including
     * retries
     *
     * Can be used to calculate transaction fees
     */


    _createClass(Loader, null, [{
      key: "getMinNumSignatures",
      value: function getMinNumSignatures(dataLength) {
        return 2 * ( // Every transaction requires two signatures (payer + program)
        Math.ceil(dataLength / Loader.chunkSize) + 1 + // Add one for Create transaction
        1) // Add one for Finalize transaction
        ;
      }
      /**
       * Loads a generic program
       *
       * @param connection The connection to use
       * @param payer System account that pays to load the program
       * @param program Account to load the program into
       * @param programId Public key that identifies the loader
       * @param data Program octets
       * @return true if program was loaded successfully, false if program was already loaded
       */

    }, {
      key: "load",
      value: function () {
        var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(connection, payer, program, programId, data) {
          var balanceNeeded, programInfo, transaction, dataLayout, chunkSize, offset$1, array, transactions, bytes, _data, _transaction, REQUESTS_PER_SECOND, _dataLayout, _data2, _transaction2;

          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return connection.getMinimumBalanceForRentExemption(data.length);

              case 2:
                balanceNeeded = _context5.sent;
                _context5.next = 5;
                return connection.getAccountInfo(program.publicKey, 'confirmed');

              case 5:
                programInfo = _context5.sent;
                transaction = null;

                if (!(programInfo !== null)) {
                  _context5.next = 16;
                  break;
                }

                if (!programInfo.executable) {
                  _context5.next = 11;
                  break;
                }

                console.error('Program load failed, account is already executable');
                return _context5.abrupt("return", false);

              case 11:
                if (programInfo.data.length !== data.length) {
                  transaction = transaction || new Transaction$1();
                  transaction.add(SystemProgram.allocate({
                    accountPubkey: program.publicKey,
                    space: data.length
                  }));
                }

                if (!programInfo.owner.equals(programId)) {
                  transaction = transaction || new Transaction$1();
                  transaction.add(SystemProgram.assign({
                    accountPubkey: program.publicKey,
                    programId: programId
                  }));
                }

                if (programInfo.lamports < balanceNeeded) {
                  transaction = transaction || new Transaction$1();
                  transaction.add(SystemProgram.transfer({
                    fromPubkey: payer.publicKey,
                    toPubkey: program.publicKey,
                    lamports: balanceNeeded - programInfo.lamports
                  }));
                }

                _context5.next = 17;
                break;

              case 16:
                transaction = new Transaction$1().add(SystemProgram.createAccount({
                  fromPubkey: payer.publicKey,
                  newAccountPubkey: program.publicKey,
                  lamports: balanceNeeded > 0 ? balanceNeeded : 1,
                  space: data.length,
                  programId: programId
                }));

              case 17:
                if (!(transaction !== null)) {
                  _context5.next = 20;
                  break;
                }

                _context5.next = 20;
                return sendAndConfirmTransaction(connection, transaction, [payer, program], {
                  commitment: 'confirmed'
                });

              case 20:
                dataLayout = struct([u32('instruction'), u32('offset'), u32('bytesLength'), u32('bytesLengthPadding'), seq$1(u8('byte'), offset(u32(), -8), 'bytes')]);
                chunkSize = Loader.chunkSize;
                offset$1 = 0;
                array = data;
                transactions = [];

              case 25:
                if (!(array.length > 0)) {
                  _context5.next = 39;
                  break;
                }

                bytes = array.slice(0, chunkSize);
                _data = Buffer$1.alloc(chunkSize + 16);
                dataLayout.encode({
                  instruction: 0,
                  // Load instruction
                  offset: offset$1,
                  bytes: bytes,
                  bytesLength: 0,
                  bytesLengthPadding: 0
                }, _data);
                _transaction = new Transaction$1().add({
                  keys: [{
                    pubkey: program.publicKey,
                    isSigner: true,
                    isWritable: true
                  }],
                  programId: programId,
                  data: _data
                });
                transactions.push(sendAndConfirmTransaction(connection, _transaction, [payer, program], {
                  commitment: 'confirmed'
                })); // Delay between sends in an attempt to reduce rate limit errors

                if (!connection._rpcEndpoint.includes('solana.com')) {
                  _context5.next = 35;
                  break;
                }

                REQUESTS_PER_SECOND = 4;
                _context5.next = 35;
                return sleep(1000 / REQUESTS_PER_SECOND);

              case 35:
                offset$1 += chunkSize;
                array = array.slice(chunkSize);
                _context5.next = 25;
                break;

              case 39:
                _context5.next = 41;
                return Promise.all(transactions);

              case 41:
                _dataLayout = struct([u32('instruction')]);
                _data2 = Buffer$1.alloc(_dataLayout.span);

                _dataLayout.encode({
                  instruction: 1 // Finalize instruction

                }, _data2);

                _transaction2 = new Transaction$1().add({
                  keys: [{
                    pubkey: program.publicKey,
                    isSigner: true,
                    isWritable: true
                  }, {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: false,
                    isWritable: false
                  }],
                  programId: programId,
                  data: _data2
                });
                _context5.next = 47;
                return sendAndConfirmTransaction(connection, _transaction2, [payer, program], {
                  commitment: 'confirmed'
                });

              case 47:
                return _context5.abrupt("return", true);

              case 48:
              case "end":
                return _context5.stop();
            }
          }, _callee5);
        }));

        function load(_x13, _x14, _x15, _x16, _x17) {
          return _load.apply(this, arguments);
        }

        return load;
      }()
    }]);

    return Loader;
  }();

  Loader.chunkSize = CHUNK_SIZE$2;
  var BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');
  /**
   * Factory class for transactions to interact with a program loader
   */

  var BpfLoader = /*#__PURE__*/function () {
    function BpfLoader() {
      _classCallCheck(this, BpfLoader);
    }

    _createClass(BpfLoader, null, [{
      key: "getMinNumSignatures",
      value:
      /**
       * Minimum number of signatures required to load a program not including
       * retries
       *
       * Can be used to calculate transaction fees
       */
      function getMinNumSignatures(dataLength) {
        return Loader.getMinNumSignatures(dataLength);
      }
      /**
       * Load a SBF program
       *
       * @param connection The connection to use
       * @param payer Account that will pay program loading fees
       * @param program Account to load the program into
       * @param elf The entire ELF containing the SBF program
       * @param loaderProgramId The program id of the BPF loader to use
       * @return true if program was loaded successfully, false if program was already loaded
       */

    }, {
      key: "load",
      value: function load(connection, payer, program, elf, loaderProgramId) {
        return Loader.load(connection, payer, program, loaderProgramId, elf);
      }
    }]);

    return BpfLoader;
  }();

  var objToString = Object.prototype.toString;

  var objKeys = Object.keys || function (obj) {
    var keys = [];

    for (var name in obj) {
      keys.push(name);
    }

    return keys;
  };

  function stringify(val, isArrayProp) {
    var i, max, str, keys, key, propVal, toStr;

    if (val === true) {
      return "true";
    }

    if (val === false) {
      return "false";
    }

    switch (_typeof$1(val)) {
      case "object":
        if (val === null) {
          return null;
        } else if (val.toJSON && typeof val.toJSON === "function") {
          return stringify(val.toJSON(), isArrayProp);
        } else {
          toStr = objToString.call(val);

          if (toStr === "[object Array]") {
            str = '[';
            max = val.length - 1;

            for (i = 0; i < max; i++) {
              str += stringify(val[i], true) + ',';
            }

            if (max > -1) {
              str += stringify(val[i], true);
            }

            return str + ']';
          } else if (toStr === "[object Object]") {
            // only object is left
            keys = objKeys(val).sort();
            max = keys.length;
            str = "";
            i = 0;

            while (i < max) {
              key = keys[i];
              propVal = stringify(val[key], false);

              if (propVal !== undefined) {
                if (str) {
                  str += ',';
                }

                str += JSON.stringify(key) + ':' + propVal;
              }

              i++;
            }

            return '{' + str + '}';
          } else {
            return JSON.stringify(val);
          }
        }

      case "function":
      case "undefined":
        return isArrayProp ? null : undefined;

      case "string":
        return JSON.stringify(val);

      default:
        return isFinite(val) ? val : null;
    }
  }

  var fastStableStringify = function fastStableStringify(val) {
    var returnVal = stringify(val, false);

    if (returnVal !== undefined) {
      return '' + returnVal;
    }
  };

  var fastStableStringify$1 = fastStableStringify;
  var MINIMUM_SLOT_PER_EPOCH = 32; // Returns the number of trailing zeros in the binary representation of self.

  function trailingZeros(n) {
    var trailingZeros = 0;

    while (n > 1) {
      n /= 2;
      trailingZeros++;
    }

    return trailingZeros;
  } // Returns the smallest power of two greater than or equal to n


  function nextPowerOfTwo(n) {
    if (n === 0) return 1;
    n--;
    n |= n >> 1;
    n |= n >> 2;
    n |= n >> 4;
    n |= n >> 8;
    n |= n >> 16;
    n |= n >> 32;
    return n + 1;
  }
  /**
   * Epoch schedule
   * (see https://docs.solana.com/terminology#epoch)
   * Can be retrieved with the {@link Connection.getEpochSchedule} method
   */


  var EpochSchedule = /*#__PURE__*/function () {
    /** The maximum number of slots in each epoch */

    /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */

    /** Indicates whether epochs start short and grow */

    /** The first epoch with `slotsPerEpoch` slots */

    /** The first slot of `firstNormalEpoch` */
    function EpochSchedule(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {
      _classCallCheck(this, EpochSchedule);

      this.slotsPerEpoch = void 0;
      this.leaderScheduleSlotOffset = void 0;
      this.warmup = void 0;
      this.firstNormalEpoch = void 0;
      this.firstNormalSlot = void 0;
      this.slotsPerEpoch = slotsPerEpoch;
      this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;
      this.warmup = warmup;
      this.firstNormalEpoch = firstNormalEpoch;
      this.firstNormalSlot = firstNormalSlot;
    }

    _createClass(EpochSchedule, [{
      key: "getEpoch",
      value: function getEpoch(slot) {
        return this.getEpochAndSlotIndex(slot)[0];
      }
    }, {
      key: "getEpochAndSlotIndex",
      value: function getEpochAndSlotIndex(slot) {
        if (slot < this.firstNormalSlot) {
          var epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;
          var epochLen = this.getSlotsInEpoch(epoch);
          var slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);
          return [epoch, slotIndex];
        } else {
          var normalSlotIndex = slot - this.firstNormalSlot;
          var normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);

          var _epoch = this.firstNormalEpoch + normalEpochIndex;

          var _slotIndex = normalSlotIndex % this.slotsPerEpoch;

          return [_epoch, _slotIndex];
        }
      }
    }, {
      key: "getFirstSlotInEpoch",
      value: function getFirstSlotInEpoch(epoch) {
        if (epoch <= this.firstNormalEpoch) {
          return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;
        } else {
          return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;
        }
      }
    }, {
      key: "getLastSlotInEpoch",
      value: function getLastSlotInEpoch(epoch) {
        return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;
      }
    }, {
      key: "getSlotsInEpoch",
      value: function getSlotsInEpoch(epoch) {
        if (epoch < this.firstNormalEpoch) {
          return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));
        } else {
          return this.slotsPerEpoch;
        }
      }
    }]);

    return EpochSchedule;
  }();

  var SendTransactionError = /*#__PURE__*/function (_Error4) {
    _inherits(SendTransactionError, _Error4);

    var _super6 = _createSuper(SendTransactionError);

    function SendTransactionError(message, logs) {
      var _this12;

      _classCallCheck(this, SendTransactionError);

      _this12 = _super6.call(this, message);
      _this12.logs = void 0;
      _this12.logs = logs;
      return _this12;
    }

    return _createClass(SendTransactionError);
  }( /*#__PURE__*/_wrapNativeSuper(Error)); // Keep in sync with client/src/rpc_custom_errors.rs
  // Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/


  var SolanaJSONRPCErrorCode = {
    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
    JSON_RPC_SCAN_ERROR: -32012,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
  };

  var SolanaJSONRPCError = /*#__PURE__*/function (_Error5) {
    _inherits(SolanaJSONRPCError, _Error5);

    var _super7 = _createSuper(SolanaJSONRPCError);

    function SolanaJSONRPCError(_ref21, customMessage) {
      var _this13;

      var code = _ref21.code,
          message = _ref21.message,
          data = _ref21.data;

      _classCallCheck(this, SolanaJSONRPCError);

      _this13 = _super7.call(this, customMessage != null ? "".concat(customMessage, ": ").concat(message) : message);
      _this13.code = void 0;
      _this13.data = void 0;
      _this13.code = code;
      _this13.data = data;
      _this13.name = 'SolanaJSONRPCError';
      return _this13;
    }

    return _createClass(SolanaJSONRPCError);
  }( /*#__PURE__*/_wrapNativeSuper(Error));

  var fetchImpl = globalThis.fetch;

  var RpcWebSocketClient = /*#__PURE__*/function (_RpcWebSocketCommonCl) {
    _inherits(RpcWebSocketClient, _RpcWebSocketCommonCl);

    var _super8 = _createSuper(RpcWebSocketClient);

    function RpcWebSocketClient(address, options, generate_request_id) {
      var _this14;

      _classCallCheck(this, RpcWebSocketClient);

      var webSocketFactory = function webSocketFactory(url) {
        var rpc = createRpc(url, _objectSpread2({
          autoconnect: true,
          max_reconnects: 5,
          reconnect: true,
          reconnect_interval: 1000
        }, options));

        if ('socket' in rpc) {
          _this14.underlyingSocket = rpc.socket;
        } else {
          _this14.underlyingSocket = rpc;
        }

        return rpc;
      };

      _this14 = _super8.call(this, webSocketFactory, address, options, generate_request_id);
      _this14.underlyingSocket = void 0;
      return _this14;
    }

    _createClass(RpcWebSocketClient, [{
      key: "call",
      value: function call() {
        var _this$underlyingSocke;

        var readyState = (_this$underlyingSocke = this.underlyingSocket) === null || _this$underlyingSocke === void 0 ? void 0 : _this$underlyingSocke.readyState;

        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }

        if (readyState === 1
        /* WebSocket.OPEN */
        ) {
          var _get2;

          return (_get2 = _get(_getPrototypeOf(RpcWebSocketClient.prototype), "call", this)).call.apply(_get2, [this].concat(args));
        }

        return Promise.reject(new Error('Tried to call a JSON-RPC method `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
      }
    }, {
      key: "notify",
      value: function notify() {
        var _this$underlyingSocke2;

        var readyState = (_this$underlyingSocke2 = this.underlyingSocket) === null || _this$underlyingSocke2 === void 0 ? void 0 : _this$underlyingSocke2.readyState;

        for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          args[_key7] = arguments[_key7];
        }

        if (readyState === 1
        /* WebSocket.OPEN */
        ) {
          var _get3;

          return (_get3 = _get(_getPrototypeOf(RpcWebSocketClient.prototype), "notify", this)).call.apply(_get3, [this].concat(args));
        }

        return Promise.reject(new Error('Tried to send a JSON-RPC notification `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));
      }
    }]);

    return RpcWebSocketClient;
  }(RpcWebSocketCommonClient); // TODO: These constants should be removed in favor of reading them out of a
  // Syscall account

  /**
   * @internal
   */


  var NUM_TICKS_PER_SECOND = 160;
  /**
   * @internal
   */

  var DEFAULT_TICKS_PER_SLOT = 64;
  /**
   * @internal
   */

  var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;
  /**
   * @internal
   */

  var MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;
  /**
   * @internal
   */

  /**
   * Decode account data buffer using an AccountType
   * @internal
   */

  function decodeData(type, data) {
    var decoded;

    try {
      decoded = type.layout.decode(data);
    } catch (err) {
      throw new Error('invalid instruction; ' + err);
    }

    if (decoded.typeIndex !== type.index) {
      throw new Error("invalid account data; account type mismatch ".concat(decoded.typeIndex, " != ").concat(type.index));
    }

    return decoded;
  } /// The serialized size of lookup table metadata


  var LOOKUP_TABLE_META_SIZE = 56;

  var AddressLookupTableAccount = /*#__PURE__*/function () {
    function AddressLookupTableAccount(args) {
      _classCallCheck(this, AddressLookupTableAccount);

      this.key = void 0;
      this.state = void 0;
      this.key = args.key;
      this.state = args.state;
    }

    _createClass(AddressLookupTableAccount, [{
      key: "isActive",
      value: function isActive() {
        var U64_MAX = BigInt('0xffffffffffffffff');
        return this.state.deactivationSlot === U64_MAX;
      }
    }], [{
      key: "deserialize",
      value: function deserialize(accountData) {
        var meta = decodeData(LookupTableMetaLayout, accountData);
        var serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;
        assert(serializedAddressesLen >= 0, 'lookup table is invalid');
        assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');
        var numSerializedAddresses = serializedAddressesLen / 32;

        var _BufferLayout$struct$ = struct([seq$1(publicKey(), numSerializedAddresses, 'addresses')]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE)),
            addresses = _BufferLayout$struct$.addresses;

        return {
          deactivationSlot: meta.deactivationSlot,
          lastExtendedSlot: meta.lastExtendedSlot,
          lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,
          authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,
          addresses: addresses.map(function (address) {
            return new PublicKey(address);
          })
        };
      }
    }]);

    return AddressLookupTableAccount;
  }();

  var LookupTableMetaLayout = {
    index: 1,
    layout: struct([u32('typeIndex'), u64('deactivationSlot'), nu64('lastExtendedSlot'), u8('lastExtendedStartIndex'), u8(), // option
    seq$1(publicKey(), offset(u8(), -1), 'authority')])
  };
  var URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;

  function makeWebsocketUrl(endpoint) {
    var matches = endpoint.match(URL_RE);

    if (matches == null) {
      throw TypeError("Failed to validate endpoint URL `".concat(endpoint, "`"));
    }

    var _matches = _slicedToArray(matches, 4);
        _matches[0];
        var // eslint-disable-line @typescript-eslint/no-unused-vars
    hostish = _matches[1],
        portWithColon = _matches[2],
        rest = _matches[3];

    var protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';
    var startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);
    var websocketPort = // Only shift the port by +1 as a convention for ws(s) only if given endpoint
    // is explictly specifying the endpoint port (HTTP-based RPC), assuming
    // we're directly trying to connect to solana-validator's ws listening port.
    // When the endpoint omits the port, we're connecting to the protocol
    // default ports: http(80) or https(443) and it's assumed we're behind a reverse
    // proxy which manages WebSocket upgrade and backend port redirection.
    startPort == null ? '' : ":".concat(startPort + 1);
    return "".concat(protocol, "//").concat(hostish).concat(websocketPort).concat(rest);
  }

  var PublicKeyFromString = coerce(instance(PublicKey), string(), function (value) {
    return new PublicKey(value);
  });
  var RawAccountDataResult = tuple([string(), literal('base64')]);
  var BufferFromRawAccountData = coerce(instance(Buffer$1), RawAccountDataResult, function (value) {
    return Buffer$1.from(value[0], 'base64');
  });
  /**
   * Attempt to use a recent blockhash for up to 30 seconds
   * @internal
   */

  var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;
  /**
   * HACK.
   * Copied from rpc-websockets/dist/lib/client.
   * Otherwise, `yarn build` fails with:
   * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d
   */

  /* @internal */

  function assertEndpointUrl(putativeUrl) {
    if (/^https?:/.test(putativeUrl) === false) {
      throw new TypeError('Endpoint URL must start with `http:` or `https:`.');
    }

    return putativeUrl;
  }
  /** @internal */


  function extractCommitmentFromConfig(commitmentOrConfig) {
    var commitment;
    var config;

    if (typeof commitmentOrConfig === 'string') {
      commitment = commitmentOrConfig;
    } else if (commitmentOrConfig) {
      var specifiedCommitment = commitmentOrConfig.commitment,
          specifiedConfig = _objectWithoutProperties(commitmentOrConfig, _excluded);

      commitment = specifiedCommitment;
      config = specifiedConfig;
    }

    return {
      commitment: commitment,
      config: config
    };
  }
  /**
   * @internal
   */


  function createRpcResult(result) {
    return union([type({
      jsonrpc: literal('2.0'),
      id: string(),
      result: result
    }), type({
      jsonrpc: literal('2.0'),
      id: string(),
      error: type({
        code: unknown(),
        message: string(),
        data: optional(any())
      })
    })]);
  }

  var UnknownRpcResult = createRpcResult(unknown());
  /**
   * @internal
   */

  function jsonRpcResult(schema) {
    return coerce(createRpcResult(schema), UnknownRpcResult, function (value) {
      if ('error' in value) {
        return value;
      } else {
        return _objectSpread2(_objectSpread2({}, value), {}, {
          result: _create(value.result, schema)
        });
      }
    });
  }
  /**
   * @internal
   */


  function jsonRpcResultAndContext(value) {
    return jsonRpcResult(type({
      context: type({
        slot: number()
      }),
      value: value
    }));
  }
  /**
   * @internal
   */


  function notificationResultAndContext(value) {
    return type({
      context: type({
        slot: number()
      }),
      value: value
    });
  }
  /**
   * @internal
   */


  function versionedMessageFromResponse(version, response) {
    if (version === 0) {
      return new MessageV0({
        header: response.header,
        staticAccountKeys: response.accountKeys.map(function (accountKey) {
          return new PublicKey(accountKey);
        }),
        recentBlockhash: response.recentBlockhash,
        compiledInstructions: response.instructions.map(function (ix) {
          return {
            programIdIndex: ix.programIdIndex,
            accountKeyIndexes: ix.accounts,
            data: bs58$1.decode(ix.data)
          };
        }),
        addressTableLookups: response.addressTableLookups
      });
    } else {
      return new Message(response);
    }
  }
  /**
   * The level of commitment desired when querying state
   * <pre>
   *   'processed': Query the most recent block which has reached 1 confirmation by the connected node
   *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster
   *   'finalized': Query the most recent block which has been finalized by the cluster
   * </pre>
   */


  var GetInflationGovernorResult = type({
    foundation: number(),
    foundationTerm: number(),
    initial: number(),
    taper: number(),
    terminal: number()
  });
  /**
   * The inflation reward for an epoch
   */

  /**
   * Expected JSON RPC response for the "getInflationReward" message
   */

  var GetInflationRewardResult = jsonRpcResult(array(nullable(type({
    epoch: number(),
    effectiveSlot: number(),
    amount: number(),
    postBalance: number(),
    commission: optional(nullable(number()))
  }))));
  /**
   * Expected JSON RPC response for the "getRecentPrioritizationFees" message
   */

  var GetRecentPrioritizationFeesResult = array(type({
    slot: number(),
    prioritizationFee: number()
  }));
  /**
   * Expected JSON RPC response for the "getInflationRate" message
   */

  var GetInflationRateResult = type({
    total: number(),
    validator: number(),
    foundation: number(),
    epoch: number()
  });
  /**
   * Information about the current epoch
   */

  var GetEpochInfoResult = type({
    epoch: number(),
    slotIndex: number(),
    slotsInEpoch: number(),
    absoluteSlot: number(),
    blockHeight: optional(number()),
    transactionCount: optional(number())
  });
  var GetEpochScheduleResult = type({
    slotsPerEpoch: number(),
    leaderScheduleSlotOffset: number(),
    warmup: _boolean(),
    firstNormalEpoch: number(),
    firstNormalSlot: number()
  });
  /**
   * Leader schedule
   * (see https://docs.solana.com/terminology#leader-schedule)
   */

  var GetLeaderScheduleResult = record(string(), array(number()));
  /**
   * Transaction error or null
   */

  var TransactionErrorResult = nullable(union([type({}), string()]));
  /**
   * Signature status for a transaction
   */

  var SignatureStatusResult = type({
    err: TransactionErrorResult
  });
  /**
   * Transaction signature received notification
   */

  var SignatureReceivedResult = literal('receivedSignature');
  /**
   * Version info for a node
   */

  var VersionResult = type({
    'solana-core': string(),
    'feature-set': optional(number())
  });
  var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
    err: nullable(union([type({}), string()])),
    logs: nullable(array(string())),
    accounts: optional(nullable(array(nullable(type({
      executable: _boolean(),
      owner: string(),
      lamports: number(),
      data: array(string()),
      rentEpoch: optional(number())
    }))))),
    unitsConsumed: optional(number()),
    returnData: optional(nullable(type({
      programId: string(),
      data: tuple([string(), literal('base64')])
    })))
  }));
  /**
   * Expected JSON RPC response for the "getBlockProduction" message
   */

  var BlockProductionResponseStruct = jsonRpcResultAndContext(type({
    byIdentity: record(string(), array(number())),
    range: type({
      firstSlot: number(),
      lastSlot: number()
    })
  }));
  /**
   * A performance sample
   */

  function createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {
    var fetch = customFetch ? customFetch : fetchImpl;
    var agent;
    {
      if (httpAgent != null) {
        console.warn('You have supplied an `httpAgent` when creating a `Connection` in a browser environment.' + 'It has been ignored; `httpAgent` is only used in Node environments.');
      }
    }
    var fetchWithMiddleware;

    if (fetchMiddleware) {
      fetchWithMiddleware = /*#__PURE__*/function () {
        var _ref22 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(info, init) {
          var modifiedFetchArgs;
          return _regeneratorRuntime().wrap(function _callee6$(_context6) {
            while (1) switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return new Promise(function (resolve, reject) {
                  try {
                    fetchMiddleware(info, init, function (modifiedInfo, modifiedInit) {
                      return resolve([modifiedInfo, modifiedInit]);
                    });
                  } catch (error) {
                    reject(error);
                  }
                });

              case 2:
                modifiedFetchArgs = _context6.sent;
                _context6.next = 5;
                return fetch.apply(void 0, _toConsumableArray(modifiedFetchArgs));

              case 5:
                return _context6.abrupt("return", _context6.sent);

              case 6:
              case "end":
                return _context6.stop();
            }
          }, _callee6);
        }));

        return function fetchWithMiddleware(_x18, _x19) {
          return _ref22.apply(this, arguments);
        };
      }();
    }

    var clientBrowser = new RpcClient( /*#__PURE__*/function () {
      var _ref23 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request, callback) {
        var options, too_many_requests_retries, res, waitTime, text;
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              options = {
                method: 'POST',
                body: request,
                agent: agent,
                headers: Object.assign({
                  'Content-Type': 'application/json'
                }, httpHeaders || {}, COMMON_HTTP_HEADERS)
              };
              _context7.prev = 1;
              too_many_requests_retries = 5;
              waitTime = 500;

            case 4:
              if (!fetchWithMiddleware) {
                _context7.next = 10;
                break;
              }

              _context7.next = 7;
              return fetchWithMiddleware(url, options);

            case 7:
              res = _context7.sent;
              _context7.next = 13;
              break;

            case 10:
              _context7.next = 12;
              return fetch(url, options);

            case 12:
              res = _context7.sent;

            case 13:
              if (!(res.status !== 429
              /* Too many requests */
              )) {
                _context7.next = 15;
                break;
              }

              return _context7.abrupt("break", 26);

            case 15:
              if (!(disableRetryOnRateLimit === true)) {
                _context7.next = 17;
                break;
              }

              return _context7.abrupt("break", 26);

            case 17:
              too_many_requests_retries -= 1;

              if (!(too_many_requests_retries === 0)) {
                _context7.next = 20;
                break;
              }

              return _context7.abrupt("break", 26);

            case 20:
              console.log("Server responded with ".concat(res.status, " ").concat(res.statusText, ".  Retrying after ").concat(waitTime, "ms delay..."));
              _context7.next = 23;
              return sleep(waitTime);

            case 23:
              waitTime *= 2;

            case 24:
              _context7.next = 4;
              break;

            case 26:
              _context7.next = 28;
              return res.text();

            case 28:
              text = _context7.sent;

              if (res.ok) {
                callback(null, text);
              } else {
                callback(new Error("".concat(res.status, " ").concat(res.statusText, ": ").concat(text)));
              }

              _context7.next = 35;
              break;

            case 32:
              _context7.prev = 32;
              _context7.t0 = _context7["catch"](1);
              if (_context7.t0 instanceof Error) callback(_context7.t0);

            case 35:
            case "end":
              return _context7.stop();
          }
        }, _callee7, null, [[1, 32]]);
      }));

      return function (_x20, _x21) {
        return _ref23.apply(this, arguments);
      };
    }(), {});
    return clientBrowser;
  }

  function createRpcRequest(client) {
    return function (method, args) {
      return new Promise(function (resolve, reject) {
        client.request(method, args, function (err, response) {
          if (err) {
            reject(err);
            return;
          }

          resolve(response);
        });
      });
    };
  }

  function createRpcBatchRequest(client) {
    return function (requests) {
      return new Promise(function (resolve, reject) {
        // Do nothing if requests is empty
        if (requests.length === 0) resolve([]);
        var batch = requests.map(function (params) {
          return client.request(params.methodName, params.args);
        });
        client.request(batch, function (err, response) {
          if (err) {
            reject(err);
            return;
          }

          resolve(response);
        });
      });
    };
  }
  /**
   * Expected JSON RPC response for the "getInflationGovernor" message
   */


  var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);
  /**
   * Expected JSON RPC response for the "getInflationRate" message
   */

  var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);
  /**
   * Expected JSON RPC response for the "getRecentPrioritizationFees" message
   */

  var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);
  /**
   * Expected JSON RPC response for the "getEpochInfo" message
   */

  var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);
  /**
   * Expected JSON RPC response for the "getEpochSchedule" message
   */

  var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);
  /**
   * Expected JSON RPC response for the "getLeaderSchedule" message
   */

  var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);
  /**
   * Expected JSON RPC response for the "minimumLedgerSlot" and "getFirstAvailableBlock" messages
   */

  var SlotRpcResult = jsonRpcResult(number());
  /**
   * Supply
   */

  /**
   * Expected JSON RPC response for the "getSupply" message
   */

  var GetSupplyRpcResult = jsonRpcResultAndContext(type({
    total: number(),
    circulating: number(),
    nonCirculating: number(),
    nonCirculatingAccounts: array(PublicKeyFromString)
  }));
  /**
   * Token amount object which returns a token amount in different formats
   * for various client use cases.
   */

  /**
   * Expected JSON RPC structure for token amounts
   */

  var TokenAmountResult = type({
    amount: string(),
    uiAmount: nullable(number()),
    decimals: number(),
    uiAmountString: optional(string())
  });
  /**
   * Token address and balance.
   */

  /**
   * Expected JSON RPC response for the "getTokenLargestAccounts" message
   */

  var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({
    address: PublicKeyFromString,
    amount: string(),
    uiAmount: nullable(number()),
    decimals: number(),
    uiAmountString: optional(string())
  })));
  /**
   * Expected JSON RPC response for the "getTokenAccountsByOwner" message
   */

  var GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
    pubkey: PublicKeyFromString,
    account: type({
      executable: _boolean(),
      owner: PublicKeyFromString,
      lamports: number(),
      data: BufferFromRawAccountData,
      rentEpoch: number()
    })
  })));
  var ParsedAccountDataResult = type({
    program: string(),
    parsed: unknown(),
    space: number()
  });
  /**
   * Expected JSON RPC response for the "getTokenAccountsByOwner" message with parsed data
   */

  var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({
    pubkey: PublicKeyFromString,
    account: type({
      executable: _boolean(),
      owner: PublicKeyFromString,
      lamports: number(),
      data: ParsedAccountDataResult,
      rentEpoch: number()
    })
  })));
  /**
   * Pair of an account address and its balance
   */

  /**
   * Expected JSON RPC response for the "getLargestAccounts" message
   */

  var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({
    lamports: number(),
    address: PublicKeyFromString
  })));
  /**
   * @internal
   */

  var AccountInfoResult = type({
    executable: _boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: BufferFromRawAccountData,
    rentEpoch: number()
  });
  /**
   * @internal
   */

  var KeyedAccountInfoResult = type({
    pubkey: PublicKeyFromString,
    account: AccountInfoResult
  });
  var ParsedOrRawAccountData = coerce(union([instance(Buffer$1), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), function (value) {
    if (Array.isArray(value)) {
      return _create(value, BufferFromRawAccountData);
    } else {
      return value;
    }
  });
  /**
   * @internal
   */

  var ParsedAccountInfoResult = type({
    executable: _boolean(),
    owner: PublicKeyFromString,
    lamports: number(),
    data: ParsedOrRawAccountData,
    rentEpoch: number()
  });
  var KeyedParsedAccountInfoResult = type({
    pubkey: PublicKeyFromString,
    account: ParsedAccountInfoResult
  });
  /**
   * @internal
   */

  var StakeActivationResult = type({
    state: union([literal('active'), literal('inactive'), literal('activating'), literal('deactivating')]),
    active: number(),
    inactive: number()
  });
  /**
   * Expected JSON RPC response for the "getConfirmedSignaturesForAddress2" message
   */

  var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({
    signature: string(),
    slot: number(),
    err: TransactionErrorResult,
    memo: nullable(string()),
    blockTime: optional(nullable(number()))
  })));
  /**
   * Expected JSON RPC response for the "getSignaturesForAddress" message
   */

  var GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({
    signature: string(),
    slot: number(),
    err: TransactionErrorResult,
    memo: nullable(string()),
    blockTime: optional(nullable(number()))
  })));
  /***
   * Expected JSON RPC response for the "accountNotification" message
   */

  var AccountNotificationResult = type({
    subscription: number(),
    result: notificationResultAndContext(AccountInfoResult)
  });
  /**
   * @internal
   */

  var ProgramAccountInfoResult = type({
    pubkey: PublicKeyFromString,
    account: AccountInfoResult
  });
  /***
   * Expected JSON RPC response for the "programNotification" message
   */

  var ProgramAccountNotificationResult = type({
    subscription: number(),
    result: notificationResultAndContext(ProgramAccountInfoResult)
  });
  /**
   * @internal
   */

  var SlotInfoResult = type({
    parent: number(),
    slot: number(),
    root: number()
  });
  /**
   * Expected JSON RPC response for the "slotNotification" message
   */

  var SlotNotificationResult = type({
    subscription: number(),
    result: SlotInfoResult
  });
  /**
   * Slot updates which can be used for tracking the live progress of a cluster.
   * - `"firstShredReceived"`: connected node received the first shred of a block.
   * Indicates that a new block that is being produced.
   * - `"completed"`: connected node has received all shreds of a block. Indicates
   * a block was recently produced.
   * - `"optimisticConfirmation"`: block was optimistically confirmed by the
   * cluster. It is not guaranteed that an optimistic confirmation notification
   * will be sent for every finalized blocks.
   * - `"root"`: the connected node rooted this block.
   * - `"createdBank"`: the connected node has started validating this block.
   * - `"frozen"`: the connected node has validated this block.
   * - `"dead"`: the connected node failed to validate this block.
   */

  /**
   * @internal
   */

  var SlotUpdateResult = union([type({
    type: union([literal('firstShredReceived'), literal('completed'), literal('optimisticConfirmation'), literal('root')]),
    slot: number(),
    timestamp: number()
  }), type({
    type: literal('createdBank'),
    parent: number(),
    slot: number(),
    timestamp: number()
  }), type({
    type: literal('frozen'),
    slot: number(),
    timestamp: number(),
    stats: type({
      numTransactionEntries: number(),
      numSuccessfulTransactions: number(),
      numFailedTransactions: number(),
      maxTransactionsPerEntry: number()
    })
  }), type({
    type: literal('dead'),
    slot: number(),
    timestamp: number(),
    err: string()
  })]);
  /**
   * Expected JSON RPC response for the "slotsUpdatesNotification" message
   */

  var SlotUpdateNotificationResult = type({
    subscription: number(),
    result: SlotUpdateResult
  });
  /**
   * Expected JSON RPC response for the "signatureNotification" message
   */

  var SignatureNotificationResult = type({
    subscription: number(),
    result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))
  });
  /**
   * Expected JSON RPC response for the "rootNotification" message
   */

  var RootNotificationResult = type({
    subscription: number(),
    result: number()
  });
  var ContactInfoResult = type({
    pubkey: string(),
    gossip: nullable(string()),
    tpu: nullable(string()),
    rpc: nullable(string()),
    version: nullable(string())
  });
  var VoteAccountInfoResult = type({
    votePubkey: string(),
    nodePubkey: string(),
    activatedStake: number(),
    epochVoteAccount: _boolean(),
    epochCredits: array(tuple([number(), number(), number()])),
    commission: number(),
    lastVote: number(),
    rootSlot: nullable(number())
  });
  /**
   * Expected JSON RPC response for the "getVoteAccounts" message
   */

  var GetVoteAccounts = jsonRpcResult(type({
    current: array(VoteAccountInfoResult),
    delinquent: array(VoteAccountInfoResult)
  }));
  var ConfirmationStatus = union([literal('processed'), literal('confirmed'), literal('finalized')]);
  var SignatureStatusResponse = type({
    slot: number(),
    confirmations: nullable(number()),
    err: TransactionErrorResult,
    confirmationStatus: optional(ConfirmationStatus)
  });
  /**
   * Expected JSON RPC response for the "getSignatureStatuses" message
   */

  var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));
  /**
   * Expected JSON RPC response for the "getMinimumBalanceForRentExemption" message
   */

  var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());
  var AddressTableLookupStruct = type({
    accountKey: PublicKeyFromString,
    writableIndexes: array(number()),
    readonlyIndexes: array(number())
  });
  var ConfirmedTransactionResult = type({
    signatures: array(string()),
    message: type({
      accountKeys: array(string()),
      header: type({
        numRequiredSignatures: number(),
        numReadonlySignedAccounts: number(),
        numReadonlyUnsignedAccounts: number()
      }),
      instructions: array(type({
        accounts: array(number()),
        data: string(),
        programIdIndex: number()
      })),
      recentBlockhash: string(),
      addressTableLookups: optional(array(AddressTableLookupStruct))
    })
  });
  var AnnotatedAccountKey = type({
    pubkey: PublicKeyFromString,
    signer: _boolean(),
    writable: _boolean(),
    source: optional(union([literal('transaction'), literal('lookupTable')]))
  });
  var ConfirmedTransactionAccountsModeResult = type({
    accountKeys: array(AnnotatedAccountKey),
    signatures: array(string())
  });
  var ParsedInstructionResult = type({
    parsed: unknown(),
    program: string(),
    programId: PublicKeyFromString
  });
  var RawInstructionResult = type({
    accounts: array(PublicKeyFromString),
    data: string(),
    programId: PublicKeyFromString
  });
  var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);
  var UnknownInstructionResult = union([type({
    parsed: unknown(),
    program: string(),
    programId: string()
  }), type({
    accounts: array(string()),
    data: string(),
    programId: string()
  })]);
  var ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, function (value) {
    if ('accounts' in value) {
      return _create(value, RawInstructionResult);
    } else {
      return _create(value, ParsedInstructionResult);
    }
  });
  /**
   * @internal
   */

  var ParsedConfirmedTransactionResult = type({
    signatures: array(string()),
    message: type({
      accountKeys: array(AnnotatedAccountKey),
      instructions: array(ParsedOrRawInstruction),
      recentBlockhash: string(),
      addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))
    })
  });
  var TokenBalanceResult = type({
    accountIndex: number(),
    mint: string(),
    owner: optional(string()),
    uiTokenAmount: TokenAmountResult
  });
  var LoadedAddressesResult = type({
    writable: array(PublicKeyFromString),
    readonly: array(PublicKeyFromString)
  });
  /**
   * @internal
   */

  var ConfirmedTransactionMetaResult = type({
    err: TransactionErrorResult,
    fee: number(),
    innerInstructions: optional(nullable(array(type({
      index: number(),
      instructions: array(type({
        accounts: array(number()),
        data: string(),
        programIdIndex: number()
      }))
    })))),
    preBalances: array(number()),
    postBalances: array(number()),
    logMessages: optional(nullable(array(string()))),
    preTokenBalances: optional(nullable(array(TokenBalanceResult))),
    postTokenBalances: optional(nullable(array(TokenBalanceResult))),
    loadedAddresses: optional(LoadedAddressesResult),
    computeUnitsConsumed: optional(number())
  });
  /**
   * @internal
   */

  var ParsedConfirmedTransactionMetaResult = type({
    err: TransactionErrorResult,
    fee: number(),
    innerInstructions: optional(nullable(array(type({
      index: number(),
      instructions: array(ParsedOrRawInstruction)
    })))),
    preBalances: array(number()),
    postBalances: array(number()),
    logMessages: optional(nullable(array(string()))),
    preTokenBalances: optional(nullable(array(TokenBalanceResult))),
    postTokenBalances: optional(nullable(array(TokenBalanceResult))),
    loadedAddresses: optional(LoadedAddressesResult),
    computeUnitsConsumed: optional(number())
  });
  var TransactionVersionStruct = union([literal(0), literal('legacy')]);
  /** @internal */

  var RewardsResult = type({
    pubkey: string(),
    lamports: number(),
    postBalance: nullable(number()),
    rewardType: nullable(string()),
    commission: optional(nullable(number()))
  });
  /**
   * Expected JSON RPC response for the "getBlock" message
   */

  var GetBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
      transaction: ConfirmedTransactionResult,
      meta: nullable(ConfirmedTransactionMetaResult),
      version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  /**
   * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `none`
   */

  var GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  /**
   * Expected JSON RPC response for the "getBlock" message when `transactionDetails` is `accounts`
   */

  var GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
      transaction: ConfirmedTransactionAccountsModeResult,
      meta: nullable(ConfirmedTransactionMetaResult),
      version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  /**
   * Expected parsed JSON RPC response for the "getBlock" message
   */

  var GetParsedBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
      transaction: ParsedConfirmedTransactionResult,
      meta: nullable(ParsedConfirmedTransactionMetaResult),
      version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  /**
   * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `accounts`
   */

  var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
      transaction: ConfirmedTransactionAccountsModeResult,
      meta: nullable(ParsedConfirmedTransactionMetaResult),
      version: optional(TransactionVersionStruct)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  /**
   * Expected parsed JSON RPC response for the "getBlock" message  when `transactionDetails` is `none`
   */

  var GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number()),
    blockHeight: nullable(number())
  })));
  /**
   * Expected JSON RPC response for the "getConfirmedBlock" message
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.
   */

  var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    transactions: array(type({
      transaction: ConfirmedTransactionResult,
      meta: nullable(ConfirmedTransactionMetaResult)
    })),
    rewards: optional(array(RewardsResult)),
    blockTime: nullable(number())
  })));
  /**
   * Expected JSON RPC response for the "getBlock" message
   */

  var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({
    blockhash: string(),
    previousBlockhash: string(),
    parentSlot: number(),
    signatures: array(string()),
    blockTime: nullable(number())
  })));
  /**
   * Expected JSON RPC response for the "getTransaction" message
   */

  var GetTransactionRpcResult = jsonRpcResult(nullable(type({
    slot: number(),
    meta: ConfirmedTransactionMetaResult,
    blockTime: optional(nullable(number())),
    transaction: ConfirmedTransactionResult,
    version: optional(TransactionVersionStruct)
  })));
  /**
   * Expected parsed JSON RPC response for the "getTransaction" message
   */

  var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({
    slot: number(),
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable(ParsedConfirmedTransactionMetaResult),
    blockTime: optional(nullable(number())),
    version: optional(TransactionVersionStruct)
  })));
  /**
   * Expected JSON RPC response for the "getRecentBlockhash" message
   *
   * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.
   */

  var GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext(type({
    blockhash: string(),
    feeCalculator: type({
      lamportsPerSignature: number()
    })
  }));
  /**
   * Expected JSON RPC response for the "getLatestBlockhash" message
   */

  var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({
    blockhash: string(),
    lastValidBlockHeight: number()
  }));
  var PerfSampleResult = type({
    slot: number(),
    numTransactions: number(),
    numSlots: number(),
    samplePeriodSecs: number()
  });
  /*
   * Expected JSON RPC response for "getRecentPerformanceSamples" message
   */

  var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));
  /**
   * Expected JSON RPC response for the "getFeeCalculatorForBlockhash" message
   */

  var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({
    feeCalculator: type({
      lamportsPerSignature: number()
    })
  })));
  /**
   * Expected JSON RPC response for the "requestAirdrop" message
   */

  var RequestAirdropRpcResult = jsonRpcResult(string());
  /**
   * Expected JSON RPC response for the "sendTransaction" message
   */

  var SendTransactionRpcResult = jsonRpcResult(string());
  /**
   * Information about the latest slot being processed by a node
   */

  /**
   * @internal
   */

  var LogsResult = type({
    err: TransactionErrorResult,
    logs: array(string()),
    signature: string()
  });
  /**
   * Logs result.
   */

  /**
   * Expected JSON RPC response for the "logsNotification" message.
   */

  var LogsNotificationResult = type({
    result: notificationResultAndContext(LogsResult),
    subscription: number()
  });
  /**
   * Filter for log subscriptions.
   */

  /** @internal */

  var COMMON_HTTP_HEADERS = {
    'solana-client': "js/".concat("0.0.0-development")
  };
  /**
   * A connection to a fullnode JSON RPC endpoint
   */

  var Connection = /*#__PURE__*/function () {
    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal
     * A number that we increment every time an active connection closes.
     * Used to determine whether the same socket connection that was open
     * when an async operation started is the same one that's active when
     * its continuation fires.
     *
     */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /** @internal */

    /**
     * Special case.
     * After a signature is processed, RPCs automatically dispose of the
     * subscription on the server side. We need to track which of these
     * subscriptions have been disposed in such a way, so that we know
     * whether the client is dealing with a not-yet-processed signature
     * (in which case we must tear down the server subscription) or an
     * already-processed signature (in which case the client can simply
     * clear out the subscription locally without telling the server).
     *
     * NOTE: There is a proposal to eliminate this special case, here:
     * https://github.com/solana-labs/solana/issues/18892
     */

    /** @internal */

    /**
     * Establish a JSON RPC connection
     *
     * @param endpoint URL to the fullnode JSON RPC endpoint
     * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object
     */
    function Connection(endpoint, _commitmentOrConfig) {
      var _this15 = this;

      _classCallCheck(this, Connection);

      this._commitment = void 0;
      this._confirmTransactionInitialTimeout = void 0;
      this._rpcEndpoint = void 0;
      this._rpcWsEndpoint = void 0;
      this._rpcClient = void 0;
      this._rpcRequest = void 0;
      this._rpcBatchRequest = void 0;
      this._rpcWebSocket = void 0;
      this._rpcWebSocketConnected = false;
      this._rpcWebSocketHeartbeat = null;
      this._rpcWebSocketIdleTimeout = null;
      this._rpcWebSocketGeneration = 0;
      this._disableBlockhashCaching = false;
      this._pollingBlockhash = false;
      this._blockhashInfo = {
        latestBlockhash: null,
        lastFetch: 0,
        transactionSignatures: [],
        simulatedSignatures: []
      };
      this._nextClientSubscriptionId = 0;
      this._subscriptionDisposeFunctionsByClientSubscriptionId = {};
      this._subscriptionHashByClientSubscriptionId = {};
      this._subscriptionStateChangeCallbacksByHash = {};
      this._subscriptionCallbacksByServerSubscriptionId = {};
      this._subscriptionsByHash = {};
      this._subscriptionsAutoDisposedByRpc = new Set();

      this.getBlockHeight = function () {
        var requestPromises = {};
        return /*#__PURE__*/function () {
          var _ref24 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(commitmentOrConfig) {
            var _requestPromises$requ;

            var _extractCommitmentFro, commitment, config, args, requestHash;

            return _regeneratorRuntime().wrap(function _callee9$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  _extractCommitmentFro = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro.commitment, config = _extractCommitmentFro.config;
                  args = _this15._buildArgs([], commitment, undefined
                  /* encoding */
                  , config);
                  requestHash = fastStableStringify$1(args);
                  requestPromises[requestHash] = (_requestPromises$requ = requestPromises[requestHash]) !== null && _requestPromises$requ !== void 0 ? _requestPromises$requ : _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
                    var unsafeRes, res;
                    return _regeneratorRuntime().wrap(function _callee8$(_context8) {
                      while (1) switch (_context8.prev = _context8.next) {
                        case 0:
                          _context8.prev = 0;
                          _context8.next = 3;
                          return _this15._rpcRequest('getBlockHeight', args);

                        case 3:
                          unsafeRes = _context8.sent;
                          res = _create(unsafeRes, jsonRpcResult(number()));

                          if (!('error' in res)) {
                            _context8.next = 7;
                            break;
                          }

                          throw new SolanaJSONRPCError(res.error, 'failed to get block height information');

                        case 7:
                          return _context8.abrupt("return", res.result);

                        case 8:
                          _context8.prev = 8;
                          delete requestPromises[requestHash];
                          return _context8.finish(8);

                        case 11:
                        case "end":
                          return _context8.stop();
                      }
                    }, _callee8, null, [[0,, 8, 11]]);
                  }))();
                  _context9.next = 6;
                  return requestPromises[requestHash];

                case 6:
                  return _context9.abrupt("return", _context9.sent);

                case 7:
                case "end":
                  return _context9.stop();
              }
            }, _callee9);
          }));

          return function (_x22) {
            return _ref24.apply(this, arguments);
          };
        }();
      }();

      var wsEndpoint;
      var httpHeaders;
      var fetch;
      var fetchMiddleware;
      var disableRetryOnRateLimit;
      var httpAgent;

      if (_commitmentOrConfig && typeof _commitmentOrConfig === 'string') {
        this._commitment = _commitmentOrConfig;
      } else if (_commitmentOrConfig) {
        this._commitment = _commitmentOrConfig.commitment;
        this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;
        wsEndpoint = _commitmentOrConfig.wsEndpoint;
        httpHeaders = _commitmentOrConfig.httpHeaders;
        fetch = _commitmentOrConfig.fetch;
        fetchMiddleware = _commitmentOrConfig.fetchMiddleware;
        disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;
        httpAgent = _commitmentOrConfig.httpAgent;
      }

      this._rpcEndpoint = assertEndpointUrl(endpoint);
      this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);
      this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);
      this._rpcRequest = createRpcRequest(this._rpcClient);
      this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);
      this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {
        autoconnect: false,
        max_reconnects: Infinity
      });

      this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));

      this._rpcWebSocket.on('error', this._wsOnError.bind(this));

      this._rpcWebSocket.on('close', this._wsOnClose.bind(this));

      this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));

      this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));

      this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));

      this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));

      this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));

      this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));

      this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));
    }
    /**
     * The default commitment used for requests
     */


    _createClass(Connection, [{
      key: "commitment",
      get: function get() {
        return this._commitment;
      }
      /**
       * The RPC endpoint
       */

    }, {
      key: "rpcEndpoint",
      get: function get() {
        return this._rpcEndpoint;
      }
      /**
       * Fetch the balance for the specified public key, return with context
       */

    }, {
      key: "getBalanceAndContext",
      value: function () {
        var _getBalanceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(publicKey, commitmentOrConfig) {
          var _extractCommitmentFro2, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee10$(_context10) {
            while (1) switch (_context10.prev = _context10.next) {
              case 0:
                /** @internal */
                _extractCommitmentFro2 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro2.commitment, config = _extractCommitmentFro2.config;
                args = this._buildArgs([publicKey.toBase58()], commitment, undefined
                /* encoding */
                , config);
                _context10.next = 4;
                return this._rpcRequest('getBalance', args);

              case 4:
                unsafeRes = _context10.sent;
                res = _create(unsafeRes, jsonRpcResultAndContext(number()));

                if (!('error' in res)) {
                  _context10.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get balance for ".concat(publicKey.toBase58()));

              case 8:
                return _context10.abrupt("return", res.result);

              case 9:
              case "end":
                return _context10.stop();
            }
          }, _callee10, this);
        }));

        function getBalanceAndContext(_x23, _x24) {
          return _getBalanceAndContext.apply(this, arguments);
        }

        return getBalanceAndContext;
      }()
      /**
       * Fetch the balance for the specified public key
       */

    }, {
      key: "getBalance",
      value: function () {
        var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(publicKey, commitmentOrConfig) {
          return _regeneratorRuntime().wrap(function _callee11$(_context11) {
            while (1) switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return this.getBalanceAndContext(publicKey, commitmentOrConfig).then(function (x) {
                  return x.value;
                })["catch"](function (e) {
                  throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);
                });

              case 2:
                return _context11.abrupt("return", _context11.sent);

              case 3:
              case "end":
                return _context11.stop();
            }
          }, _callee11, this);
        }));

        function getBalance(_x25, _x26) {
          return _getBalance.apply(this, arguments);
        }

        return getBalance;
      }()
      /**
       * Fetch the estimated production time of a block
       */

    }, {
      key: "getBlockTime",
      value: function () {
        var _getBlockTime = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(slot) {
          var unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee12$(_context12) {
            while (1) switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this._rpcRequest('getBlockTime', [slot]);

              case 2:
                unsafeRes = _context12.sent;
                res = _create(unsafeRes, jsonRpcResult(nullable(number())));

                if (!('error' in res)) {
                  _context12.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get block time for slot ".concat(slot));

              case 6:
                return _context12.abrupt("return", res.result);

              case 7:
              case "end":
                return _context12.stop();
            }
          }, _callee12, this);
        }));

        function getBlockTime(_x27) {
          return _getBlockTime.apply(this, arguments);
        }

        return getBlockTime;
      }()
      /**
       * Fetch the lowest slot that the node has information about in its ledger.
       * This value may increase over time if the node is configured to purge older ledger data
       */

    }, {
      key: "getMinimumLedgerSlot",
      value: function () {
        var _getMinimumLedgerSlot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
          var unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee13$(_context13) {
            while (1) switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return this._rpcRequest('minimumLedgerSlot', []);

              case 2:
                unsafeRes = _context13.sent;
                res = _create(unsafeRes, jsonRpcResult(number()));

                if (!('error' in res)) {
                  _context13.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');

              case 6:
                return _context13.abrupt("return", res.result);

              case 7:
              case "end":
                return _context13.stop();
            }
          }, _callee13, this);
        }));

        function getMinimumLedgerSlot() {
          return _getMinimumLedgerSlot.apply(this, arguments);
        }

        return getMinimumLedgerSlot;
      }()
      /**
       * Fetch the slot of the lowest confirmed block that has not been purged from the ledger
       */

    }, {
      key: "getFirstAvailableBlock",
      value: function () {
        var _getFirstAvailableBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
          var unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this._rpcRequest('getFirstAvailableBlock', []);

              case 2:
                unsafeRes = _context14.sent;
                res = _create(unsafeRes, SlotRpcResult);

                if (!('error' in res)) {
                  _context14.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get first available block');

              case 6:
                return _context14.abrupt("return", res.result);

              case 7:
              case "end":
                return _context14.stop();
            }
          }, _callee14, this);
        }));

        function getFirstAvailableBlock() {
          return _getFirstAvailableBlock.apply(this, arguments);
        }

        return getFirstAvailableBlock;
      }()
      /**
       * Fetch information about the current supply
       */

    }, {
      key: "getSupply",
      value: function () {
        var _getSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(config) {
          var configArg, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee15$(_context15) {
            while (1) switch (_context15.prev = _context15.next) {
              case 0:
                configArg = {};

                if (typeof config === 'string') {
                  configArg = {
                    commitment: config
                  };
                } else if (config) {
                  configArg = _objectSpread2(_objectSpread2({}, config), {}, {
                    commitment: config && config.commitment || this.commitment
                  });
                } else {
                  configArg = {
                    commitment: this.commitment
                  };
                }

                _context15.next = 4;
                return this._rpcRequest('getSupply', [configArg]);

              case 4:
                unsafeRes = _context15.sent;
                res = _create(unsafeRes, GetSupplyRpcResult);

                if (!('error' in res)) {
                  _context15.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get supply');

              case 8:
                return _context15.abrupt("return", res.result);

              case 9:
              case "end":
                return _context15.stop();
            }
          }, _callee15, this);
        }));

        function getSupply(_x28) {
          return _getSupply.apply(this, arguments);
        }

        return getSupply;
      }()
      /**
       * Fetch the current supply of a token mint
       */

    }, {
      key: "getTokenSupply",
      value: function () {
        var _getTokenSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(tokenMintAddress, commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee16$(_context16) {
            while (1) switch (_context16.prev = _context16.next) {
              case 0:
                args = this._buildArgs([tokenMintAddress.toBase58()], commitment);
                _context16.next = 3;
                return this._rpcRequest('getTokenSupply', args);

              case 3:
                unsafeRes = _context16.sent;
                res = _create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));

                if (!('error' in res)) {
                  _context16.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get token supply');

              case 7:
                return _context16.abrupt("return", res.result);

              case 8:
              case "end":
                return _context16.stop();
            }
          }, _callee16, this);
        }));

        function getTokenSupply(_x29, _x30) {
          return _getTokenSupply.apply(this, arguments);
        }

        return getTokenSupply;
      }()
      /**
       * Fetch the current balance of a token account
       */

    }, {
      key: "getTokenAccountBalance",
      value: function () {
        var _getTokenAccountBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(tokenAddress, commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee17$(_context17) {
            while (1) switch (_context17.prev = _context17.next) {
              case 0:
                args = this._buildArgs([tokenAddress.toBase58()], commitment);
                _context17.next = 3;
                return this._rpcRequest('getTokenAccountBalance', args);

              case 3:
                unsafeRes = _context17.sent;
                res = _create(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));

                if (!('error' in res)) {
                  _context17.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');

              case 7:
                return _context17.abrupt("return", res.result);

              case 8:
              case "end":
                return _context17.stop();
            }
          }, _callee17, this);
        }));

        function getTokenAccountBalance(_x31, _x32) {
          return _getTokenAccountBalance.apply(this, arguments);
        }

        return getTokenAccountBalance;
      }()
      /**
       * Fetch all the token accounts owned by the specified account
       *
       * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>>}
       */

    }, {
      key: "getTokenAccountsByOwner",
      value: function () {
        var _getTokenAccountsByOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(ownerAddress, filter, commitmentOrConfig) {
          var _extractCommitmentFro3, commitment, config, _args, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee18$(_context18) {
            while (1) switch (_context18.prev = _context18.next) {
              case 0:
                _extractCommitmentFro3 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro3.commitment, config = _extractCommitmentFro3.config;
                _args = [ownerAddress.toBase58()];

                if ('mint' in filter) {
                  _args.push({
                    mint: filter.mint.toBase58()
                  });
                } else {
                  _args.push({
                    programId: filter.programId.toBase58()
                  });
                }

                args = this._buildArgs(_args, commitment, 'base64', config);
                _context18.next = 6;
                return this._rpcRequest('getTokenAccountsByOwner', args);

              case 6:
                unsafeRes = _context18.sent;
                res = _create(unsafeRes, GetTokenAccountsByOwner);

                if (!('error' in res)) {
                  _context18.next = 10;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get token accounts owned by account ".concat(ownerAddress.toBase58()));

              case 10:
                return _context18.abrupt("return", res.result);

              case 11:
              case "end":
                return _context18.stop();
            }
          }, _callee18, this);
        }));

        function getTokenAccountsByOwner(_x33, _x34, _x35) {
          return _getTokenAccountsByOwner.apply(this, arguments);
        }

        return getTokenAccountsByOwner;
      }()
      /**
       * Fetch parsed token accounts owned by the specified account
       *
       * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}
       */

    }, {
      key: "getParsedTokenAccountsByOwner",
      value: function () {
        var _getParsedTokenAccountsByOwner = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(ownerAddress, filter, commitment) {
          var _args, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee19$(_context19) {
            while (1) switch (_context19.prev = _context19.next) {
              case 0:
                _args = [ownerAddress.toBase58()];

                if ('mint' in filter) {
                  _args.push({
                    mint: filter.mint.toBase58()
                  });
                } else {
                  _args.push({
                    programId: filter.programId.toBase58()
                  });
                }

                args = this._buildArgs(_args, commitment, 'jsonParsed');
                _context19.next = 5;
                return this._rpcRequest('getTokenAccountsByOwner', args);

              case 5:
                unsafeRes = _context19.sent;
                res = _create(unsafeRes, GetParsedTokenAccountsByOwner);

                if (!('error' in res)) {
                  _context19.next = 9;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get token accounts owned by account ".concat(ownerAddress.toBase58()));

              case 9:
                return _context19.abrupt("return", res.result);

              case 10:
              case "end":
                return _context19.stop();
            }
          }, _callee19, this);
        }));

        function getParsedTokenAccountsByOwner(_x36, _x37, _x38) {
          return _getParsedTokenAccountsByOwner.apply(this, arguments);
        }

        return getParsedTokenAccountsByOwner;
      }()
      /**
       * Fetch the 20 largest accounts with their current balances
       */

    }, {
      key: "getLargestAccounts",
      value: function () {
        var _getLargestAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(config) {
          var arg, args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee20$(_context20) {
            while (1) switch (_context20.prev = _context20.next) {
              case 0:
                arg = _objectSpread2(_objectSpread2({}, config), {}, {
                  commitment: config && config.commitment || this.commitment
                });
                args = arg.filter || arg.commitment ? [arg] : [];
                _context20.next = 4;
                return this._rpcRequest('getLargestAccounts', args);

              case 4:
                unsafeRes = _context20.sent;
                res = _create(unsafeRes, GetLargestAccountsRpcResult);

                if (!('error' in res)) {
                  _context20.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');

              case 8:
                return _context20.abrupt("return", res.result);

              case 9:
              case "end":
                return _context20.stop();
            }
          }, _callee20, this);
        }));

        function getLargestAccounts(_x39) {
          return _getLargestAccounts.apply(this, arguments);
        }

        return getLargestAccounts;
      }()
      /**
       * Fetch the 20 largest token accounts with their current balances
       * for a given mint.
       */

    }, {
      key: "getTokenLargestAccounts",
      value: function () {
        var _getTokenLargestAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(mintAddress, commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee21$(_context21) {
            while (1) switch (_context21.prev = _context21.next) {
              case 0:
                args = this._buildArgs([mintAddress.toBase58()], commitment);
                _context21.next = 3;
                return this._rpcRequest('getTokenLargestAccounts', args);

              case 3:
                unsafeRes = _context21.sent;
                res = _create(unsafeRes, GetTokenLargestAccountsResult);

                if (!('error' in res)) {
                  _context21.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get token largest accounts');

              case 7:
                return _context21.abrupt("return", res.result);

              case 8:
              case "end":
                return _context21.stop();
            }
          }, _callee21, this);
        }));

        function getTokenLargestAccounts(_x40, _x41) {
          return _getTokenLargestAccounts.apply(this, arguments);
        }

        return getTokenLargestAccounts;
      }()
      /**
       * Fetch all the account info for the specified public key, return with context
       */

    }, {
      key: "getAccountInfoAndContext",
      value: function () {
        var _getAccountInfoAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(publicKey, commitmentOrConfig) {
          var _extractCommitmentFro4, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee22$(_context22) {
            while (1) switch (_context22.prev = _context22.next) {
              case 0:
                _extractCommitmentFro4 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro4.commitment, config = _extractCommitmentFro4.config;
                args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);
                _context22.next = 4;
                return this._rpcRequest('getAccountInfo', args);

              case 4:
                unsafeRes = _context22.sent;
                res = _create(unsafeRes, jsonRpcResultAndContext(nullable(AccountInfoResult)));

                if (!('error' in res)) {
                  _context22.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get info about account ".concat(publicKey.toBase58()));

              case 8:
                return _context22.abrupt("return", res.result);

              case 9:
              case "end":
                return _context22.stop();
            }
          }, _callee22, this);
        }));

        function getAccountInfoAndContext(_x42, _x43) {
          return _getAccountInfoAndContext.apply(this, arguments);
        }

        return getAccountInfoAndContext;
      }()
      /**
       * Fetch parsed account info for the specified public key
       */

    }, {
      key: "getParsedAccountInfo",
      value: function () {
        var _getParsedAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(publicKey, commitmentOrConfig) {
          var _extractCommitmentFro5, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee23$(_context23) {
            while (1) switch (_context23.prev = _context23.next) {
              case 0:
                _extractCommitmentFro5 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro5.commitment, config = _extractCommitmentFro5.config;
                args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed', config);
                _context23.next = 4;
                return this._rpcRequest('getAccountInfo', args);

              case 4:
                unsafeRes = _context23.sent;
                res = _create(unsafeRes, jsonRpcResultAndContext(nullable(ParsedAccountInfoResult)));

                if (!('error' in res)) {
                  _context23.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get info about account ".concat(publicKey.toBase58()));

              case 8:
                return _context23.abrupt("return", res.result);

              case 9:
              case "end":
                return _context23.stop();
            }
          }, _callee23, this);
        }));

        function getParsedAccountInfo(_x44, _x45) {
          return _getParsedAccountInfo.apply(this, arguments);
        }

        return getParsedAccountInfo;
      }()
      /**
       * Fetch all the account info for the specified public key
       */

    }, {
      key: "getAccountInfo",
      value: function () {
        var _getAccountInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(publicKey, commitmentOrConfig) {
          var res;
          return _regeneratorRuntime().wrap(function _callee24$(_context24) {
            while (1) switch (_context24.prev = _context24.next) {
              case 0:
                _context24.prev = 0;
                _context24.next = 3;
                return this.getAccountInfoAndContext(publicKey, commitmentOrConfig);

              case 3:
                res = _context24.sent;
                return _context24.abrupt("return", res.value);

              case 7:
                _context24.prev = 7;
                _context24.t0 = _context24["catch"](0);
                throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + _context24.t0);

              case 10:
              case "end":
                return _context24.stop();
            }
          }, _callee24, this, [[0, 7]]);
        }));

        function getAccountInfo(_x46, _x47) {
          return _getAccountInfo.apply(this, arguments);
        }

        return getAccountInfo;
      }()
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
       */

    }, {
      key: "getMultipleParsedAccounts",
      value: function () {
        var _getMultipleParsedAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(publicKeys, rawConfig) {
          var _extractCommitmentFro6, commitment, config, keys, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee25$(_context25) {
            while (1) switch (_context25.prev = _context25.next) {
              case 0:
                _extractCommitmentFro6 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro6.commitment, config = _extractCommitmentFro6.config;
                keys = publicKeys.map(function (key) {
                  return key.toBase58();
                });
                args = this._buildArgs([keys], commitment, 'jsonParsed', config);
                _context25.next = 5;
                return this._rpcRequest('getMultipleAccounts', args);

              case 5:
                unsafeRes = _context25.sent;
                res = _create(unsafeRes, jsonRpcResultAndContext(array(nullable(ParsedAccountInfoResult))));

                if (!('error' in res)) {
                  _context25.next = 9;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get info for accounts ".concat(keys));

              case 9:
                return _context25.abrupt("return", res.result);

              case 10:
              case "end":
                return _context25.stop();
            }
          }, _callee25, this);
        }));

        function getMultipleParsedAccounts(_x48, _x49) {
          return _getMultipleParsedAccounts.apply(this, arguments);
        }

        return getMultipleParsedAccounts;
      }()
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys, return with context
       */

    }, {
      key: "getMultipleAccountsInfoAndContext",
      value: function () {
        var _getMultipleAccountsInfoAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(publicKeys, commitmentOrConfig) {
          var _extractCommitmentFro7, commitment, config, keys, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee26$(_context26) {
            while (1) switch (_context26.prev = _context26.next) {
              case 0:
                _extractCommitmentFro7 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro7.commitment, config = _extractCommitmentFro7.config;
                keys = publicKeys.map(function (key) {
                  return key.toBase58();
                });
                args = this._buildArgs([keys], commitment, 'base64', config);
                _context26.next = 5;
                return this._rpcRequest('getMultipleAccounts', args);

              case 5:
                unsafeRes = _context26.sent;
                res = _create(unsafeRes, jsonRpcResultAndContext(array(nullable(AccountInfoResult))));

                if (!('error' in res)) {
                  _context26.next = 9;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get info for accounts ".concat(keys));

              case 9:
                return _context26.abrupt("return", res.result);

              case 10:
              case "end":
                return _context26.stop();
            }
          }, _callee26, this);
        }));

        function getMultipleAccountsInfoAndContext(_x50, _x51) {
          return _getMultipleAccountsInfoAndContext.apply(this, arguments);
        }

        return getMultipleAccountsInfoAndContext;
      }()
      /**
       * Fetch all the account info for multiple accounts specified by an array of public keys
       */

    }, {
      key: "getMultipleAccountsInfo",
      value: function () {
        var _getMultipleAccountsInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(publicKeys, commitmentOrConfig) {
          var res;
          return _regeneratorRuntime().wrap(function _callee27$(_context27) {
            while (1) switch (_context27.prev = _context27.next) {
              case 0:
                _context27.next = 2;
                return this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);

              case 2:
                res = _context27.sent;
                return _context27.abrupt("return", res.value);

              case 4:
              case "end":
                return _context27.stop();
            }
          }, _callee27, this);
        }));

        function getMultipleAccountsInfo(_x52, _x53) {
          return _getMultipleAccountsInfo.apply(this, arguments);
        }

        return getMultipleAccountsInfo;
      }()
      /**
       * Returns epoch activation information for a stake account that has been delegated
       */

    }, {
      key: "getStakeActivation",
      value: function () {
        var _getStakeActivation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28(publicKey, commitmentOrConfig, epoch) {
          var _extractCommitmentFro8, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee28$(_context28) {
            while (1) switch (_context28.prev = _context28.next) {
              case 0:
                _extractCommitmentFro8 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro8.commitment, config = _extractCommitmentFro8.config;
                args = this._buildArgs([publicKey.toBase58()], commitment, undefined
                /* encoding */
                , _objectSpread2(_objectSpread2({}, config), {}, {
                  epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch
                }));
                _context28.next = 4;
                return this._rpcRequest('getStakeActivation', args);

              case 4:
                unsafeRes = _context28.sent;
                res = _create(unsafeRes, jsonRpcResult(StakeActivationResult));

                if (!('error' in res)) {
                  _context28.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get Stake Activation ".concat(publicKey.toBase58()));

              case 8:
                return _context28.abrupt("return", res.result);

              case 9:
              case "end":
                return _context28.stop();
            }
          }, _callee28, this);
        }));

        function getStakeActivation(_x54, _x55, _x56) {
          return _getStakeActivation.apply(this, arguments);
        }

        return getStakeActivation;
      }()
      /**
       * Fetch all the accounts owned by the specified program id
       *
       * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}
       */

    }, {
      key: "getProgramAccounts",
      value: function () {
        var _getProgramAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(programId, configOrCommitment) {
          var _extractCommitmentFro9, commitment, config, _ref26, encoding, configWithoutEncoding, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee29$(_context29) {
            while (1) switch (_context29.prev = _context29.next) {
              case 0:
                _extractCommitmentFro9 = extractCommitmentFromConfig(configOrCommitment), commitment = _extractCommitmentFro9.commitment, config = _extractCommitmentFro9.config;
                _ref26 = config || {}, encoding = _ref26.encoding, configWithoutEncoding = _objectWithoutProperties(_ref26, _excluded2);
                args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', configWithoutEncoding);
                _context29.next = 5;
                return this._rpcRequest('getProgramAccounts', args);

              case 5:
                unsafeRes = _context29.sent;
                res = _create(unsafeRes, jsonRpcResult(array(KeyedAccountInfoResult)));

                if (!('error' in res)) {
                  _context29.next = 9;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get accounts owned by program ".concat(programId.toBase58()));

              case 9:
                return _context29.abrupt("return", res.result);

              case 10:
              case "end":
                return _context29.stop();
            }
          }, _callee29, this);
        }));

        function getProgramAccounts(_x57, _x58) {
          return _getProgramAccounts.apply(this, arguments);
        }

        return getProgramAccounts;
      }()
      /**
       * Fetch and parse all the accounts owned by the specified program id
       *
       * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}
       */

    }, {
      key: "getParsedProgramAccounts",
      value: function () {
        var _getParsedProgramAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(programId, configOrCommitment) {
          var _extractCommitmentFro10, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee30$(_context30) {
            while (1) switch (_context30.prev = _context30.next) {
              case 0:
                _extractCommitmentFro10 = extractCommitmentFromConfig(configOrCommitment), commitment = _extractCommitmentFro10.commitment, config = _extractCommitmentFro10.config;
                args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);
                _context30.next = 4;
                return this._rpcRequest('getProgramAccounts', args);

              case 4:
                unsafeRes = _context30.sent;
                res = _create(unsafeRes, jsonRpcResult(array(KeyedParsedAccountInfoResult)));

                if (!('error' in res)) {
                  _context30.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get accounts owned by program ".concat(programId.toBase58()));

              case 8:
                return _context30.abrupt("return", res.result);

              case 9:
              case "end":
                return _context30.stop();
            }
          }, _callee30, this);
        }));

        function getParsedProgramAccounts(_x59, _x60) {
          return _getParsedProgramAccounts.apply(this, arguments);
        }

        return getParsedProgramAccounts;
      }() // eslint-disable-next-line no-dupe-class-members

    }, {
      key: "confirmTransaction",
      value: function () {
        var _confirmTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(strategy, commitment) {
          var rawSignature, _config$abortSignal, config, decodedSignature;

          return _regeneratorRuntime().wrap(function _callee31$(_context31) {
            while (1) switch (_context31.prev = _context31.next) {
              case 0:
                if (!(typeof strategy == 'string')) {
                  _context31.next = 4;
                  break;
                }

                rawSignature = strategy;
                _context31.next = 8;
                break;

              case 4:
                config = strategy;

                if (!((_config$abortSignal = config.abortSignal) !== null && _config$abortSignal !== void 0 && _config$abortSignal.aborted)) {
                  _context31.next = 7;
                  break;
                }

                return _context31.abrupt("return", Promise.reject(config.abortSignal.reason));

              case 7:
                rawSignature = config.signature;

              case 8:
                _context31.prev = 8;
                decodedSignature = bs58$1.decode(rawSignature);
                _context31.next = 15;
                break;

              case 12:
                _context31.prev = 12;
                _context31.t0 = _context31["catch"](8);
                throw new Error('signature must be base58 encoded: ' + rawSignature);

              case 15:
                assert(decodedSignature.length === 64, 'signature has invalid length');

                if (!(typeof strategy === 'string')) {
                  _context31.next = 22;
                  break;
                }

                _context31.next = 19;
                return this.confirmTransactionUsingLegacyTimeoutStrategy({
                  commitment: commitment || this.commitment,
                  signature: rawSignature
                });

              case 19:
                return _context31.abrupt("return", _context31.sent);

              case 22:
                if (!('lastValidBlockHeight' in strategy)) {
                  _context31.next = 28;
                  break;
                }

                _context31.next = 25;
                return this.confirmTransactionUsingBlockHeightExceedanceStrategy({
                  commitment: commitment || this.commitment,
                  strategy: strategy
                });

              case 25:
                return _context31.abrupt("return", _context31.sent);

              case 28:
                _context31.next = 30;
                return this.confirmTransactionUsingDurableNonceStrategy({
                  commitment: commitment || this.commitment,
                  strategy: strategy
                });

              case 30:
                return _context31.abrupt("return", _context31.sent);

              case 31:
              case "end":
                return _context31.stop();
            }
          }, _callee31, this, [[8, 12]]);
        }));

        function confirmTransaction(_x61, _x62) {
          return _confirmTransaction.apply(this, arguments);
        }

        return confirmTransaction;
      }()
    }, {
      key: "getCancellationPromise",
      value: function getCancellationPromise(signal) {
        return new Promise(function (_, reject) {
          if (signal == null) {
            return;
          }

          if (signal.aborted) {
            reject(signal.reason);
          } else {
            signal.addEventListener('abort', function () {
              reject(signal.reason);
            });
          }
        });
      }
    }, {
      key: "getTransactionConfirmationPromise",
      value: function getTransactionConfirmationPromise(_ref27) {
        var _this16 = this;

        var commitment = _ref27.commitment,
            signature = _ref27.signature;
        var signatureSubscriptionId;
        var disposeSignatureSubscriptionStateChangeObserver;
        var done = false;
        var confirmationPromise = new Promise(function (resolve, reject) {
          try {
            signatureSubscriptionId = _this16.onSignature(signature, function (result, context) {
              signatureSubscriptionId = undefined;
              var response = {
                context: context,
                value: result
              };
              resolve({
                __type: TransactionStatus.PROCESSED,
                response: response
              });
            }, commitment);
            var subscriptionSetupPromise = new Promise(function (resolveSubscriptionSetup) {
              if (signatureSubscriptionId == null) {
                resolveSubscriptionSetup();
              } else {
                disposeSignatureSubscriptionStateChangeObserver = _this16._onSubscriptionStateChange(signatureSubscriptionId, function (nextState) {
                  if (nextState === 'subscribed') {
                    resolveSubscriptionSetup();
                  }
                });
              }
            });

            _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {
              var response, context, value;
              return _regeneratorRuntime().wrap(function _callee32$(_context32) {
                while (1) switch (_context32.prev = _context32.next) {
                  case 0:
                    _context32.next = 2;
                    return subscriptionSetupPromise;

                  case 2:
                    if (!done) {
                      _context32.next = 4;
                      break;
                    }

                    return _context32.abrupt("return");

                  case 4:
                    _context32.next = 6;
                    return _this16.getSignatureStatus(signature);

                  case 6:
                    response = _context32.sent;

                    if (!done) {
                      _context32.next = 9;
                      break;
                    }

                    return _context32.abrupt("return");

                  case 9:
                    if (!(response == null)) {
                      _context32.next = 11;
                      break;
                    }

                    return _context32.abrupt("return");

                  case 11:
                    context = response.context, value = response.value;

                    if (!(value == null)) {
                      _context32.next = 14;
                      break;
                    }

                    return _context32.abrupt("return");

                  case 14:
                    if (!(value !== null && value !== void 0 && value.err)) {
                      _context32.next = 18;
                      break;
                    }

                    reject(value.err);
                    _context32.next = 29;
                    break;

                  case 18:
                    _context32.t0 = commitment;
                    _context32.next = _context32.t0 === 'confirmed' ? 21 : _context32.t0 === 'single' ? 21 : _context32.t0 === 'singleGossip' ? 21 : _context32.t0 === 'finalized' ? 24 : _context32.t0 === 'max' ? 24 : _context32.t0 === 'root' ? 24 : _context32.t0 === 'processed' ? 27 : _context32.t0 === 'recent' ? 27 : 27;
                    break;

                  case 21:
                    if (!(value.confirmationStatus === 'processed')) {
                      _context32.next = 23;
                      break;
                    }

                    return _context32.abrupt("return");

                  case 23:
                    return _context32.abrupt("break", 27);

                  case 24:
                    if (!(value.confirmationStatus === 'processed' || value.confirmationStatus === 'confirmed')) {
                      _context32.next = 26;
                      break;
                    }

                    return _context32.abrupt("return");

                  case 26:
                    return _context32.abrupt("break", 27);

                  case 27:
                    done = true;
                    resolve({
                      __type: TransactionStatus.PROCESSED,
                      response: {
                        context: context,
                        value: value
                      }
                    });

                  case 29:
                  case "end":
                    return _context32.stop();
                }
              }, _callee32);
            }))();
          } catch (err) {
            reject(err);
          }
        });

        var abortConfirmation = function abortConfirmation() {
          if (disposeSignatureSubscriptionStateChangeObserver) {
            disposeSignatureSubscriptionStateChangeObserver();
            disposeSignatureSubscriptionStateChangeObserver = undefined;
          }

          if (signatureSubscriptionId != null) {
            _this16.removeSignatureListener(signatureSubscriptionId);

            signatureSubscriptionId = undefined;
          }
        };

        return {
          abortConfirmation: abortConfirmation,
          confirmationPromise: confirmationPromise
        };
      }
    }, {
      key: "confirmTransactionUsingBlockHeightExceedanceStrategy",
      value: function () {
        var _confirmTransactionUsingBlockHeightExceedanceStrategy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(_ref29) {
          var _this17 = this;

          var commitment, _ref29$strategy, abortSignal, lastValidBlockHeight, signature, done, expiryPromise, _this$getTransactionC, abortConfirmation, confirmationPromise, cancellationPromise, result, outcome;

          return _regeneratorRuntime().wrap(function _callee35$(_context35) {
            while (1) switch (_context35.prev = _context35.next) {
              case 0:
                commitment = _ref29.commitment, _ref29$strategy = _ref29.strategy, abortSignal = _ref29$strategy.abortSignal, lastValidBlockHeight = _ref29$strategy.lastValidBlockHeight, signature = _ref29$strategy.signature;
                done = false;
                expiryPromise = new Promise(function (resolve) {
                  var checkBlockHeight = /*#__PURE__*/function () {
                    var _ref30 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {
                      var blockHeight;
                      return _regeneratorRuntime().wrap(function _callee33$(_context33) {
                        while (1) switch (_context33.prev = _context33.next) {
                          case 0:
                            _context33.prev = 0;
                            _context33.next = 3;
                            return _this17.getBlockHeight(commitment);

                          case 3:
                            blockHeight = _context33.sent;
                            return _context33.abrupt("return", blockHeight);

                          case 7:
                            _context33.prev = 7;
                            _context33.t0 = _context33["catch"](0);
                            return _context33.abrupt("return", -1);

                          case 10:
                          case "end":
                            return _context33.stop();
                        }
                      }, _callee33, null, [[0, 7]]);
                    }));

                    return function checkBlockHeight() {
                      return _ref30.apply(this, arguments);
                    };
                  }();

                  _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {
                    var currentBlockHeight;
                    return _regeneratorRuntime().wrap(function _callee34$(_context34) {
                      while (1) switch (_context34.prev = _context34.next) {
                        case 0:
                          _context34.next = 2;
                          return checkBlockHeight();

                        case 2:
                          currentBlockHeight = _context34.sent;

                          if (!done) {
                            _context34.next = 5;
                            break;
                          }

                          return _context34.abrupt("return");

                        case 5:
                          if (!(currentBlockHeight <= lastValidBlockHeight)) {
                            _context34.next = 17;
                            break;
                          }

                          _context34.next = 8;
                          return sleep(1000);

                        case 8:
                          if (!done) {
                            _context34.next = 10;
                            break;
                          }

                          return _context34.abrupt("return");

                        case 10:
                          _context34.next = 12;
                          return checkBlockHeight();

                        case 12:
                          currentBlockHeight = _context34.sent;

                          if (!done) {
                            _context34.next = 15;
                            break;
                          }

                          return _context34.abrupt("return");

                        case 15:
                          _context34.next = 5;
                          break;

                        case 17:
                          resolve({
                            __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
                          });

                        case 18:
                        case "end":
                          return _context34.stop();
                      }
                    }, _callee34);
                  }))();
                });
                _this$getTransactionC = this.getTransactionConfirmationPromise({
                  commitment: commitment,
                  signature: signature
                }), abortConfirmation = _this$getTransactionC.abortConfirmation, confirmationPromise = _this$getTransactionC.confirmationPromise;
                cancellationPromise = this.getCancellationPromise(abortSignal);
                _context35.prev = 5;
                _context35.next = 8;
                return Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);

              case 8:
                outcome = _context35.sent;

                if (!(outcome.__type === TransactionStatus.PROCESSED)) {
                  _context35.next = 13;
                  break;
                }

                result = outcome.response;
                _context35.next = 14;
                break;

              case 13:
                throw new TransactionExpiredBlockheightExceededError(signature);

              case 14:
                _context35.prev = 14;
                done = true;
                abortConfirmation();
                return _context35.finish(14);

              case 18:
                return _context35.abrupt("return", result);

              case 19:
              case "end":
                return _context35.stop();
            }
          }, _callee35, this, [[5,, 14, 18]]);
        }));

        function confirmTransactionUsingBlockHeightExceedanceStrategy(_x63) {
          return _confirmTransactionUsingBlockHeightExceedanceStrategy.apply(this, arguments);
        }

        return confirmTransactionUsingBlockHeightExceedanceStrategy;
      }()
    }, {
      key: "confirmTransactionUsingDurableNonceStrategy",
      value: function () {
        var _confirmTransactionUsingDurableNonceStrategy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee38(_ref32) {
          var _this18 = this;

          var commitment, _ref32$strategy, abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature, done, expiryPromise, _this$getTransactionC2, abortConfirmation, confirmationPromise, cancellationPromise, result, outcome, _signatureStatus, signatureStatus, _outcome$slotInWhichN, status, commitmentForStatus, confirmationStatus;

          return _regeneratorRuntime().wrap(function _callee38$(_context38) {
            while (1) switch (_context38.prev = _context38.next) {
              case 0:
                commitment = _ref32.commitment, _ref32$strategy = _ref32.strategy, abortSignal = _ref32$strategy.abortSignal, minContextSlot = _ref32$strategy.minContextSlot, nonceAccountPubkey = _ref32$strategy.nonceAccountPubkey, nonceValue = _ref32$strategy.nonceValue, signature = _ref32$strategy.signature;
                done = false;
                expiryPromise = new Promise(function (resolve) {
                  var currentNonceValue = nonceValue;
                  var lastCheckedSlot = null;

                  var getCurrentNonceValue = /*#__PURE__*/function () {
                    var _ref33 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {
                      var _yield$_this18$getNon2, context, nonceAccount;

                      return _regeneratorRuntime().wrap(function _callee36$(_context36) {
                        while (1) switch (_context36.prev = _context36.next) {
                          case 0:
                            _context36.prev = 0;
                            _context36.next = 3;
                            return _this18.getNonceAndContext(nonceAccountPubkey, {
                              commitment: commitment,
                              minContextSlot: minContextSlot
                            });

                          case 3:
                            _yield$_this18$getNon2 = _context36.sent;
                            context = _yield$_this18$getNon2.context;
                            nonceAccount = _yield$_this18$getNon2.value;
                            lastCheckedSlot = context.slot;
                            return _context36.abrupt("return", nonceAccount === null || nonceAccount === void 0 ? void 0 : nonceAccount.nonce);

                          case 10:
                            _context36.prev = 10;
                            _context36.t0 = _context36["catch"](0);
                            return _context36.abrupt("return", currentNonceValue);

                          case 13:
                          case "end":
                            return _context36.stop();
                        }
                      }, _callee36, null, [[0, 10]]);
                    }));

                    return function getCurrentNonceValue() {
                      return _ref33.apply(this, arguments);
                    };
                  }();

                  _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {
                    return _regeneratorRuntime().wrap(function _callee37$(_context37) {
                      while (1) switch (_context37.prev = _context37.next) {
                        case 0:
                          _context37.next = 2;
                          return getCurrentNonceValue();

                        case 2:
                          currentNonceValue = _context37.sent;

                          if (!done) {
                            _context37.next = 5;
                            break;
                          }

                          return _context37.abrupt("return");

                        case 5:

                          if (!(nonceValue !== currentNonceValue)) {
                            _context37.next = 9;
                            break;
                          }

                          resolve({
                            __type: TransactionStatus.NONCE_INVALID,
                            slotInWhichNonceDidAdvance: lastCheckedSlot
                          });
                          return _context37.abrupt("return");

                        case 9:
                          _context37.next = 11;
                          return sleep(2000);

                        case 11:
                          if (!done) {
                            _context37.next = 13;
                            break;
                          }

                          return _context37.abrupt("return");

                        case 13:
                          _context37.next = 15;
                          return getCurrentNonceValue();

                        case 15:
                          currentNonceValue = _context37.sent;

                          if (!done) {
                            _context37.next = 18;
                            break;
                          }

                          return _context37.abrupt("return");

                        case 18:
                          _context37.next = 5;
                          break;

                        case 20:
                        case "end":
                          return _context37.stop();
                      }
                    }, _callee37);
                  }))();
                });
                _this$getTransactionC2 = this.getTransactionConfirmationPromise({
                  commitment: commitment,
                  signature: signature
                }), abortConfirmation = _this$getTransactionC2.abortConfirmation, confirmationPromise = _this$getTransactionC2.confirmationPromise;
                cancellationPromise = this.getCancellationPromise(abortSignal);
                _context38.prev = 5;
                _context38.next = 8;
                return Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);

              case 8:
                outcome = _context38.sent;

                if (!(outcome.__type === TransactionStatus.PROCESSED)) {
                  _context38.next = 13;
                  break;
                }

                result = outcome.response;
                _context38.next = 47;
                break;

              case 13:

                _context38.next = 16;
                return this.getSignatureStatus(signature);

              case 16:
                status = _context38.sent;

                if (!(status == null)) {
                  _context38.next = 19;
                  break;
                }

                return _context38.abrupt("break", 27);

              case 19:
                if (!(status.context.slot < ((_outcome$slotInWhichN = outcome.slotInWhichNonceDidAdvance) !== null && _outcome$slotInWhichN !== void 0 ? _outcome$slotInWhichN : minContextSlot))) {
                  _context38.next = 23;
                  break;
                }

                _context38.next = 22;
                return sleep(400);

              case 22:
                return _context38.abrupt("continue", 13);

              case 23:
                signatureStatus = status;
                return _context38.abrupt("break", 27);

              case 27:
                if (!((_signatureStatus = signatureStatus) !== null && _signatureStatus !== void 0 && _signatureStatus.value)) {
                  _context38.next = 46;
                  break;
                }

                commitmentForStatus = commitment || 'finalized';
                confirmationStatus = signatureStatus.value.confirmationStatus;
                _context38.t0 = commitmentForStatus;
                _context38.next = _context38.t0 === 'processed' ? 33 : _context38.t0 === 'recent' ? 33 : _context38.t0 === 'confirmed' ? 36 : _context38.t0 === 'single' ? 36 : _context38.t0 === 'singleGossip' ? 36 : _context38.t0 === 'finalized' ? 39 : _context38.t0 === 'max' ? 39 : _context38.t0 === 'root' ? 39 : 42;
                break;

              case 33:
                if (!(confirmationStatus !== 'processed' && confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized')) {
                  _context38.next = 35;
                  break;
                }

                throw new TransactionExpiredNonceInvalidError(signature);

              case 35:
                return _context38.abrupt("break", 43);

              case 36:
                if (!(confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized')) {
                  _context38.next = 38;
                  break;
                }

                throw new TransactionExpiredNonceInvalidError(signature);

              case 38:
                return _context38.abrupt("break", 43);

              case 39:
                if (!(confirmationStatus !== 'finalized')) {
                  _context38.next = 41;
                  break;
                }

                throw new TransactionExpiredNonceInvalidError(signature);

              case 41:
                return _context38.abrupt("break", 43);

              case 42:

              case 43:
                result = {
                  context: signatureStatus.context,
                  value: {
                    err: signatureStatus.value.err
                  }
                };
                _context38.next = 47;
                break;

              case 46:
                throw new TransactionExpiredNonceInvalidError(signature);

              case 47:
                _context38.prev = 47;
                done = true;
                abortConfirmation();
                return _context38.finish(47);

              case 51:
                return _context38.abrupt("return", result);

              case 52:
              case "end":
                return _context38.stop();
            }
          }, _callee38, this, [[5,, 47, 51]]);
        }));

        function confirmTransactionUsingDurableNonceStrategy(_x64) {
          return _confirmTransactionUsingDurableNonceStrategy.apply(this, arguments);
        }

        return confirmTransactionUsingDurableNonceStrategy;
      }()
    }, {
      key: "confirmTransactionUsingLegacyTimeoutStrategy",
      value: function () {
        var _confirmTransactionUsingLegacyTimeoutStrategy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee39(_ref35) {
          var _this19 = this;

          var commitment, signature, timeoutId, expiryPromise, _this$getTransactionC3, abortConfirmation, confirmationPromise, result, outcome;

          return _regeneratorRuntime().wrap(function _callee39$(_context39) {
            while (1) switch (_context39.prev = _context39.next) {
              case 0:
                commitment = _ref35.commitment, signature = _ref35.signature;
                expiryPromise = new Promise(function (resolve) {
                  var timeoutMs = _this19._confirmTransactionInitialTimeout || 60 * 1000;

                  switch (commitment) {
                    case 'processed':
                    case 'recent':
                    case 'single':
                    case 'confirmed':
                    case 'singleGossip':
                      {
                        timeoutMs = _this19._confirmTransactionInitialTimeout || 30 * 1000;
                        break;
                      }
                  }

                  timeoutId = setTimeout(function () {
                    return resolve({
                      __type: TransactionStatus.TIMED_OUT,
                      timeoutMs: timeoutMs
                    });
                  }, timeoutMs);
                });
                _this$getTransactionC3 = this.getTransactionConfirmationPromise({
                  commitment: commitment,
                  signature: signature
                }), abortConfirmation = _this$getTransactionC3.abortConfirmation, confirmationPromise = _this$getTransactionC3.confirmationPromise;
                _context39.prev = 3;
                _context39.next = 6;
                return Promise.race([confirmationPromise, expiryPromise]);

              case 6:
                outcome = _context39.sent;

                if (!(outcome.__type === TransactionStatus.PROCESSED)) {
                  _context39.next = 11;
                  break;
                }

                result = outcome.response;
                _context39.next = 12;
                break;

              case 11:
                throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);

              case 12:
                _context39.prev = 12;
                clearTimeout(timeoutId);
                abortConfirmation();
                return _context39.finish(12);

              case 16:
                return _context39.abrupt("return", result);

              case 17:
              case "end":
                return _context39.stop();
            }
          }, _callee39, this, [[3,, 12, 16]]);
        }));

        function confirmTransactionUsingLegacyTimeoutStrategy(_x65) {
          return _confirmTransactionUsingLegacyTimeoutStrategy.apply(this, arguments);
        }

        return confirmTransactionUsingLegacyTimeoutStrategy;
      }()
      /**
       * Return the list of nodes that are currently participating in the cluster
       */

    }, {
      key: "getClusterNodes",
      value: function () {
        var _getClusterNodes = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {
          var unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee40$(_context40) {
            while (1) switch (_context40.prev = _context40.next) {
              case 0:
                _context40.next = 2;
                return this._rpcRequest('getClusterNodes', []);

              case 2:
                unsafeRes = _context40.sent;
                res = _create(unsafeRes, jsonRpcResult(array(ContactInfoResult)));

                if (!('error' in res)) {
                  _context40.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');

              case 6:
                return _context40.abrupt("return", res.result);

              case 7:
              case "end":
                return _context40.stop();
            }
          }, _callee40, this);
        }));

        function getClusterNodes() {
          return _getClusterNodes.apply(this, arguments);
        }

        return getClusterNodes;
      }()
      /**
       * Return the list of nodes that are currently participating in the cluster
       */

    }, {
      key: "getVoteAccounts",
      value: function () {
        var _getVoteAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee41(commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee41$(_context41) {
            while (1) switch (_context41.prev = _context41.next) {
              case 0:
                args = this._buildArgs([], commitment);
                _context41.next = 3;
                return this._rpcRequest('getVoteAccounts', args);

              case 3:
                unsafeRes = _context41.sent;
                res = _create(unsafeRes, GetVoteAccounts);

                if (!('error' in res)) {
                  _context41.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');

              case 7:
                return _context41.abrupt("return", res.result);

              case 8:
              case "end":
                return _context41.stop();
            }
          }, _callee41, this);
        }));

        function getVoteAccounts(_x66) {
          return _getVoteAccounts.apply(this, arguments);
        }

        return getVoteAccounts;
      }()
      /**
       * Fetch the current slot that the node is processing
       */

    }, {
      key: "getSlot",
      value: function () {
        var _getSlot = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee42(commitmentOrConfig) {
          var _extractCommitmentFro11, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee42$(_context42) {
            while (1) switch (_context42.prev = _context42.next) {
              case 0:
                _extractCommitmentFro11 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro11.commitment, config = _extractCommitmentFro11.config;
                args = this._buildArgs([], commitment, undefined
                /* encoding */
                , config);
                _context42.next = 4;
                return this._rpcRequest('getSlot', args);

              case 4:
                unsafeRes = _context42.sent;
                res = _create(unsafeRes, jsonRpcResult(number()));

                if (!('error' in res)) {
                  _context42.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get slot');

              case 8:
                return _context42.abrupt("return", res.result);

              case 9:
              case "end":
                return _context42.stop();
            }
          }, _callee42, this);
        }));

        function getSlot(_x67) {
          return _getSlot.apply(this, arguments);
        }

        return getSlot;
      }()
      /**
       * Fetch the current slot leader of the cluster
       */

    }, {
      key: "getSlotLeader",
      value: function () {
        var _getSlotLeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee43(commitmentOrConfig) {
          var _extractCommitmentFro12, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee43$(_context43) {
            while (1) switch (_context43.prev = _context43.next) {
              case 0:
                _extractCommitmentFro12 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro12.commitment, config = _extractCommitmentFro12.config;
                args = this._buildArgs([], commitment, undefined
                /* encoding */
                , config);
                _context43.next = 4;
                return this._rpcRequest('getSlotLeader', args);

              case 4:
                unsafeRes = _context43.sent;
                res = _create(unsafeRes, jsonRpcResult(string()));

                if (!('error' in res)) {
                  _context43.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');

              case 8:
                return _context43.abrupt("return", res.result);

              case 9:
              case "end":
                return _context43.stop();
            }
          }, _callee43, this);
        }));

        function getSlotLeader(_x68) {
          return _getSlotLeader.apply(this, arguments);
        }

        return getSlotLeader;
      }()
      /**
       * Fetch `limit` number of slot leaders starting from `startSlot`
       *
       * @param startSlot fetch slot leaders starting from this slot
       * @param limit number of slot leaders to return
       */

    }, {
      key: "getSlotLeaders",
      value: function () {
        var _getSlotLeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee44(startSlot, limit) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee44$(_context44) {
            while (1) switch (_context44.prev = _context44.next) {
              case 0:
                args = [startSlot, limit];
                _context44.next = 3;
                return this._rpcRequest('getSlotLeaders', args);

              case 3:
                unsafeRes = _context44.sent;
                res = _create(unsafeRes, jsonRpcResult(array(PublicKeyFromString)));

                if (!('error' in res)) {
                  _context44.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');

              case 7:
                return _context44.abrupt("return", res.result);

              case 8:
              case "end":
                return _context44.stop();
            }
          }, _callee44, this);
        }));

        function getSlotLeaders(_x69, _x70) {
          return _getSlotLeaders.apply(this, arguments);
        }

        return getSlotLeaders;
      }()
      /**
       * Fetch the current status of a signature
       */

    }, {
      key: "getSignatureStatus",
      value: function () {
        var _getSignatureStatus = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee45(signature, config) {
          var _yield$this$getSignat, context, values, value;

          return _regeneratorRuntime().wrap(function _callee45$(_context45) {
            while (1) switch (_context45.prev = _context45.next) {
              case 0:
                _context45.next = 2;
                return this.getSignatureStatuses([signature], config);

              case 2:
                _yield$this$getSignat = _context45.sent;
                context = _yield$this$getSignat.context;
                values = _yield$this$getSignat.value;
                assert(values.length === 1);
                value = values[0];
                return _context45.abrupt("return", {
                  context: context,
                  value: value
                });

              case 8:
              case "end":
                return _context45.stop();
            }
          }, _callee45, this);
        }));

        function getSignatureStatus(_x71, _x72) {
          return _getSignatureStatus.apply(this, arguments);
        }

        return getSignatureStatus;
      }()
      /**
       * Fetch the current statuses of a batch of signatures
       */

    }, {
      key: "getSignatureStatuses",
      value: function () {
        var _getSignatureStatuses = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee46(signatures, config) {
          var params, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee46$(_context46) {
            while (1) switch (_context46.prev = _context46.next) {
              case 0:
                params = [signatures];

                if (config) {
                  params.push(config);
                }

                _context46.next = 4;
                return this._rpcRequest('getSignatureStatuses', params);

              case 4:
                unsafeRes = _context46.sent;
                res = _create(unsafeRes, GetSignatureStatusesRpcResult);

                if (!('error' in res)) {
                  _context46.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get signature status');

              case 8:
                return _context46.abrupt("return", res.result);

              case 9:
              case "end":
                return _context46.stop();
            }
          }, _callee46, this);
        }));

        function getSignatureStatuses(_x73, _x74) {
          return _getSignatureStatuses.apply(this, arguments);
        }

        return getSignatureStatuses;
      }()
      /**
       * Fetch the current transaction count of the cluster
       */

    }, {
      key: "getTransactionCount",
      value: function () {
        var _getTransactionCount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee47(commitmentOrConfig) {
          var _extractCommitmentFro13, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee47$(_context47) {
            while (1) switch (_context47.prev = _context47.next) {
              case 0:
                _extractCommitmentFro13 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro13.commitment, config = _extractCommitmentFro13.config;
                args = this._buildArgs([], commitment, undefined
                /* encoding */
                , config);
                _context47.next = 4;
                return this._rpcRequest('getTransactionCount', args);

              case 4:
                unsafeRes = _context47.sent;
                res = _create(unsafeRes, jsonRpcResult(number()));

                if (!('error' in res)) {
                  _context47.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get transaction count');

              case 8:
                return _context47.abrupt("return", res.result);

              case 9:
              case "end":
                return _context47.stop();
            }
          }, _callee47, this);
        }));

        function getTransactionCount(_x75) {
          return _getTransactionCount.apply(this, arguments);
        }

        return getTransactionCount;
      }()
      /**
       * Fetch the current total currency supply of the cluster in lamports
       *
       * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.
       */

    }, {
      key: "getTotalSupply",
      value: function () {
        var _getTotalSupply = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee48(commitment) {
          var result;
          return _regeneratorRuntime().wrap(function _callee48$(_context48) {
            while (1) switch (_context48.prev = _context48.next) {
              case 0:
                _context48.next = 2;
                return this.getSupply({
                  commitment: commitment,
                  excludeNonCirculatingAccountsList: true
                });

              case 2:
                result = _context48.sent;
                return _context48.abrupt("return", result.value.total);

              case 4:
              case "end":
                return _context48.stop();
            }
          }, _callee48, this);
        }));

        function getTotalSupply(_x76) {
          return _getTotalSupply.apply(this, arguments);
        }

        return getTotalSupply;
      }()
      /**
       * Fetch the cluster InflationGovernor parameters
       */

    }, {
      key: "getInflationGovernor",
      value: function () {
        var _getInflationGovernor = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee49(commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee49$(_context49) {
            while (1) switch (_context49.prev = _context49.next) {
              case 0:
                args = this._buildArgs([], commitment);
                _context49.next = 3;
                return this._rpcRequest('getInflationGovernor', args);

              case 3:
                unsafeRes = _context49.sent;
                res = _create(unsafeRes, GetInflationGovernorRpcResult);

                if (!('error' in res)) {
                  _context49.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get inflation');

              case 7:
                return _context49.abrupt("return", res.result);

              case 8:
              case "end":
                return _context49.stop();
            }
          }, _callee49, this);
        }));

        function getInflationGovernor(_x77) {
          return _getInflationGovernor.apply(this, arguments);
        }

        return getInflationGovernor;
      }()
      /**
       * Fetch the inflation reward for a list of addresses for an epoch
       */

    }, {
      key: "getInflationReward",
      value: function () {
        var _getInflationReward = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee50(addresses, epoch, commitmentOrConfig) {
          var _extractCommitmentFro14, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee50$(_context50) {
            while (1) switch (_context50.prev = _context50.next) {
              case 0:
                _extractCommitmentFro14 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro14.commitment, config = _extractCommitmentFro14.config;
                args = this._buildArgs([addresses.map(function (pubkey) {
                  return pubkey.toBase58();
                })], commitment, undefined
                /* encoding */
                , _objectSpread2(_objectSpread2({}, config), {}, {
                  epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch
                }));
                _context50.next = 4;
                return this._rpcRequest('getInflationReward', args);

              case 4:
                unsafeRes = _context50.sent;
                res = _create(unsafeRes, GetInflationRewardResult);

                if (!('error' in res)) {
                  _context50.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');

              case 8:
                return _context50.abrupt("return", res.result);

              case 9:
              case "end":
                return _context50.stop();
            }
          }, _callee50, this);
        }));

        function getInflationReward(_x78, _x79, _x80) {
          return _getInflationReward.apply(this, arguments);
        }

        return getInflationReward;
      }()
      /**
       * Fetch the specific inflation values for the current epoch
       */

    }, {
      key: "getInflationRate",
      value: function () {
        var _getInflationRate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee51() {
          var unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee51$(_context51) {
            while (1) switch (_context51.prev = _context51.next) {
              case 0:
                _context51.next = 2;
                return this._rpcRequest('getInflationRate', []);

              case 2:
                unsafeRes = _context51.sent;
                res = _create(unsafeRes, GetInflationRateRpcResult);

                if (!('error' in res)) {
                  _context51.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get inflation rate');

              case 6:
                return _context51.abrupt("return", res.result);

              case 7:
              case "end":
                return _context51.stop();
            }
          }, _callee51, this);
        }));

        function getInflationRate() {
          return _getInflationRate.apply(this, arguments);
        }

        return getInflationRate;
      }()
      /**
       * Fetch the Epoch Info parameters
       */

    }, {
      key: "getEpochInfo",
      value: function () {
        var _getEpochInfo = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee52(commitmentOrConfig) {
          var _extractCommitmentFro15, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee52$(_context52) {
            while (1) switch (_context52.prev = _context52.next) {
              case 0:
                _extractCommitmentFro15 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro15.commitment, config = _extractCommitmentFro15.config;
                args = this._buildArgs([], commitment, undefined
                /* encoding */
                , config);
                _context52.next = 4;
                return this._rpcRequest('getEpochInfo', args);

              case 4:
                unsafeRes = _context52.sent;
                res = _create(unsafeRes, GetEpochInfoRpcResult);

                if (!('error' in res)) {
                  _context52.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');

              case 8:
                return _context52.abrupt("return", res.result);

              case 9:
              case "end":
                return _context52.stop();
            }
          }, _callee52, this);
        }));

        function getEpochInfo(_x81) {
          return _getEpochInfo.apply(this, arguments);
        }

        return getEpochInfo;
      }()
      /**
       * Fetch the Epoch Schedule parameters
       */

    }, {
      key: "getEpochSchedule",
      value: function () {
        var _getEpochSchedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee53() {
          var unsafeRes, res, epochSchedule;
          return _regeneratorRuntime().wrap(function _callee53$(_context53) {
            while (1) switch (_context53.prev = _context53.next) {
              case 0:
                _context53.next = 2;
                return this._rpcRequest('getEpochSchedule', []);

              case 2:
                unsafeRes = _context53.sent;
                res = _create(unsafeRes, GetEpochScheduleRpcResult);

                if (!('error' in res)) {
                  _context53.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');

              case 6:
                epochSchedule = res.result;
                return _context53.abrupt("return", new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot));

              case 8:
              case "end":
                return _context53.stop();
            }
          }, _callee53, this);
        }));

        function getEpochSchedule() {
          return _getEpochSchedule.apply(this, arguments);
        }

        return getEpochSchedule;
      }()
      /**
       * Fetch the leader schedule for the current epoch
       * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}
       */

    }, {
      key: "getLeaderSchedule",
      value: function () {
        var _getLeaderSchedule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee54() {
          var unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee54$(_context54) {
            while (1) switch (_context54.prev = _context54.next) {
              case 0:
                _context54.next = 2;
                return this._rpcRequest('getLeaderSchedule', []);

              case 2:
                unsafeRes = _context54.sent;
                res = _create(unsafeRes, GetLeaderScheduleRpcResult);

                if (!('error' in res)) {
                  _context54.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');

              case 6:
                return _context54.abrupt("return", res.result);

              case 7:
              case "end":
                return _context54.stop();
            }
          }, _callee54, this);
        }));

        function getLeaderSchedule() {
          return _getLeaderSchedule.apply(this, arguments);
        }

        return getLeaderSchedule;
      }()
      /**
       * Fetch the minimum balance needed to exempt an account of `dataLength`
       * size from rent
       */

    }, {
      key: "getMinimumBalanceForRentExemption",
      value: function () {
        var _getMinimumBalanceForRentExemption = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee55(dataLength, commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee55$(_context55) {
            while (1) switch (_context55.prev = _context55.next) {
              case 0:
                args = this._buildArgs([dataLength], commitment);
                _context55.next = 3;
                return this._rpcRequest('getMinimumBalanceForRentExemption', args);

              case 3:
                unsafeRes = _context55.sent;
                res = _create(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);

                if (!('error' in res)) {
                  _context55.next = 8;
                  break;
                }

                console.warn('Unable to fetch minimum balance for rent exemption');
                return _context55.abrupt("return", 0);

              case 8:
                return _context55.abrupt("return", res.result);

              case 9:
              case "end":
                return _context55.stop();
            }
          }, _callee55, this);
        }));

        function getMinimumBalanceForRentExemption(_x82, _x83) {
          return _getMinimumBalanceForRentExemption.apply(this, arguments);
        }

        return getMinimumBalanceForRentExemption;
      }()
      /**
       * Fetch a recent blockhash from the cluster, return with context
       * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
       */

    }, {
      key: "getRecentBlockhashAndContext",
      value: function () {
        var _getRecentBlockhashAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee56(commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee56$(_context56) {
            while (1) switch (_context56.prev = _context56.next) {
              case 0:
                args = this._buildArgs([], commitment);
                _context56.next = 3;
                return this._rpcRequest('getRecentBlockhash', args);

              case 3:
                unsafeRes = _context56.sent;
                res = _create(unsafeRes, GetRecentBlockhashAndContextRpcResult);

                if (!('error' in res)) {
                  _context56.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get recent blockhash');

              case 7:
                return _context56.abrupt("return", res.result);

              case 8:
              case "end":
                return _context56.stop();
            }
          }, _callee56, this);
        }));

        function getRecentBlockhashAndContext(_x84) {
          return _getRecentBlockhashAndContext.apply(this, arguments);
        }

        return getRecentBlockhashAndContext;
      }()
      /**
       * Fetch recent performance samples
       * @return {Promise<Array<PerfSample>>}
       */

    }, {
      key: "getRecentPerformanceSamples",
      value: function () {
        var _getRecentPerformanceSamples = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee57(limit) {
          var unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee57$(_context57) {
            while (1) switch (_context57.prev = _context57.next) {
              case 0:
                _context57.next = 2;
                return this._rpcRequest('getRecentPerformanceSamples', limit ? [limit] : []);

              case 2:
                unsafeRes = _context57.sent;
                res = _create(unsafeRes, GetRecentPerformanceSamplesRpcResult);

                if (!('error' in res)) {
                  _context57.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get recent performance samples');

              case 6:
                return _context57.abrupt("return", res.result);

              case 7:
              case "end":
                return _context57.stop();
            }
          }, _callee57, this);
        }));

        function getRecentPerformanceSamples(_x85) {
          return _getRecentPerformanceSamples.apply(this, arguments);
        }

        return getRecentPerformanceSamples;
      }()
      /**
       * Fetch the fee calculator for a recent blockhash from the cluster, return with context
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.
       */

    }, {
      key: "getFeeCalculatorForBlockhash",
      value: function () {
        var _getFeeCalculatorForBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee58(blockhash, commitment) {
          var args, unsafeRes, res, _res$result, context, value;

          return _regeneratorRuntime().wrap(function _callee58$(_context58) {
            while (1) switch (_context58.prev = _context58.next) {
              case 0:
                args = this._buildArgs([blockhash], commitment);
                _context58.next = 3;
                return this._rpcRequest('getFeeCalculatorForBlockhash', args);

              case 3:
                unsafeRes = _context58.sent;
                res = _create(unsafeRes, GetFeeCalculatorRpcResult);

                if (!('error' in res)) {
                  _context58.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');

              case 7:
                _res$result = res.result, context = _res$result.context, value = _res$result.value;
                return _context58.abrupt("return", {
                  context: context,
                  value: value !== null ? value.feeCalculator : null
                });

              case 9:
              case "end":
                return _context58.stop();
            }
          }, _callee58, this);
        }));

        function getFeeCalculatorForBlockhash(_x86, _x87) {
          return _getFeeCalculatorForBlockhash.apply(this, arguments);
        }

        return getFeeCalculatorForBlockhash;
      }()
      /**
       * Fetch the fee for a message from the cluster, return with context
       */

    }, {
      key: "getFeeForMessage",
      value: function () {
        var _getFeeForMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee59(message, commitment) {
          var wireMessage, args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee59$(_context59) {
            while (1) switch (_context59.prev = _context59.next) {
              case 0:
                wireMessage = toBuffer(message.serialize()).toString('base64');
                args = this._buildArgs([wireMessage], commitment);
                _context59.next = 4;
                return this._rpcRequest('getFeeForMessage', args);

              case 4:
                unsafeRes = _context59.sent;
                res = _create(unsafeRes, jsonRpcResultAndContext(nullable(number())));

                if (!('error' in res)) {
                  _context59.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get fee for message');

              case 8:
                if (!(res.result === null)) {
                  _context59.next = 10;
                  break;
                }

                throw new Error('invalid blockhash');

              case 10:
                return _context59.abrupt("return", res.result);

              case 11:
              case "end":
                return _context59.stop();
            }
          }, _callee59, this);
        }));

        function getFeeForMessage(_x88, _x89) {
          return _getFeeForMessage.apply(this, arguments);
        }

        return getFeeForMessage;
      }()
      /**
       * Fetch a list of prioritization fees from recent blocks.
       */

    }, {
      key: "getRecentPrioritizationFees",
      value: function () {
        var _getRecentPrioritizationFees = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee60(config) {
          var _config$lockedWritabl;

          var accounts, args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee60$(_context60) {
            while (1) switch (_context60.prev = _context60.next) {
              case 0:
                accounts = config === null || config === void 0 ? void 0 : (_config$lockedWritabl = config.lockedWritableAccounts) === null || _config$lockedWritabl === void 0 ? void 0 : _config$lockedWritabl.map(function (key) {
                  return key.toBase58();
                });
                args = this._buildArgs(accounts !== null && accounts !== void 0 && accounts.length ? [accounts] : []);
                _context60.next = 4;
                return this._rpcRequest('getRecentPrioritizationFees', args);

              case 4:
                unsafeRes = _context60.sent;
                res = _create(unsafeRes, GetRecentPrioritizationFeesRpcResult);

                if (!('error' in res)) {
                  _context60.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get recent prioritization fees');

              case 8:
                return _context60.abrupt("return", res.result);

              case 9:
              case "end":
                return _context60.stop();
            }
          }, _callee60, this);
        }));

        function getRecentPrioritizationFees(_x90) {
          return _getRecentPrioritizationFees.apply(this, arguments);
        }

        return getRecentPrioritizationFees;
      }()
      /**
       * Fetch a recent blockhash from the cluster
       * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.
       */

    }, {
      key: "getRecentBlockhash",
      value: function () {
        var _getRecentBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee61(commitment) {
          var res;
          return _regeneratorRuntime().wrap(function _callee61$(_context61) {
            while (1) switch (_context61.prev = _context61.next) {
              case 0:
                _context61.prev = 0;
                _context61.next = 3;
                return this.getRecentBlockhashAndContext(commitment);

              case 3:
                res = _context61.sent;
                return _context61.abrupt("return", res.value);

              case 7:
                _context61.prev = 7;
                _context61.t0 = _context61["catch"](0);
                throw new Error('failed to get recent blockhash: ' + _context61.t0);

              case 10:
              case "end":
                return _context61.stop();
            }
          }, _callee61, this, [[0, 7]]);
        }));

        function getRecentBlockhash(_x91) {
          return _getRecentBlockhash.apply(this, arguments);
        }

        return getRecentBlockhash;
      }()
      /**
       * Fetch the latest blockhash from the cluster
       * @return {Promise<BlockhashWithExpiryBlockHeight>}
       */

    }, {
      key: "getLatestBlockhash",
      value: function () {
        var _getLatestBlockhash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee62(commitmentOrConfig) {
          var res;
          return _regeneratorRuntime().wrap(function _callee62$(_context62) {
            while (1) switch (_context62.prev = _context62.next) {
              case 0:
                _context62.prev = 0;
                _context62.next = 3;
                return this.getLatestBlockhashAndContext(commitmentOrConfig);

              case 3:
                res = _context62.sent;
                return _context62.abrupt("return", res.value);

              case 7:
                _context62.prev = 7;
                _context62.t0 = _context62["catch"](0);
                throw new Error('failed to get recent blockhash: ' + _context62.t0);

              case 10:
              case "end":
                return _context62.stop();
            }
          }, _callee62, this, [[0, 7]]);
        }));

        function getLatestBlockhash(_x92) {
          return _getLatestBlockhash.apply(this, arguments);
        }

        return getLatestBlockhash;
      }()
      /**
       * Fetch the latest blockhash from the cluster
       * @return {Promise<BlockhashWithExpiryBlockHeight>}
       */

    }, {
      key: "getLatestBlockhashAndContext",
      value: function () {
        var _getLatestBlockhashAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee63(commitmentOrConfig) {
          var _extractCommitmentFro16, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee63$(_context63) {
            while (1) switch (_context63.prev = _context63.next) {
              case 0:
                _extractCommitmentFro16 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro16.commitment, config = _extractCommitmentFro16.config;
                args = this._buildArgs([], commitment, undefined
                /* encoding */
                , config);
                _context63.next = 4;
                return this._rpcRequest('getLatestBlockhash', args);

              case 4:
                unsafeRes = _context63.sent;
                res = _create(unsafeRes, GetLatestBlockhashRpcResult);

                if (!('error' in res)) {
                  _context63.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');

              case 8:
                return _context63.abrupt("return", res.result);

              case 9:
              case "end":
                return _context63.stop();
            }
          }, _callee63, this);
        }));

        function getLatestBlockhashAndContext(_x93) {
          return _getLatestBlockhashAndContext.apply(this, arguments);
        }

        return getLatestBlockhashAndContext;
      }()
      /**
       * Fetch the node version
       */

    }, {
      key: "getVersion",
      value: function () {
        var _getVersion = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee64() {
          var unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee64$(_context64) {
            while (1) switch (_context64.prev = _context64.next) {
              case 0:
                _context64.next = 2;
                return this._rpcRequest('getVersion', []);

              case 2:
                unsafeRes = _context64.sent;
                res = _create(unsafeRes, jsonRpcResult(VersionResult));

                if (!('error' in res)) {
                  _context64.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get version');

              case 6:
                return _context64.abrupt("return", res.result);

              case 7:
              case "end":
                return _context64.stop();
            }
          }, _callee64, this);
        }));

        function getVersion() {
          return _getVersion.apply(this, arguments);
        }

        return getVersion;
      }()
      /**
       * Fetch the genesis hash
       */

    }, {
      key: "getGenesisHash",
      value: function () {
        var _getGenesisHash = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee65() {
          var unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee65$(_context65) {
            while (1) switch (_context65.prev = _context65.next) {
              case 0:
                _context65.next = 2;
                return this._rpcRequest('getGenesisHash', []);

              case 2:
                unsafeRes = _context65.sent;
                res = _create(unsafeRes, jsonRpcResult(string()));

                if (!('error' in res)) {
                  _context65.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');

              case 6:
                return _context65.abrupt("return", res.result);

              case 7:
              case "end":
                return _context65.stop();
            }
          }, _callee65, this);
        }));

        function getGenesisHash() {
          return _getGenesisHash.apply(this, arguments);
        }

        return getGenesisHash;
      }()
      /**
       * Fetch a processed block from the cluster.
       *
       * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by
       * setting the `maxSupportedTransactionVersion` property.
       */

      /**
       * Fetch a processed block from the cluster.
       */
      // eslint-disable-next-line no-dupe-class-members

    }, {
      key: "getBlock",
      value: function () {
        var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee66(slot, rawConfig) {
          var _extractCommitmentFro17, commitment, config, args, unsafeRes, res, _res, _res2, result;

          return _regeneratorRuntime().wrap(function _callee66$(_context66) {
            while (1) switch (_context66.prev = _context66.next) {
              case 0:
                _extractCommitmentFro17 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro17.commitment, config = _extractCommitmentFro17.config;
                args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined
                /* encoding */
                , config);
                _context66.next = 4;
                return this._rpcRequest('getBlock', args);

              case 4:
                unsafeRes = _context66.sent;
                _context66.prev = 5;
                _context66.t0 = config === null || config === void 0 ? void 0 : config.transactionDetails;
                _context66.next = _context66.t0 === 'accounts' ? 9 : _context66.t0 === 'none' ? 13 : 17;
                break;

              case 9:
                res = _create(unsafeRes, GetAccountsModeBlockRpcResult);

                if (!('error' in res)) {
                  _context66.next = 12;
                  break;
                }

                throw res.error;

              case 12:
                return _context66.abrupt("return", res.result);

              case 13:
                _res = _create(unsafeRes, GetNoneModeBlockRpcResult);

                if (!('error' in _res)) {
                  _context66.next = 16;
                  break;
                }

                throw _res.error;

              case 16:
                return _context66.abrupt("return", _res.result);

              case 17:
                _res2 = _create(unsafeRes, GetBlockRpcResult);

                if (!('error' in _res2)) {
                  _context66.next = 20;
                  break;
                }

                throw _res2.error;

              case 20:
                result = _res2.result;
                return _context66.abrupt("return", result ? _objectSpread2(_objectSpread2({}, result), {}, {
                  transactions: result.transactions.map(function (_ref36) {
                    var transaction = _ref36.transaction,
                        meta = _ref36.meta,
                        version = _ref36.version;
                    return {
                      meta: meta,
                      transaction: _objectSpread2(_objectSpread2({}, transaction), {}, {
                        message: versionedMessageFromResponse(version, transaction.message)
                      }),
                      version: version
                    };
                  })
                }) : null);

              case 22:
                _context66.next = 27;
                break;

              case 24:
                _context66.prev = 24;
                _context66.t1 = _context66["catch"](5);
                throw new SolanaJSONRPCError(_context66.t1, 'failed to get confirmed block');

              case 27:
              case "end":
                return _context66.stop();
            }
          }, _callee66, this, [[5, 24]]);
        }));

        function getBlock(_x94, _x95) {
          return _getBlock.apply(this, arguments);
        }

        return getBlock;
      }()
      /**
       * Fetch parsed transaction details for a confirmed or finalized block
       */
      // eslint-disable-next-line no-dupe-class-members

    }, {
      key: "getParsedBlock",
      value: function () {
        var _getParsedBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee67(slot, rawConfig) {
          var _extractCommitmentFro18, commitment, config, args, unsafeRes, res, _res3, _res4;

          return _regeneratorRuntime().wrap(function _callee67$(_context67) {
            while (1) switch (_context67.prev = _context67.next) {
              case 0:
                _extractCommitmentFro18 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro18.commitment, config = _extractCommitmentFro18.config;
                args = this._buildArgsAtLeastConfirmed([slot], commitment, 'jsonParsed', config);
                _context67.next = 4;
                return this._rpcRequest('getBlock', args);

              case 4:
                unsafeRes = _context67.sent;
                _context67.prev = 5;
                _context67.t0 = config === null || config === void 0 ? void 0 : config.transactionDetails;
                _context67.next = _context67.t0 === 'accounts' ? 9 : _context67.t0 === 'none' ? 13 : 17;
                break;

              case 9:
                res = _create(unsafeRes, GetParsedAccountsModeBlockRpcResult);

                if (!('error' in res)) {
                  _context67.next = 12;
                  break;
                }

                throw res.error;

              case 12:
                return _context67.abrupt("return", res.result);

              case 13:
                _res3 = _create(unsafeRes, GetParsedNoneModeBlockRpcResult);

                if (!('error' in _res3)) {
                  _context67.next = 16;
                  break;
                }

                throw _res3.error;

              case 16:
                return _context67.abrupt("return", _res3.result);

              case 17:
                _res4 = _create(unsafeRes, GetParsedBlockRpcResult);

                if (!('error' in _res4)) {
                  _context67.next = 20;
                  break;
                }

                throw _res4.error;

              case 20:
                return _context67.abrupt("return", _res4.result);

              case 21:
                _context67.next = 26;
                break;

              case 23:
                _context67.prev = 23;
                _context67.t1 = _context67["catch"](5);
                throw new SolanaJSONRPCError(_context67.t1, 'failed to get block');

              case 26:
              case "end":
                return _context67.stop();
            }
          }, _callee67, this, [[5, 23]]);
        }));

        function getParsedBlock(_x96, _x97) {
          return _getParsedBlock.apply(this, arguments);
        }

        return getParsedBlock;
      }()
      /*
       * Returns the current block height of the node
       */

      /*
       * Returns recent block production information from the current or previous epoch
       */

    }, {
      key: "getBlockProduction",
      value: function () {
        var _getBlockProduction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee68(configOrCommitment) {
          var extra, commitment, c, rest, args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee68$(_context68) {
            while (1) switch (_context68.prev = _context68.next) {
              case 0:
                if (typeof configOrCommitment === 'string') {
                  commitment = configOrCommitment;
                } else if (configOrCommitment) {
                  c = configOrCommitment.commitment, rest = _objectWithoutProperties(configOrCommitment, _excluded3);
                  commitment = c;
                  extra = rest;
                }

                args = this._buildArgs([], commitment, 'base64', extra);
                _context68.next = 4;
                return this._rpcRequest('getBlockProduction', args);

              case 4:
                unsafeRes = _context68.sent;
                res = _create(unsafeRes, BlockProductionResponseStruct);

                if (!('error' in res)) {
                  _context68.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get block production information');

              case 8:
                return _context68.abrupt("return", res.result);

              case 9:
              case "end":
                return _context68.stop();
            }
          }, _callee68, this);
        }));

        function getBlockProduction(_x98) {
          return _getBlockProduction.apply(this, arguments);
        }

        return getBlockProduction;
      }()
      /**
       * Fetch a confirmed or finalized transaction from the cluster.
       *
       * @deprecated Instead, call `getTransaction` using a
       * `GetVersionedTransactionConfig` by setting the
       * `maxSupportedTransactionVersion` property.
       */

      /**
       * Fetch a confirmed or finalized transaction from the cluster.
       */
      // eslint-disable-next-line no-dupe-class-members

    }, {
      key: "getTransaction",
      value: function () {
        var _getTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee69(signature, rawConfig) {
          var _extractCommitmentFro19, commitment, config, args, unsafeRes, res, result;

          return _regeneratorRuntime().wrap(function _callee69$(_context69) {
            while (1) switch (_context69.prev = _context69.next) {
              case 0:
                _extractCommitmentFro19 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro19.commitment, config = _extractCommitmentFro19.config;
                args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined
                /* encoding */
                , config);
                _context69.next = 4;
                return this._rpcRequest('getTransaction', args);

              case 4:
                unsafeRes = _context69.sent;
                res = _create(unsafeRes, GetTransactionRpcResult);

                if (!('error' in res)) {
                  _context69.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get transaction');

              case 8:
                result = res.result;

                if (result) {
                  _context69.next = 11;
                  break;
                }

                return _context69.abrupt("return", result);

              case 11:
                return _context69.abrupt("return", _objectSpread2(_objectSpread2({}, result), {}, {
                  transaction: _objectSpread2(_objectSpread2({}, result.transaction), {}, {
                    message: versionedMessageFromResponse(result.version, result.transaction.message)
                  })
                }));

              case 12:
              case "end":
                return _context69.stop();
            }
          }, _callee69, this);
        }));

        function getTransaction(_x99, _x100) {
          return _getTransaction.apply(this, arguments);
        }

        return getTransaction;
      }()
      /**
       * Fetch parsed transaction details for a confirmed or finalized transaction
       */

    }, {
      key: "getParsedTransaction",
      value: function () {
        var _getParsedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee70(signature, commitmentOrConfig) {
          var _extractCommitmentFro20, commitment, config, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee70$(_context70) {
            while (1) switch (_context70.prev = _context70.next) {
              case 0:
                _extractCommitmentFro20 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro20.commitment, config = _extractCommitmentFro20.config;
                args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);
                _context70.next = 4;
                return this._rpcRequest('getTransaction', args);

              case 4:
                unsafeRes = _context70.sent;
                res = _create(unsafeRes, GetParsedTransactionRpcResult);

                if (!('error' in res)) {
                  _context70.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get transaction');

              case 8:
                return _context70.abrupt("return", res.result);

              case 9:
              case "end":
                return _context70.stop();
            }
          }, _callee70, this);
        }));

        function getParsedTransaction(_x101, _x102) {
          return _getParsedTransaction.apply(this, arguments);
        }

        return getParsedTransaction;
      }()
      /**
       * Fetch parsed transaction details for a batch of confirmed transactions
       */

    }, {
      key: "getParsedTransactions",
      value: function () {
        var _getParsedTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee71(signatures, commitmentOrConfig) {
          var _this20 = this;

          var _extractCommitmentFro21, commitment, config, batch, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee71$(_context71) {
            while (1) switch (_context71.prev = _context71.next) {
              case 0:
                _extractCommitmentFro21 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro21.commitment, config = _extractCommitmentFro21.config;
                batch = signatures.map(function (signature) {
                  var args = _this20._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);

                  return {
                    methodName: 'getTransaction',
                    args: args
                  };
                });
                _context71.next = 4;
                return this._rpcBatchRequest(batch);

              case 4:
                unsafeRes = _context71.sent;
                res = unsafeRes.map(function (unsafeRes) {
                  var res = _create(unsafeRes, GetParsedTransactionRpcResult);

                  if ('error' in res) {
                    throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
                  }

                  return res.result;
                });
                return _context71.abrupt("return", res);

              case 7:
              case "end":
                return _context71.stop();
            }
          }, _callee71, this);
        }));

        function getParsedTransactions(_x103, _x104) {
          return _getParsedTransactions.apply(this, arguments);
        }

        return getParsedTransactions;
      }()
      /**
       * Fetch transaction details for a batch of confirmed transactions.
       * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.
       *
       * @deprecated Instead, call `getTransactions` using a
       * `GetVersionedTransactionConfig` by setting the
       * `maxSupportedTransactionVersion` property.
       */

      /**
       * Fetch transaction details for a batch of confirmed transactions.
       * Similar to {@link getParsedTransactions} but returns a {@link
       * VersionedTransactionResponse}.
       */
      // eslint-disable-next-line no-dupe-class-members

    }, {
      key: "getTransactions",
      value: function () {
        var _getTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee72(signatures, commitmentOrConfig) {
          var _this21 = this;

          var _extractCommitmentFro22, commitment, config, batch, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee72$(_context72) {
            while (1) switch (_context72.prev = _context72.next) {
              case 0:
                _extractCommitmentFro22 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro22.commitment, config = _extractCommitmentFro22.config;
                batch = signatures.map(function (signature) {
                  var args = _this21._buildArgsAtLeastConfirmed([signature], commitment, undefined
                  /* encoding */
                  , config);

                  return {
                    methodName: 'getTransaction',
                    args: args
                  };
                });
                _context72.next = 4;
                return this._rpcBatchRequest(batch);

              case 4:
                unsafeRes = _context72.sent;
                res = unsafeRes.map(function (unsafeRes) {
                  var res = _create(unsafeRes, GetTransactionRpcResult);

                  if ('error' in res) {
                    throw new SolanaJSONRPCError(res.error, 'failed to get transactions');
                  }

                  var result = res.result;
                  if (!result) return result;
                  return _objectSpread2(_objectSpread2({}, result), {}, {
                    transaction: _objectSpread2(_objectSpread2({}, result.transaction), {}, {
                      message: versionedMessageFromResponse(result.version, result.transaction.message)
                    })
                  });
                });
                return _context72.abrupt("return", res);

              case 7:
              case "end":
                return _context72.stop();
            }
          }, _callee72, this);
        }));

        function getTransactions(_x105, _x106) {
          return _getTransactions.apply(this, arguments);
        }

        return getTransactions;
      }()
      /**
       * Fetch a list of Transactions and transaction statuses from the cluster
       * for a confirmed block.
       *
       * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.
       */

    }, {
      key: "getConfirmedBlock",
      value: function () {
        var _getConfirmedBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee73(slot, commitment) {
          var args, unsafeRes, res, result, block;
          return _regeneratorRuntime().wrap(function _callee73$(_context73) {
            while (1) switch (_context73.prev = _context73.next) {
              case 0:
                args = this._buildArgsAtLeastConfirmed([slot], commitment);
                _context73.next = 3;
                return this._rpcRequest('getConfirmedBlock', args);

              case 3:
                unsafeRes = _context73.sent;
                res = _create(unsafeRes, GetConfirmedBlockRpcResult);

                if (!('error' in res)) {
                  _context73.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');

              case 7:
                result = res.result;

                if (result) {
                  _context73.next = 10;
                  break;
                }

                throw new Error('Confirmed block ' + slot + ' not found');

              case 10:
                block = _objectSpread2(_objectSpread2({}, result), {}, {
                  transactions: result.transactions.map(function (_ref37) {
                    var transaction = _ref37.transaction,
                        meta = _ref37.meta;
                    var message = new Message(transaction.message);
                    return {
                      meta: meta,
                      transaction: _objectSpread2(_objectSpread2({}, transaction), {}, {
                        message: message
                      })
                    };
                  })
                });
                return _context73.abrupt("return", _objectSpread2(_objectSpread2({}, block), {}, {
                  transactions: block.transactions.map(function (_ref38) {
                    var transaction = _ref38.transaction,
                        meta = _ref38.meta;
                    return {
                      meta: meta,
                      transaction: Transaction$1.populate(transaction.message, transaction.signatures)
                    };
                  })
                }));

              case 12:
              case "end":
                return _context73.stop();
            }
          }, _callee73, this);
        }));

        function getConfirmedBlock(_x107, _x108) {
          return _getConfirmedBlock.apply(this, arguments);
        }

        return getConfirmedBlock;
      }()
      /**
       * Fetch confirmed blocks between two slots
       */

    }, {
      key: "getBlocks",
      value: function () {
        var _getBlocks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee74(startSlot, endSlot, commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee74$(_context74) {
            while (1) switch (_context74.prev = _context74.next) {
              case 0:
                args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);
                _context74.next = 3;
                return this._rpcRequest('getBlocks', args);

              case 3:
                unsafeRes = _context74.sent;
                res = _create(unsafeRes, jsonRpcResult(array(number())));

                if (!('error' in res)) {
                  _context74.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get blocks');

              case 7:
                return _context74.abrupt("return", res.result);

              case 8:
              case "end":
                return _context74.stop();
            }
          }, _callee74, this);
        }));

        function getBlocks(_x109, _x110, _x111) {
          return _getBlocks.apply(this, arguments);
        }

        return getBlocks;
      }()
      /**
       * Fetch a list of Signatures from the cluster for a block, excluding rewards
       */

    }, {
      key: "getBlockSignatures",
      value: function () {
        var _getBlockSignatures = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee75(slot, commitment) {
          var args, unsafeRes, res, result;
          return _regeneratorRuntime().wrap(function _callee75$(_context75) {
            while (1) switch (_context75.prev = _context75.next) {
              case 0:
                args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
                  transactionDetails: 'signatures',
                  rewards: false
                });
                _context75.next = 3;
                return this._rpcRequest('getBlock', args);

              case 3:
                unsafeRes = _context75.sent;
                res = _create(unsafeRes, GetBlockSignaturesRpcResult);

                if (!('error' in res)) {
                  _context75.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get block');

              case 7:
                result = res.result;

                if (result) {
                  _context75.next = 10;
                  break;
                }

                throw new Error('Block ' + slot + ' not found');

              case 10:
                return _context75.abrupt("return", result);

              case 11:
              case "end":
                return _context75.stop();
            }
          }, _callee75, this);
        }));

        function getBlockSignatures(_x112, _x113) {
          return _getBlockSignatures.apply(this, arguments);
        }

        return getBlockSignatures;
      }()
      /**
       * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.
       */

    }, {
      key: "getConfirmedBlockSignatures",
      value: function () {
        var _getConfirmedBlockSignatures = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee76(slot, commitment) {
          var args, unsafeRes, res, result;
          return _regeneratorRuntime().wrap(function _callee76$(_context76) {
            while (1) switch (_context76.prev = _context76.next) {
              case 0:
                args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {
                  transactionDetails: 'signatures',
                  rewards: false
                });
                _context76.next = 3;
                return this._rpcRequest('getConfirmedBlock', args);

              case 3:
                unsafeRes = _context76.sent;
                res = _create(unsafeRes, GetBlockSignaturesRpcResult);

                if (!('error' in res)) {
                  _context76.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');

              case 7:
                result = res.result;

                if (result) {
                  _context76.next = 10;
                  break;
                }

                throw new Error('Confirmed block ' + slot + ' not found');

              case 10:
                return _context76.abrupt("return", result);

              case 11:
              case "end":
                return _context76.stop();
            }
          }, _callee76, this);
        }));

        function getConfirmedBlockSignatures(_x114, _x115) {
          return _getConfirmedBlockSignatures.apply(this, arguments);
        }

        return getConfirmedBlockSignatures;
      }()
      /**
       * Fetch a transaction details for a confirmed transaction
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.
       */

    }, {
      key: "getConfirmedTransaction",
      value: function () {
        var _getConfirmedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee77(signature, commitment) {
          var args, unsafeRes, res, result, message, signatures;
          return _regeneratorRuntime().wrap(function _callee77$(_context77) {
            while (1) switch (_context77.prev = _context77.next) {
              case 0:
                args = this._buildArgsAtLeastConfirmed([signature], commitment);
                _context77.next = 3;
                return this._rpcRequest('getConfirmedTransaction', args);

              case 3:
                unsafeRes = _context77.sent;
                res = _create(unsafeRes, GetTransactionRpcResult);

                if (!('error' in res)) {
                  _context77.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get transaction');

              case 7:
                result = res.result;

                if (result) {
                  _context77.next = 10;
                  break;
                }

                return _context77.abrupt("return", result);

              case 10:
                message = new Message(result.transaction.message);
                signatures = result.transaction.signatures;
                return _context77.abrupt("return", _objectSpread2(_objectSpread2({}, result), {}, {
                  transaction: Transaction$1.populate(message, signatures)
                }));

              case 13:
              case "end":
                return _context77.stop();
            }
          }, _callee77, this);
        }));

        function getConfirmedTransaction(_x116, _x117) {
          return _getConfirmedTransaction.apply(this, arguments);
        }

        return getConfirmedTransaction;
      }()
      /**
       * Fetch parsed transaction details for a confirmed transaction
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.
       */

    }, {
      key: "getParsedConfirmedTransaction",
      value: function () {
        var _getParsedConfirmedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee78(signature, commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee78$(_context78) {
            while (1) switch (_context78.prev = _context78.next) {
              case 0:
                args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');
                _context78.next = 3;
                return this._rpcRequest('getConfirmedTransaction', args);

              case 3:
                unsafeRes = _context78.sent;
                res = _create(unsafeRes, GetParsedTransactionRpcResult);

                if (!('error' in res)) {
                  _context78.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transaction');

              case 7:
                return _context78.abrupt("return", res.result);

              case 8:
              case "end":
                return _context78.stop();
            }
          }, _callee78, this);
        }));

        function getParsedConfirmedTransaction(_x118, _x119) {
          return _getParsedConfirmedTransaction.apply(this, arguments);
        }

        return getParsedConfirmedTransaction;
      }()
      /**
       * Fetch parsed transaction details for a batch of confirmed transactions
       *
       * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.
       */

    }, {
      key: "getParsedConfirmedTransactions",
      value: function () {
        var _getParsedConfirmedTransactions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee79(signatures, commitment) {
          var _this22 = this;

          var batch, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee79$(_context79) {
            while (1) switch (_context79.prev = _context79.next) {
              case 0:
                batch = signatures.map(function (signature) {
                  var args = _this22._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');

                  return {
                    methodName: 'getConfirmedTransaction',
                    args: args
                  };
                });
                _context79.next = 3;
                return this._rpcBatchRequest(batch);

              case 3:
                unsafeRes = _context79.sent;
                res = unsafeRes.map(function (unsafeRes) {
                  var res = _create(unsafeRes, GetParsedTransactionRpcResult);

                  if ('error' in res) {
                    throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transactions');
                  }

                  return res.result;
                });
                return _context79.abrupt("return", res);

              case 6:
              case "end":
                return _context79.stop();
            }
          }, _callee79, this);
        }));

        function getParsedConfirmedTransactions(_x120, _x121) {
          return _getParsedConfirmedTransactions.apply(this, arguments);
        }

        return getParsedConfirmedTransactions;
      }()
      /**
       * Fetch a list of all the confirmed signatures for transactions involving an address
       * within a specified slot range. Max range allowed is 10,000 slots.
       *
       * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.
       *
       * @param address queried address
       * @param startSlot start slot, inclusive
       * @param endSlot end slot, inclusive
       */

    }, {
      key: "getConfirmedSignaturesForAddress",
      value: function () {
        var _getConfirmedSignaturesForAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee80(address, startSlot, endSlot) {
          var options, firstAvailableBlock, block, highestConfirmedRoot, _block, confirmedSignatureInfo;

          return _regeneratorRuntime().wrap(function _callee80$(_context80) {
            while (1) switch (_context80.prev = _context80.next) {
              case 0:
                options = {};
                _context80.next = 3;
                return this.getFirstAvailableBlock();

              case 3:
                firstAvailableBlock = _context80.sent;

              case 4:
                if ('until' in options) {
                  _context80.next = 24;
                  break;
                }

                startSlot--;

                if (!(startSlot <= 0 || startSlot < firstAvailableBlock)) {
                  _context80.next = 8;
                  break;
                }

                return _context80.abrupt("break", 24);

              case 8:
                _context80.prev = 8;
                _context80.next = 11;
                return this.getConfirmedBlockSignatures(startSlot, 'finalized');

              case 11:
                block = _context80.sent;

                if (block.signatures.length > 0) {
                  options.until = block.signatures[block.signatures.length - 1].toString();
                }

                _context80.next = 22;
                break;

              case 15:
                _context80.prev = 15;
                _context80.t0 = _context80["catch"](8);

                if (!(_context80.t0 instanceof Error && _context80.t0.message.includes('skipped'))) {
                  _context80.next = 21;
                  break;
                }

                return _context80.abrupt("continue", 4);

              case 21:
                throw _context80.t0;

              case 22:
                _context80.next = 4;
                break;

              case 24:
                _context80.next = 26;
                return this.getSlot('finalized');

              case 26:
                highestConfirmedRoot = _context80.sent;

              case 27:
                if ('before' in options) {
                  _context80.next = 47;
                  break;
                }

                endSlot++;

                if (!(endSlot > highestConfirmedRoot)) {
                  _context80.next = 31;
                  break;
                }

                return _context80.abrupt("break", 47);

              case 31:
                _context80.prev = 31;
                _context80.next = 34;
                return this.getConfirmedBlockSignatures(endSlot);

              case 34:
                _block = _context80.sent;

                if (_block.signatures.length > 0) {
                  options.before = _block.signatures[_block.signatures.length - 1].toString();
                }

                _context80.next = 45;
                break;

              case 38:
                _context80.prev = 38;
                _context80.t1 = _context80["catch"](31);

                if (!(_context80.t1 instanceof Error && _context80.t1.message.includes('skipped'))) {
                  _context80.next = 44;
                  break;
                }

                return _context80.abrupt("continue", 27);

              case 44:
                throw _context80.t1;

              case 45:
                _context80.next = 27;
                break;

              case 47:
                _context80.next = 49;
                return this.getConfirmedSignaturesForAddress2(address, options);

              case 49:
                confirmedSignatureInfo = _context80.sent;
                return _context80.abrupt("return", confirmedSignatureInfo.map(function (info) {
                  return info.signature;
                }));

              case 51:
              case "end":
                return _context80.stop();
            }
          }, _callee80, this, [[8, 15], [31, 38]]);
        }));

        function getConfirmedSignaturesForAddress(_x122, _x123, _x124) {
          return _getConfirmedSignaturesForAddress.apply(this, arguments);
        }

        return getConfirmedSignaturesForAddress;
      }()
      /**
       * Returns confirmed signatures for transactions involving an
       * address backwards in time from the provided signature or most recent confirmed block
       *
       *
       * @param address queried address
       * @param options
       */

    }, {
      key: "getConfirmedSignaturesForAddress2",
      value: function () {
        var _getConfirmedSignaturesForAddress2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee81(address, options, commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee81$(_context81) {
            while (1) switch (_context81.prev = _context81.next) {
              case 0:
                args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
                _context81.next = 3;
                return this._rpcRequest('getConfirmedSignaturesForAddress2', args);

              case 3:
                unsafeRes = _context81.sent;
                res = _create(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);

                if (!('error' in res)) {
                  _context81.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get confirmed signatures for address');

              case 7:
                return _context81.abrupt("return", res.result);

              case 8:
              case "end":
                return _context81.stop();
            }
          }, _callee81, this);
        }));

        function getConfirmedSignaturesForAddress2(_x125, _x126, _x127) {
          return _getConfirmedSignaturesForAddress2.apply(this, arguments);
        }

        return getConfirmedSignaturesForAddress2;
      }()
      /**
       * Returns confirmed signatures for transactions involving an
       * address backwards in time from the provided signature or most recent confirmed block
       *
       *
       * @param address queried address
       * @param options
       */

    }, {
      key: "getSignaturesForAddress",
      value: function () {
        var _getSignaturesForAddress = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee82(address, options, commitment) {
          var args, unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee82$(_context82) {
            while (1) switch (_context82.prev = _context82.next) {
              case 0:
                args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);
                _context82.next = 3;
                return this._rpcRequest('getSignaturesForAddress', args);

              case 3:
                unsafeRes = _context82.sent;
                res = _create(unsafeRes, GetSignaturesForAddressRpcResult);

                if (!('error' in res)) {
                  _context82.next = 7;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, 'failed to get signatures for address');

              case 7:
                return _context82.abrupt("return", res.result);

              case 8:
              case "end":
                return _context82.stop();
            }
          }, _callee82, this);
        }));

        function getSignaturesForAddress(_x128, _x129, _x130) {
          return _getSignaturesForAddress.apply(this, arguments);
        }

        return getSignaturesForAddress;
      }()
    }, {
      key: "getAddressLookupTable",
      value: function () {
        var _getAddressLookupTable = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee83(accountKey, config) {
          var _yield$this$getAccoun, context, accountInfo, value;

          return _regeneratorRuntime().wrap(function _callee83$(_context83) {
            while (1) switch (_context83.prev = _context83.next) {
              case 0:
                _context83.next = 2;
                return this.getAccountInfoAndContext(accountKey, config);

              case 2:
                _yield$this$getAccoun = _context83.sent;
                context = _yield$this$getAccoun.context;
                accountInfo = _yield$this$getAccoun.value;
                value = null;

                if (accountInfo !== null) {
                  value = new AddressLookupTableAccount({
                    key: accountKey,
                    state: AddressLookupTableAccount.deserialize(accountInfo.data)
                  });
                }

                return _context83.abrupt("return", {
                  context: context,
                  value: value
                });

              case 8:
              case "end":
                return _context83.stop();
            }
          }, _callee83, this);
        }));

        function getAddressLookupTable(_x131, _x132) {
          return _getAddressLookupTable.apply(this, arguments);
        }

        return getAddressLookupTable;
      }()
      /**
       * Fetch the contents of a Nonce account from the cluster, return with context
       */

    }, {
      key: "getNonceAndContext",
      value: function () {
        var _getNonceAndContext = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee84(nonceAccount, commitmentOrConfig) {
          var _yield$this$getAccoun2, context, accountInfo, value;

          return _regeneratorRuntime().wrap(function _callee84$(_context84) {
            while (1) switch (_context84.prev = _context84.next) {
              case 0:
                _context84.next = 2;
                return this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);

              case 2:
                _yield$this$getAccoun2 = _context84.sent;
                context = _yield$this$getAccoun2.context;
                accountInfo = _yield$this$getAccoun2.value;
                value = null;

                if (accountInfo !== null) {
                  value = NonceAccount.fromAccountData(accountInfo.data);
                }

                return _context84.abrupt("return", {
                  context: context,
                  value: value
                });

              case 8:
              case "end":
                return _context84.stop();
            }
          }, _callee84, this);
        }));

        function getNonceAndContext(_x133, _x134) {
          return _getNonceAndContext.apply(this, arguments);
        }

        return getNonceAndContext;
      }()
      /**
       * Fetch the contents of a Nonce account from the cluster
       */

    }, {
      key: "getNonce",
      value: function () {
        var _getNonce = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee85(nonceAccount, commitmentOrConfig) {
          return _regeneratorRuntime().wrap(function _callee85$(_context85) {
            while (1) switch (_context85.prev = _context85.next) {
              case 0:
                _context85.next = 2;
                return this.getNonceAndContext(nonceAccount, commitmentOrConfig).then(function (x) {
                  return x.value;
                })["catch"](function (e) {
                  throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);
                });

              case 2:
                return _context85.abrupt("return", _context85.sent);

              case 3:
              case "end":
                return _context85.stop();
            }
          }, _callee85, this);
        }));

        function getNonce(_x135, _x136) {
          return _getNonce.apply(this, arguments);
        }

        return getNonce;
      }()
      /**
       * Request an allocation of lamports to the specified address
       *
       * ```typescript
       * import { Connection, PublicKey, LAMPORTS_PER_SOL } from "@solana/web3.js";
       *
       * (async () => {
       *   const connection = new Connection("https://api.testnet.solana.com", "confirmed");
       *   const myAddress = new PublicKey("2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM");
       *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);
       *   await connection.confirmTransaction(signature);
       * })();
       * ```
       */

    }, {
      key: "requestAirdrop",
      value: function () {
        var _requestAirdrop = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee86(to, lamports) {
          var unsafeRes, res;
          return _regeneratorRuntime().wrap(function _callee86$(_context86) {
            while (1) switch (_context86.prev = _context86.next) {
              case 0:
                _context86.next = 2;
                return this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);

              case 2:
                unsafeRes = _context86.sent;
                res = _create(unsafeRes, RequestAirdropRpcResult);

                if (!('error' in res)) {
                  _context86.next = 6;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "airdrop to ".concat(to.toBase58(), " failed"));

              case 6:
                return _context86.abrupt("return", res.result);

              case 7:
              case "end":
                return _context86.stop();
            }
          }, _callee86, this);
        }));

        function requestAirdrop(_x137, _x138) {
          return _requestAirdrop.apply(this, arguments);
        }

        return requestAirdrop;
      }()
      /**
       * @internal
       */

    }, {
      key: "_blockhashWithExpiryBlockHeight",
      value: function () {
        var _blockhashWithExpiryBlockHeight2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee87(disableCache) {
          var timeSinceFetch, expired;
          return _regeneratorRuntime().wrap(function _callee87$(_context87) {
            while (1) switch (_context87.prev = _context87.next) {
              case 0:
                if (disableCache) {
                  _context87.next = 10;
                  break;
                }

              case 1:
                if (!this._pollingBlockhash) {
                  _context87.next = 6;
                  break;
                }

                _context87.next = 4;
                return sleep(100);

              case 4:
                _context87.next = 1;
                break;

              case 6:
                timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;
                expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;

                if (!(this._blockhashInfo.latestBlockhash !== null && !expired)) {
                  _context87.next = 10;
                  break;
                }

                return _context87.abrupt("return", this._blockhashInfo.latestBlockhash);

              case 10:
                _context87.next = 12;
                return this._pollNewBlockhash();

              case 12:
                return _context87.abrupt("return", _context87.sent);

              case 13:
              case "end":
                return _context87.stop();
            }
          }, _callee87, this);
        }));

        function _blockhashWithExpiryBlockHeight(_x139) {
          return _blockhashWithExpiryBlockHeight2.apply(this, arguments);
        }

        return _blockhashWithExpiryBlockHeight;
      }()
      /**
       * @internal
       */

    }, {
      key: "_pollNewBlockhash",
      value: function () {
        var _pollNewBlockhash2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee88() {
          var startTime, cachedLatestBlockhash, cachedBlockhash, i, latestBlockhash;
          return _regeneratorRuntime().wrap(function _callee88$(_context88) {
            while (1) switch (_context88.prev = _context88.next) {
              case 0:
                this._pollingBlockhash = true;
                _context88.prev = 1;
                startTime = Date.now();
                cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;
                cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;
                i = 0;

              case 6:
                if (!(i < 50)) {
                  _context88.next = 18;
                  break;
                }

                _context88.next = 9;
                return this.getLatestBlockhash('finalized');

              case 9:
                latestBlockhash = _context88.sent;

                if (!(cachedBlockhash !== latestBlockhash.blockhash)) {
                  _context88.next = 13;
                  break;
                }

                this._blockhashInfo = {
                  latestBlockhash: latestBlockhash,
                  lastFetch: Date.now(),
                  transactionSignatures: [],
                  simulatedSignatures: []
                };
                return _context88.abrupt("return", latestBlockhash);

              case 13:
                _context88.next = 15;
                return sleep(MS_PER_SLOT / 2);

              case 15:
                i++;
                _context88.next = 6;
                break;

              case 18:
                throw new Error("Unable to obtain a new blockhash after ".concat(Date.now() - startTime, "ms"));

              case 19:
                _context88.prev = 19;
                this._pollingBlockhash = false;
                return _context88.finish(19);

              case 22:
              case "end":
                return _context88.stop();
            }
          }, _callee88, this, [[1,, 19, 22]]);
        }));

        function _pollNewBlockhash() {
          return _pollNewBlockhash2.apply(this, arguments);
        }

        return _pollNewBlockhash;
      }()
      /**
       * get the stake minimum delegation
       */

    }, {
      key: "getStakeMinimumDelegation",
      value: function () {
        var _getStakeMinimumDelegation = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee89(config) {
          var _extractCommitmentFro23, commitment, configArg, args, unsafeRes, res;

          return _regeneratorRuntime().wrap(function _callee89$(_context89) {
            while (1) switch (_context89.prev = _context89.next) {
              case 0:
                _extractCommitmentFro23 = extractCommitmentFromConfig(config), commitment = _extractCommitmentFro23.commitment, configArg = _extractCommitmentFro23.config;
                args = this._buildArgs([], commitment, 'base64', configArg);
                _context89.next = 4;
                return this._rpcRequest('getStakeMinimumDelegation', args);

              case 4:
                unsafeRes = _context89.sent;
                res = _create(unsafeRes, jsonRpcResultAndContext(number()));

                if (!('error' in res)) {
                  _context89.next = 8;
                  break;
                }

                throw new SolanaJSONRPCError(res.error, "failed to get stake minimum delegation");

              case 8:
                return _context89.abrupt("return", res.result);

              case 9:
              case "end":
                return _context89.stop();
            }
          }, _callee89, this);
        }));

        function getStakeMinimumDelegation(_x140) {
          return _getStakeMinimumDelegation.apply(this, arguments);
        }

        return getStakeMinimumDelegation;
      }()
      /**
       * Simulate a transaction
       *
       * @deprecated Instead, call {@link simulateTransaction} with {@link
       * VersionedTransaction} and {@link SimulateTransactionConfig} parameters
       */

      /**
       * Simulate a transaction
       */
      // eslint-disable-next-line no-dupe-class-members

    }, {
      key: "simulateTransaction",
      value: function () {
        var _simulateTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee90(transactionOrMessage, configOrSigners, includeAccounts) {
          var versionedTx, _wireTransaction, _encodedTransaction, _config, _args91, _unsafeRes, _res5, transaction, originalTx, signers, _transaction3, disableCache, _transaction4, latestBlockhash, _signature3, message, signData, wireTransaction, encodedTransaction, config, addresses, args, unsafeRes, res, logs, traceIndent, logTrace;

          return _regeneratorRuntime().wrap(function _callee90$(_context90) {
            while (1) switch (_context90.prev = _context90.next) {
              case 0:
                if (!('message' in transactionOrMessage)) {
                  _context90.next = 17;
                  break;
                }

                versionedTx = transactionOrMessage;
                _wireTransaction = versionedTx.serialize();
                _encodedTransaction = Buffer$1.from(_wireTransaction).toString('base64');

                if (!(Array.isArray(configOrSigners) || includeAccounts !== undefined)) {
                  _context90.next = 6;
                  break;
                }

                throw new Error('Invalid arguments');

              case 6:
                _config = configOrSigners || {};
                _config.encoding = 'base64';

                if (!('commitment' in _config)) {
                  _config.commitment = this.commitment;
                }

                _args91 = [_encodedTransaction, _config];
                _context90.next = 12;
                return this._rpcRequest('simulateTransaction', _args91);

              case 12:
                _unsafeRes = _context90.sent;
                _res5 = _create(_unsafeRes, SimulatedTransactionResponseStruct);

                if (!('error' in _res5)) {
                  _context90.next = 16;
                  break;
                }

                throw new Error('failed to simulate transaction: ' + _res5.error.message);

              case 16:
                return _context90.abrupt("return", _res5.result);

              case 17:
                if (transactionOrMessage instanceof Transaction$1) {
                  originalTx = transactionOrMessage;
                  transaction = new Transaction$1();
                  transaction.feePayer = originalTx.feePayer;
                  transaction.instructions = transactionOrMessage.instructions;
                  transaction.nonceInfo = originalTx.nonceInfo;
                  transaction.signatures = originalTx.signatures;
                } else {
                  transaction = Transaction$1.populate(transactionOrMessage); // HACK: this function relies on mutating the populated transaction

                  transaction._message = transaction._json = undefined;
                }

                if (!(configOrSigners !== undefined && !Array.isArray(configOrSigners))) {
                  _context90.next = 20;
                  break;
                }

                throw new Error('Invalid arguments');

              case 20:
                signers = configOrSigners;

                if (!(transaction.nonceInfo && signers)) {
                  _context90.next = 25;
                  break;
                }

                (_transaction3 = transaction).sign.apply(_transaction3, _toConsumableArray(signers));

                _context90.next = 45;
                break;

              case 25:
                disableCache = this._disableBlockhashCaching;

              case 26:
                _context90.next = 28;
                return this._blockhashWithExpiryBlockHeight(disableCache);

              case 28:
                latestBlockhash = _context90.sent;
                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
                transaction.recentBlockhash = latestBlockhash.blockhash;

                if (signers) {
                  _context90.next = 33;
                  break;
                }

                return _context90.abrupt("break", 45);

              case 33:
                (_transaction4 = transaction).sign.apply(_transaction4, _toConsumableArray(signers));

                if (transaction.signature) {
                  _context90.next = 36;
                  break;
                }

                throw new Error('!signature');

              case 36:
                _signature3 = transaction.signature.toString('base64');

                if (!(!this._blockhashInfo.simulatedSignatures.includes(_signature3) && !this._blockhashInfo.transactionSignatures.includes(_signature3))) {
                  _context90.next = 42;
                  break;
                }

                // The signature of this transaction has not been seen before with the
                // current recentBlockhash, all done. Let's break
                this._blockhashInfo.simulatedSignatures.push(_signature3);

                return _context90.abrupt("break", 45);

              case 42:
                // This transaction would be treated as duplicate (its derived signature
                // matched to one of already recorded signatures).
                // So, we must fetch a new blockhash for a different signature by disabling
                // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
                disableCache = true;

              case 43:
                _context90.next = 26;
                break;

              case 45:
                message = transaction._compile();
                signData = message.serialize();
                wireTransaction = transaction._serialize(signData);
                encodedTransaction = wireTransaction.toString('base64');
                config = {
                  encoding: 'base64',
                  commitment: this.commitment
                };

                if (includeAccounts) {
                  addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(function (key) {
                    return key.toBase58();
                  });
                  config['accounts'] = {
                    encoding: 'base64',
                    addresses: addresses
                  };
                }

                if (signers) {
                  config.sigVerify = true;
                }

                args = [encodedTransaction, config];
                _context90.next = 55;
                return this._rpcRequest('simulateTransaction', args);

              case 55:
                unsafeRes = _context90.sent;
                res = _create(unsafeRes, SimulatedTransactionResponseStruct);

                if (!('error' in res)) {
                  _context90.next = 60;
                  break;
                }

                if ('data' in res.error) {
                  logs = res.error.data.logs;

                  if (logs && Array.isArray(logs)) {
                    traceIndent = '\n    ';
                    logTrace = traceIndent + logs.join(traceIndent);
                    console.error(res.error.message, logTrace);
                  }
                }

                throw new SendTransactionError('failed to simulate transaction: ' + res.error.message, logs);

              case 60:
                return _context90.abrupt("return", res.result);

              case 61:
              case "end":
                return _context90.stop();
            }
          }, _callee90, this);
        }));

        function simulateTransaction(_x141, _x142, _x143) {
          return _simulateTransaction.apply(this, arguments);
        }

        return simulateTransaction;
      }()
      /**
       * Sign and send a transaction
       *
       * @deprecated Instead, call {@link sendTransaction} with a {@link
       * VersionedTransaction}
       */

      /**
       * Sign and send a transaction
       */
      // eslint-disable-next-line no-dupe-class-members

    }, {
      key: "sendTransaction",
      value: function () {
        var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee91(transaction, signersOrOptions, options) {
          var _wireTransaction2, signers, disableCache, latestBlockhash, _signature4, wireTransaction;

          return _regeneratorRuntime().wrap(function _callee91$(_context91) {
            while (1) switch (_context91.prev = _context91.next) {
              case 0:
                if (!('version' in transaction)) {
                  _context91.next = 7;
                  break;
                }

                if (!(signersOrOptions && Array.isArray(signersOrOptions))) {
                  _context91.next = 3;
                  break;
                }

                throw new Error('Invalid arguments');

              case 3:
                _wireTransaction2 = transaction.serialize();
                _context91.next = 6;
                return this.sendRawTransaction(_wireTransaction2, signersOrOptions);

              case 6:
                return _context91.abrupt("return", _context91.sent);

              case 7:
                if (!(signersOrOptions === undefined || !Array.isArray(signersOrOptions))) {
                  _context91.next = 9;
                  break;
                }

                throw new Error('Invalid arguments');

              case 9:
                signers = signersOrOptions;

                if (!transaction.nonceInfo) {
                  _context91.next = 14;
                  break;
                }

                transaction.sign.apply(transaction, _toConsumableArray(signers));
                _context91.next = 32;
                break;

              case 14:
                disableCache = this._disableBlockhashCaching;

              case 15:
                _context91.next = 17;
                return this._blockhashWithExpiryBlockHeight(disableCache);

              case 17:
                latestBlockhash = _context91.sent;
                transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;
                transaction.recentBlockhash = latestBlockhash.blockhash;
                transaction.sign.apply(transaction, _toConsumableArray(signers));

                if (transaction.signature) {
                  _context91.next = 23;
                  break;
                }

                throw new Error('!signature');

              case 23:
                _signature4 = transaction.signature.toString('base64');

                if (this._blockhashInfo.transactionSignatures.includes(_signature4)) {
                  _context91.next = 29;
                  break;
                }

                // The signature of this transaction has not been seen before with the
                // current recentBlockhash, all done. Let's break
                this._blockhashInfo.transactionSignatures.push(_signature4);

                return _context91.abrupt("break", 32);

              case 29:
                // This transaction would be treated as duplicate (its derived signature
                // matched to one of already recorded signatures).
                // So, we must fetch a new blockhash for a different signature by disabling
                // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).
                disableCache = true;

              case 30:
                _context91.next = 15;
                break;

              case 32:
                wireTransaction = transaction.serialize();
                _context91.next = 35;
                return this.sendRawTransaction(wireTransaction, options);

              case 35:
                return _context91.abrupt("return", _context91.sent);

              case 36:
              case "end":
                return _context91.stop();
            }
          }, _callee91, this);
        }));

        function sendTransaction(_x144, _x145, _x146) {
          return _sendTransaction.apply(this, arguments);
        }

        return sendTransaction;
      }()
      /**
       * Send a transaction that has already been signed and serialized into the
       * wire format
       */

    }, {
      key: "sendRawTransaction",
      value: function () {
        var _sendRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee92(rawTransaction, options) {
          var encodedTransaction, result;
          return _regeneratorRuntime().wrap(function _callee92$(_context92) {
            while (1) switch (_context92.prev = _context92.next) {
              case 0:
                encodedTransaction = toBuffer(rawTransaction).toString('base64');
                _context92.next = 3;
                return this.sendEncodedTransaction(encodedTransaction, options);

              case 3:
                result = _context92.sent;
                return _context92.abrupt("return", result);

              case 5:
              case "end":
                return _context92.stop();
            }
          }, _callee92, this);
        }));

        function sendRawTransaction(_x147, _x148) {
          return _sendRawTransaction.apply(this, arguments);
        }

        return sendRawTransaction;
      }()
      /**
       * Send a transaction that has already been signed, serialized into the
       * wire format, and encoded as a base64 string
       */

    }, {
      key: "sendEncodedTransaction",
      value: function () {
        var _sendEncodedTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee93(encodedTransaction, options) {
          var config, skipPreflight, preflightCommitment, args, unsafeRes, res, logs;
          return _regeneratorRuntime().wrap(function _callee93$(_context93) {
            while (1) switch (_context93.prev = _context93.next) {
              case 0:
                config = {
                  encoding: 'base64'
                };
                skipPreflight = options && options.skipPreflight;
                preflightCommitment = options && options.preflightCommitment || this.commitment;

                if (options && options.maxRetries != null) {
                  config.maxRetries = options.maxRetries;
                }

                if (options && options.minContextSlot != null) {
                  config.minContextSlot = options.minContextSlot;
                }

                if (skipPreflight) {
                  config.skipPreflight = skipPreflight;
                }

                if (preflightCommitment) {
                  config.preflightCommitment = preflightCommitment;
                }

                args = [encodedTransaction, config];
                _context93.next = 10;
                return this._rpcRequest('sendTransaction', args);

              case 10:
                unsafeRes = _context93.sent;
                res = _create(unsafeRes, SendTransactionRpcResult);

                if (!('error' in res)) {
                  _context93.next = 15;
                  break;
                }

                if ('data' in res.error) {
                  logs = res.error.data.logs;
                }

                throw new SendTransactionError('failed to send transaction: ' + res.error.message, logs);

              case 15:
                return _context93.abrupt("return", res.result);

              case 16:
              case "end":
                return _context93.stop();
            }
          }, _callee93, this);
        }));

        function sendEncodedTransaction(_x149, _x150) {
          return _sendEncodedTransaction.apply(this, arguments);
        }

        return sendEncodedTransaction;
      }()
      /**
       * @internal
       */

    }, {
      key: "_wsOnOpen",
      value: function _wsOnOpen() {
        var _this23 = this;

        this._rpcWebSocketConnected = true;
        this._rpcWebSocketHeartbeat = setInterval(function () {
          // Ping server every 5s to prevent idle timeouts
          _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee94() {
            return _regeneratorRuntime().wrap(function _callee94$(_context94) {
              while (1) switch (_context94.prev = _context94.next) {
                case 0:
                  _context94.prev = 0;
                  _context94.next = 3;
                  return _this23._rpcWebSocket.notify('ping');

                case 3:
                  _context94.next = 7;
                  break;

                case 5:
                  _context94.prev = 5;
                  _context94.t0 = _context94["catch"](0);

                case 7:
                case "end":
                  return _context94.stop();
              }
            }, _callee94, null, [[0, 5]]);
          }))();
        }, 5000);

        this._updateSubscriptions();
      }
      /**
       * @internal
       */

    }, {
      key: "_wsOnError",
      value: function _wsOnError(err) {
        this._rpcWebSocketConnected = false;
        console.error('ws error:', err.message);
      }
      /**
       * @internal
       */

    }, {
      key: "_wsOnClose",
      value: function _wsOnClose(code) {
        var _this24 = this;

        this._rpcWebSocketConnected = false;
        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;

        if (this._rpcWebSocketIdleTimeout) {
          clearTimeout(this._rpcWebSocketIdleTimeout);
          this._rpcWebSocketIdleTimeout = null;
        }

        if (this._rpcWebSocketHeartbeat) {
          clearInterval(this._rpcWebSocketHeartbeat);
          this._rpcWebSocketHeartbeat = null;
        }

        if (code === 1000) {
          // explicit close, check if any subscriptions have been made since close
          this._updateSubscriptions();

          return;
        } // implicit close, prepare subscriptions for auto-reconnect


        this._subscriptionCallbacksByServerSubscriptionId = {};
        Object.entries(this._subscriptionsByHash).forEach(function (_ref40) {
          var _ref41 = _slicedToArray(_ref40, 2),
              hash = _ref41[0],
              subscription = _ref41[1];

          _this24._setSubscription(hash, _objectSpread2(_objectSpread2({}, subscription), {}, {
            state: 'pending'
          }));
        });
      }
      /**
       * @internal
       */

    }, {
      key: "_setSubscription",
      value: function _setSubscription(hash, nextSubscription) {
        var _this$_subscriptionsB;

        var prevState = (_this$_subscriptionsB = this._subscriptionsByHash[hash]) === null || _this$_subscriptionsB === void 0 ? void 0 : _this$_subscriptionsB.state;
        this._subscriptionsByHash[hash] = nextSubscription;

        if (prevState !== nextSubscription.state) {
          var stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];

          if (stateChangeCallbacks) {
            stateChangeCallbacks.forEach(function (cb) {
              try {
                cb(nextSubscription.state); // eslint-disable-next-line no-empty
              } catch (_unused3) {}
            });
          }
        }
      }
      /**
       * @internal
       */

    }, {
      key: "_onSubscriptionStateChange",
      value: function _onSubscriptionStateChange(clientSubscriptionId, callback) {
        var _this25 = this;

        var _this$_subscriptionSt;

        var hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];

        if (hash == null) {
          return function () {};
        }

        var stateChangeCallbacks = (_this$_subscriptionSt = this._subscriptionStateChangeCallbacksByHash)[hash] || (_this$_subscriptionSt[hash] = new Set());
        stateChangeCallbacks.add(callback);
        return function () {
          stateChangeCallbacks["delete"](callback);

          if (stateChangeCallbacks.size === 0) {
            delete _this25._subscriptionStateChangeCallbacksByHash[hash];
          }
        };
      }
      /**
       * @internal
       */

    }, {
      key: "_updateSubscriptions",
      value: function () {
        var _updateSubscriptions2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee98() {
          var _this26 = this;

          var activeWebSocketGeneration, isCurrentConnectionStillActive;
          return _regeneratorRuntime().wrap(function _callee98$(_context98) {
            while (1) switch (_context98.prev = _context98.next) {
              case 0:
                if (!(Object.keys(this._subscriptionsByHash).length === 0)) {
                  _context98.next = 3;
                  break;
                }

                if (this._rpcWebSocketConnected) {
                  this._rpcWebSocketConnected = false;
                  this._rpcWebSocketIdleTimeout = setTimeout(function () {
                    _this26._rpcWebSocketIdleTimeout = null;

                    try {
                      _this26._rpcWebSocket.close();
                    } catch (err) {
                      // swallow error if socket has already been closed.
                      if (err instanceof Error) {
                        console.log("Error when closing socket connection: ".concat(err.message));
                      }
                    }
                  }, 500);
                }

                return _context98.abrupt("return");

              case 3:
                if (this._rpcWebSocketIdleTimeout !== null) {
                  clearTimeout(this._rpcWebSocketIdleTimeout);
                  this._rpcWebSocketIdleTimeout = null;
                  this._rpcWebSocketConnected = true;
                }

                if (this._rpcWebSocketConnected) {
                  _context98.next = 7;
                  break;
                }

                this._rpcWebSocket.connect();

                return _context98.abrupt("return");

              case 7:
                activeWebSocketGeneration = this._rpcWebSocketGeneration;

                isCurrentConnectionStillActive = function isCurrentConnectionStillActive() {
                  return activeWebSocketGeneration === _this26._rpcWebSocketGeneration;
                };

                _context98.next = 11;
                return Promise.all( // Don't be tempted to change this to `Object.entries`. We call
                // `_updateSubscriptions` recursively when processing the state,
                // so it's important that we look up the *current* version of
                // each subscription, every time we process a hash.
                Object.keys(this._subscriptionsByHash).map( /*#__PURE__*/function () {
                  var _ref42 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee97(hash) {
                    var subscription;
                    return _regeneratorRuntime().wrap(function _callee97$(_context97) {
                      while (1) switch (_context97.prev = _context97.next) {
                        case 0:
                          subscription = _this26._subscriptionsByHash[hash];

                          if (!(subscription === undefined)) {
                            _context97.next = 3;
                            break;
                          }

                          return _context97.abrupt("return");

                        case 3:
                          _context97.t0 = subscription.state;
                          _context97.next = _context97.t0 === 'pending' ? 6 : _context97.t0 === 'unsubscribed' ? 6 : _context97.t0 === 'subscribed' ? 15 : 19;
                          break;

                        case 6:
                          if (!(subscription.callbacks.size === 0)) {
                            _context97.next = 12;
                            break;
                          }

                          /**
                           * You can end up here when:
                           *
                           * - a subscription has recently unsubscribed
                           *   without having new callbacks added to it
                           *   while the unsubscribe was in flight, or
                           * - when a pending subscription has its
                           *   listeners removed before a request was
                           *   sent to the server.
                           *
                           * Being that nobody is interested in this
                           * subscription any longer, delete it.
                           */
                          delete _this26._subscriptionsByHash[hash];

                          if (subscription.state === 'unsubscribed') {
                            delete _this26._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];
                          }

                          _context97.next = 11;
                          return _this26._updateSubscriptions();

                        case 11:
                          return _context97.abrupt("return");

                        case 12:
                          _context97.next = 14;
                          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee95() {
                            var args, method, serverSubscriptionId;
                            return _regeneratorRuntime().wrap(function _callee95$(_context95) {
                              while (1) switch (_context95.prev = _context95.next) {
                                case 0:
                                  args = subscription.args, method = subscription.method;
                                  _context95.prev = 1;

                                  _this26._setSubscription(hash, _objectSpread2(_objectSpread2({}, subscription), {}, {
                                    state: 'subscribing'
                                  }));

                                  _context95.next = 5;
                                  return _this26._rpcWebSocket.call(method, args);

                                case 5:
                                  serverSubscriptionId = _context95.sent;

                                  _this26._setSubscription(hash, _objectSpread2(_objectSpread2({}, subscription), {}, {
                                    serverSubscriptionId: serverSubscriptionId,
                                    state: 'subscribed'
                                  }));

                                  _this26._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;
                                  _context95.next = 10;
                                  return _this26._updateSubscriptions();

                                case 10:
                                  _context95.next = 20;
                                  break;

                                case 12:
                                  _context95.prev = 12;
                                  _context95.t0 = _context95["catch"](1);

                                  if (_context95.t0 instanceof Error) {
                                    console.error("".concat(method, " error for argument"), args, _context95.t0.message);
                                  }

                                  if (isCurrentConnectionStillActive()) {
                                    _context95.next = 17;
                                    break;
                                  }

                                  return _context95.abrupt("return");

                                case 17:
                                  // TODO: Maybe add an 'errored' state or a retry limit?
                                  _this26._setSubscription(hash, _objectSpread2(_objectSpread2({}, subscription), {}, {
                                    state: 'pending'
                                  }));

                                  _context95.next = 20;
                                  return _this26._updateSubscriptions();

                                case 20:
                                case "end":
                                  return _context95.stop();
                              }
                            }, _callee95, null, [[1, 12]]);
                          }))();

                        case 14:
                          return _context97.abrupt("break", 19);

                        case 15:
                          if (!(subscription.callbacks.size === 0)) {
                            _context97.next = 18;
                            break;
                          }

                          _context97.next = 18;
                          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee96() {
                            var serverSubscriptionId, unsubscribeMethod;
                            return _regeneratorRuntime().wrap(function _callee96$(_context96) {
                              while (1) switch (_context96.prev = _context96.next) {
                                case 0:
                                  serverSubscriptionId = subscription.serverSubscriptionId, unsubscribeMethod = subscription.unsubscribeMethod;

                                  if (!_this26._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {
                                    _context96.next = 5;
                                    break;
                                  }

                                  /**
                                   * Special case.
                                   * If we're dealing with a subscription that has been auto-
                                   * disposed by the RPC, then we can skip the RPC call to
                                   * tear down the subscription here.
                                   *
                                   * NOTE: There is a proposal to eliminate this special case, here:
                                   * https://github.com/solana-labs/solana/issues/18892
                                   */
                                  _this26._subscriptionsAutoDisposedByRpc["delete"](serverSubscriptionId);

                                  _context96.next = 21;
                                  break;

                                case 5:
                                  _this26._setSubscription(hash, _objectSpread2(_objectSpread2({}, subscription), {}, {
                                    state: 'unsubscribing'
                                  }));

                                  _this26._setSubscription(hash, _objectSpread2(_objectSpread2({}, subscription), {}, {
                                    state: 'unsubscribing'
                                  }));

                                  _context96.prev = 7;
                                  _context96.next = 10;
                                  return _this26._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);

                                case 10:
                                  _context96.next = 21;
                                  break;

                                case 12:
                                  _context96.prev = 12;
                                  _context96.t0 = _context96["catch"](7);

                                  if (_context96.t0 instanceof Error) {
                                    console.error("".concat(unsubscribeMethod, " error:"), _context96.t0.message);
                                  }

                                  if (isCurrentConnectionStillActive()) {
                                    _context96.next = 17;
                                    break;
                                  }

                                  return _context96.abrupt("return");

                                case 17:
                                  // TODO: Maybe add an 'errored' state or a retry limit?
                                  _this26._setSubscription(hash, _objectSpread2(_objectSpread2({}, subscription), {}, {
                                    state: 'subscribed'
                                  }));

                                  _context96.next = 20;
                                  return _this26._updateSubscriptions();

                                case 20:
                                  return _context96.abrupt("return");

                                case 21:
                                  _this26._setSubscription(hash, _objectSpread2(_objectSpread2({}, subscription), {}, {
                                    state: 'unsubscribed'
                                  }));

                                  _context96.next = 24;
                                  return _this26._updateSubscriptions();

                                case 24:
                                case "end":
                                  return _context96.stop();
                              }
                            }, _callee96, null, [[7, 12]]);
                          }))();

                        case 18:
                          return _context97.abrupt("break", 19);

                        case 19:
                        case "end":
                          return _context97.stop();
                      }
                    }, _callee97);
                  }));

                  return function (_x151) {
                    return _ref42.apply(this, arguments);
                  };
                }()));

              case 11:
              case "end":
                return _context98.stop();
            }
          }, _callee98, this);
        }));

        function _updateSubscriptions() {
          return _updateSubscriptions2.apply(this, arguments);
        }

        return _updateSubscriptions;
      }()
      /**
       * @internal
       */

    }, {
      key: "_handleServerNotification",
      value: function _handleServerNotification(serverSubscriptionId, callbackArgs) {
        var callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];

        if (callbacks === undefined) {
          return;
        }

        callbacks.forEach(function (cb) {
          try {
            cb.apply(void 0, _toConsumableArray(callbackArgs));
          } catch (e) {
            console.error(e);
          }
        });
      }
      /**
       * @internal
       */

    }, {
      key: "_wsOnAccountNotification",
      value: function _wsOnAccountNotification(notification) {
        var _create$1 = _create(notification, AccountNotificationResult),
            result = _create$1.result,
            subscription = _create$1.subscription;

        this._handleServerNotification(subscription, [result.value, result.context]);
      }
      /**
       * @internal
       */

    }, {
      key: "_makeSubscription",
      value: function _makeSubscription(subscriptionConfig,
      /**
       * When preparing `args` for a call to `_makeSubscription`, be sure
       * to carefully apply a default `commitment` property, if necessary.
       *
       * - If the user supplied a `commitment` use that.
       * - Otherwise, if the `Connection::commitment` is set, use that.
       * - Otherwise, set it to the RPC server default: `finalized`.
       *
       * This is extremely important to ensure that these two fundamentally
       * identical subscriptions produce the same identifying hash:
       *
       * - A subscription made without specifying a commitment.
       * - A subscription made where the commitment specified is the same
       *   as the default applied to the subscription above.
       *
       * Example; these two subscriptions must produce the same hash:
       *
       * - An `accountSubscribe` subscription for `'PUBKEY'`
       * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment
       *   `'finalized'`.
       *
       * See the 'making a subscription with defaulted params omitted' test
       * in `connection-subscriptions.ts` for more.
       */
      args) {
        var _this27 = this;

        var clientSubscriptionId = this._nextClientSubscriptionId++;
        var hash = fastStableStringify$1([subscriptionConfig.method, args]);
        var existingSubscription = this._subscriptionsByHash[hash];

        if (existingSubscription === undefined) {
          this._subscriptionsByHash[hash] = _objectSpread2(_objectSpread2({}, subscriptionConfig), {}, {
            args: args,
            callbacks: new Set([subscriptionConfig.callback]),
            state: 'pending'
          });
        } else {
          existingSubscription.callbacks.add(subscriptionConfig.callback);
        }

        this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;
        this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee99() {
          var subscription;
          return _regeneratorRuntime().wrap(function _callee99$(_context99) {
            while (1) switch (_context99.prev = _context99.next) {
              case 0:
                delete _this27._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];
                delete _this27._subscriptionHashByClientSubscriptionId[clientSubscriptionId];
                subscription = _this27._subscriptionsByHash[hash];
                assert(subscription !== undefined, "Could not find a `Subscription` when tearing down client subscription #".concat(clientSubscriptionId));
                subscription.callbacks["delete"](subscriptionConfig.callback);
                _context99.next = 7;
                return _this27._updateSubscriptions();

              case 7:
              case "end":
                return _context99.stop();
            }
          }, _callee99);
        }));

        this._updateSubscriptions();

        return clientSubscriptionId;
      }
      /**
       * Register a callback to be invoked whenever the specified account changes
       *
       * @param publicKey Public key of the account to monitor
       * @param callback Function to invoke whenever the account is changed
       * @param commitment Specify the commitment level account changes must reach before notification
       * @return subscription id
       */

    }, {
      key: "onAccountChange",
      value: function onAccountChange(publicKey, callback, commitment) {
        var args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized', // Apply connection/server default.
        'base64');

        return this._makeSubscription({
          callback: callback,
          method: 'accountSubscribe',
          unsubscribeMethod: 'accountUnsubscribe'
        }, args);
      }
      /**
       * Deregister an account notification callback
       *
       * @param id client subscription id to deregister
       */

    }, {
      key: "removeAccountChangeListener",
      value: function () {
        var _removeAccountChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee100(clientSubscriptionId) {
          return _regeneratorRuntime().wrap(function _callee100$(_context100) {
            while (1) switch (_context100.prev = _context100.next) {
              case 0:
                _context100.next = 2;
                return this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');

              case 2:
              case "end":
                return _context100.stop();
            }
          }, _callee100, this);
        }));

        function removeAccountChangeListener(_x152) {
          return _removeAccountChangeListener.apply(this, arguments);
        }

        return removeAccountChangeListener;
      }()
      /**
       * @internal
       */

    }, {
      key: "_wsOnProgramAccountNotification",
      value: function _wsOnProgramAccountNotification(notification) {
        var _create2 = _create(notification, ProgramAccountNotificationResult),
            result = _create2.result,
            subscription = _create2.subscription;

        this._handleServerNotification(subscription, [{
          accountId: result.value.pubkey,
          accountInfo: result.value.account
        }, result.context]);
      }
      /**
       * Register a callback to be invoked whenever accounts owned by the
       * specified program change
       *
       * @param programId Public key of the program to monitor
       * @param callback Function to invoke whenever the account is changed
       * @param commitment Specify the commitment level account changes must reach before notification
       * @param filters The program account filters to pass into the RPC method
       * @return subscription id
       */

    }, {
      key: "onProgramAccountChange",
      value: function onProgramAccountChange(programId, callback, commitment, filters) {
        var args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized', // Apply connection/server default.
        'base64'
        /* encoding */
        , filters ? {
          filters: filters
        } : undefined
        /* extra */
        );

        return this._makeSubscription({
          callback: callback,
          method: 'programSubscribe',
          unsubscribeMethod: 'programUnsubscribe'
        }, args);
      }
      /**
       * Deregister an account notification callback
       *
       * @param id client subscription id to deregister
       */

    }, {
      key: "removeProgramAccountChangeListener",
      value: function () {
        var _removeProgramAccountChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee101(clientSubscriptionId) {
          return _regeneratorRuntime().wrap(function _callee101$(_context101) {
            while (1) switch (_context101.prev = _context101.next) {
              case 0:
                _context101.next = 2;
                return this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');

              case 2:
              case "end":
                return _context101.stop();
            }
          }, _callee101, this);
        }));

        function removeProgramAccountChangeListener(_x153) {
          return _removeProgramAccountChangeListener.apply(this, arguments);
        }

        return removeProgramAccountChangeListener;
      }()
      /**
       * Registers a callback to be invoked whenever logs are emitted.
       */

    }, {
      key: "onLogs",
      value: function onLogs(filter, callback, commitment) {
        var args = this._buildArgs([_typeof$1(filter) === 'object' ? {
          mentions: [filter.toString()]
        } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.
        );

        return this._makeSubscription({
          callback: callback,
          method: 'logsSubscribe',
          unsubscribeMethod: 'logsUnsubscribe'
        }, args);
      }
      /**
       * Deregister a logs callback.
       *
       * @param id client subscription id to deregister.
       */

    }, {
      key: "removeOnLogsListener",
      value: function () {
        var _removeOnLogsListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee102(clientSubscriptionId) {
          return _regeneratorRuntime().wrap(function _callee102$(_context102) {
            while (1) switch (_context102.prev = _context102.next) {
              case 0:
                _context102.next = 2;
                return this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');

              case 2:
              case "end":
                return _context102.stop();
            }
          }, _callee102, this);
        }));

        function removeOnLogsListener(_x154) {
          return _removeOnLogsListener.apply(this, arguments);
        }

        return removeOnLogsListener;
      }()
      /**
       * @internal
       */

    }, {
      key: "_wsOnLogsNotification",
      value: function _wsOnLogsNotification(notification) {
        var _create3 = _create(notification, LogsNotificationResult),
            result = _create3.result,
            subscription = _create3.subscription;

        this._handleServerNotification(subscription, [result.value, result.context]);
      }
      /**
       * @internal
       */

    }, {
      key: "_wsOnSlotNotification",
      value: function _wsOnSlotNotification(notification) {
        var _create4 = _create(notification, SlotNotificationResult),
            result = _create4.result,
            subscription = _create4.subscription;

        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon slot changes
       *
       * @param callback Function to invoke whenever the slot changes
       * @return subscription id
       */

    }, {
      key: "onSlotChange",
      value: function onSlotChange(callback) {
        return this._makeSubscription({
          callback: callback,
          method: 'slotSubscribe',
          unsubscribeMethod: 'slotUnsubscribe'
        }, []
        /* args */
        );
      }
      /**
       * Deregister a slot notification callback
       *
       * @param id client subscription id to deregister
       */

    }, {
      key: "removeSlotChangeListener",
      value: function () {
        var _removeSlotChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee103(clientSubscriptionId) {
          return _regeneratorRuntime().wrap(function _callee103$(_context103) {
            while (1) switch (_context103.prev = _context103.next) {
              case 0:
                _context103.next = 2;
                return this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');

              case 2:
              case "end":
                return _context103.stop();
            }
          }, _callee103, this);
        }));

        function removeSlotChangeListener(_x155) {
          return _removeSlotChangeListener.apply(this, arguments);
        }

        return removeSlotChangeListener;
      }()
      /**
       * @internal
       */

    }, {
      key: "_wsOnSlotUpdatesNotification",
      value: function _wsOnSlotUpdatesNotification(notification) {
        var _create5 = _create(notification, SlotUpdateNotificationResult),
            result = _create5.result,
            subscription = _create5.subscription;

        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s
       * may be useful to track live progress of a cluster.
       *
       * @param callback Function to invoke whenever the slot updates
       * @return subscription id
       */

    }, {
      key: "onSlotUpdate",
      value: function onSlotUpdate(callback) {
        return this._makeSubscription({
          callback: callback,
          method: 'slotsUpdatesSubscribe',
          unsubscribeMethod: 'slotsUpdatesUnsubscribe'
        }, []
        /* args */
        );
      }
      /**
       * Deregister a slot update notification callback
       *
       * @param id client subscription id to deregister
       */

    }, {
      key: "removeSlotUpdateListener",
      value: function () {
        var _removeSlotUpdateListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee104(clientSubscriptionId) {
          return _regeneratorRuntime().wrap(function _callee104$(_context104) {
            while (1) switch (_context104.prev = _context104.next) {
              case 0:
                _context104.next = 2;
                return this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');

              case 2:
              case "end":
                return _context104.stop();
            }
          }, _callee104, this);
        }));

        function removeSlotUpdateListener(_x156) {
          return _removeSlotUpdateListener.apply(this, arguments);
        }

        return removeSlotUpdateListener;
      }()
      /**
       * @internal
       */

    }, {
      key: "_unsubscribeClientSubscription",
      value: function () {
        var _unsubscribeClientSubscription2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee105(clientSubscriptionId, subscriptionName) {
          var dispose;
          return _regeneratorRuntime().wrap(function _callee105$(_context105) {
            while (1) switch (_context105.prev = _context105.next) {
              case 0:
                dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];

                if (!dispose) {
                  _context105.next = 6;
                  break;
                }

                _context105.next = 4;
                return dispose();

              case 4:
                _context105.next = 7;
                break;

              case 6:
                console.warn('Ignored unsubscribe request because an active subscription with id ' + "`".concat(clientSubscriptionId, "` for '").concat(subscriptionName, "' events ") + 'could not be found.');

              case 7:
              case "end":
                return _context105.stop();
            }
          }, _callee105, this);
        }));

        function _unsubscribeClientSubscription(_x157, _x158) {
          return _unsubscribeClientSubscription2.apply(this, arguments);
        }

        return _unsubscribeClientSubscription;
      }()
    }, {
      key: "_buildArgs",
      value: function _buildArgs(args, override, encoding, extra) {
        var commitment = override || this._commitment;

        if (commitment || encoding || extra) {
          var options = {};

          if (encoding) {
            options.encoding = encoding;
          }

          if (commitment) {
            options.commitment = commitment;
          }

          if (extra) {
            options = Object.assign(options, extra);
          }

          args.push(options);
        }

        return args;
      }
      /**
       * @internal
       */

    }, {
      key: "_buildArgsAtLeastConfirmed",
      value: function _buildArgsAtLeastConfirmed(args, override, encoding, extra) {
        var commitment = override || this._commitment;

        if (commitment && !['confirmed', 'finalized'].includes(commitment)) {
          throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');
        }

        return this._buildArgs(args, override, encoding, extra);
      }
      /**
       * @internal
       */

    }, {
      key: "_wsOnSignatureNotification",
      value: function _wsOnSignatureNotification(notification) {
        var _create6 = _create(notification, SignatureNotificationResult),
            result = _create6.result,
            subscription = _create6.subscription;

        if (result.value !== 'receivedSignature') {
          /**
           * Special case.
           * After a signature is processed, RPCs automatically dispose of the
           * subscription on the server side. We need to track which of these
           * subscriptions have been disposed in such a way, so that we know
           * whether the client is dealing with a not-yet-processed signature
           * (in which case we must tear down the server subscription) or an
           * already-processed signature (in which case the client can simply
           * clear out the subscription locally without telling the server).
           *
           * NOTE: There is a proposal to eliminate this special case, here:
           * https://github.com/solana-labs/solana/issues/18892
           */
          this._subscriptionsAutoDisposedByRpc.add(subscription);
        }

        this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{
          type: 'received'
        }, result.context] : [{
          type: 'status',
          result: result.value
        }, result.context]);
      }
      /**
       * Register a callback to be invoked upon signature updates
       *
       * @param signature Transaction signature string in base 58
       * @param callback Function to invoke on signature notifications
       * @param commitment Specify the commitment level signature must reach before notification
       * @return subscription id
       */

    }, {
      key: "onSignature",
      value: function onSignature(signature, _callback, commitment) {
        var _this28 = this;

        var args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.
        );

        var clientSubscriptionId = this._makeSubscription({
          callback: function callback(notification, context) {
            if (notification.type === 'status') {
              _callback(notification.result, context); // Signatures subscriptions are auto-removed by the RPC service
              // so no need to explicitly send an unsubscribe message.


              try {
                _this28.removeSignatureListener(clientSubscriptionId); // eslint-disable-next-line no-empty

              } catch (_err) {// Already removed.
              }
            }
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe'
        }, args);

        return clientSubscriptionId;
      }
      /**
       * Register a callback to be invoked when a transaction is
       * received and/or processed.
       *
       * @param signature Transaction signature string in base 58
       * @param callback Function to invoke on signature notifications
       * @param options Enable received notifications and set the commitment
       *   level that signature must reach before notification
       * @return subscription id
       */

    }, {
      key: "onSignatureWithOptions",
      value: function onSignatureWithOptions(signature, _callback2, options) {
        var _this29 = this;

        var _options$commitment = _objectSpread2(_objectSpread2({}, options), {}, {
          commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.

        }),
            commitment = _options$commitment.commitment,
            extra = _objectWithoutProperties(_options$commitment, _excluded4);

        var args = this._buildArgs([signature], commitment, undefined
        /* encoding */
        , extra);

        var clientSubscriptionId = this._makeSubscription({
          callback: function callback(notification, context) {
            _callback2(notification, context); // Signatures subscriptions are auto-removed by the RPC service
            // so no need to explicitly send an unsubscribe message.


            try {
              _this29.removeSignatureListener(clientSubscriptionId); // eslint-disable-next-line no-empty

            } catch (_err) {// Already removed.
            }
          },
          method: 'signatureSubscribe',
          unsubscribeMethod: 'signatureUnsubscribe'
        }, args);

        return clientSubscriptionId;
      }
      /**
       * Deregister a signature notification callback
       *
       * @param id client subscription id to deregister
       */

    }, {
      key: "removeSignatureListener",
      value: function () {
        var _removeSignatureListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee106(clientSubscriptionId) {
          return _regeneratorRuntime().wrap(function _callee106$(_context106) {
            while (1) switch (_context106.prev = _context106.next) {
              case 0:
                _context106.next = 2;
                return this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');

              case 2:
              case "end":
                return _context106.stop();
            }
          }, _callee106, this);
        }));

        function removeSignatureListener(_x159) {
          return _removeSignatureListener.apply(this, arguments);
        }

        return removeSignatureListener;
      }()
      /**
       * @internal
       */

    }, {
      key: "_wsOnRootNotification",
      value: function _wsOnRootNotification(notification) {
        var _create7 = _create(notification, RootNotificationResult),
            result = _create7.result,
            subscription = _create7.subscription;

        this._handleServerNotification(subscription, [result]);
      }
      /**
       * Register a callback to be invoked upon root changes
       *
       * @param callback Function to invoke whenever the root changes
       * @return subscription id
       */

    }, {
      key: "onRootChange",
      value: function onRootChange(callback) {
        return this._makeSubscription({
          callback: callback,
          method: 'rootSubscribe',
          unsubscribeMethod: 'rootUnsubscribe'
        }, []
        /* args */
        );
      }
      /**
       * Deregister a root notification callback
       *
       * @param id client subscription id to deregister
       */

    }, {
      key: "removeRootChangeListener",
      value: function () {
        var _removeRootChangeListener = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee107(clientSubscriptionId) {
          return _regeneratorRuntime().wrap(function _callee107$(_context107) {
            while (1) switch (_context107.prev = _context107.next) {
              case 0:
                _context107.next = 2;
                return this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');

              case 2:
              case "end":
                return _context107.stop();
            }
          }, _callee107, this);
        }));

        function removeRootChangeListener(_x160) {
          return _removeRootChangeListener.apply(this, arguments);
        }

        return removeRootChangeListener;
      }()
    }]);

    return Connection;
  }();
  /**
   * Keypair signer interface
   */

  /**
   * An account keypair used for signing transactions.
   */


  var Keypair = /*#__PURE__*/function () {
    /**
     * Create a new keypair instance.
     * Generate random keypair if no {@link Ed25519Keypair} is provided.
     *
     * @param keypair ed25519 keypair
     */
    function Keypair(keypair) {
      _classCallCheck(this, Keypair);

      this._keypair = void 0;
      this._keypair = keypair !== null && keypair !== void 0 ? keypair : generateKeypair();
    }
    /**
     * Generate a new random keypair
     */


    _createClass(Keypair, [{
      key: "publicKey",
      get:
      /**
       * The public key for this keypair
       */
      function get() {
        return new PublicKey(this._keypair.publicKey);
      }
      /**
       * The raw secret key for this keypair
       */

    }, {
      key: "secretKey",
      get: function get() {
        return new Uint8Array(this._keypair.secretKey);
      }
    }], [{
      key: "generate",
      value: function generate() {
        return new Keypair(generateKeypair());
      }
      /**
       * Create a keypair from a raw secret key byte array.
       *
       * This method should only be used to recreate a keypair from a previously
       * generated secret key. Generating keypairs from a random seed should be done
       * with the {@link Keypair.fromSeed} method.
       *
       * @throws error if the provided secret key is invalid and validation is not skipped.
       *
       * @param secretKey secret key byte array
       * @param options: skip secret key validation
       */

    }, {
      key: "fromSecretKey",
      value: function fromSecretKey(secretKey, options) {
        if (secretKey.byteLength !== 64) {
          throw new Error('bad secret key size');
        }

        var publicKey = secretKey.slice(32, 64);

        if (!options || !options.skipValidation) {
          var privateScalar = secretKey.slice(0, 32);
          var computedPublicKey = getPublicKey(privateScalar);

          for (var ii = 0; ii < 32; ii++) {
            if (publicKey[ii] !== computedPublicKey[ii]) {
              throw new Error('provided secretKey is invalid');
            }
          }
        }

        return new Keypair({
          publicKey: publicKey,
          secretKey: secretKey
        });
      }
      /**
       * Generate a keypair from a 32 byte seed.
       *
       * @param seed seed byte array
       */

    }, {
      key: "fromSeed",
      value: function fromSeed(seed) {
        var publicKey = getPublicKey(seed);
        var secretKey = new Uint8Array(64);
        secretKey.set(seed);
        secretKey.set(publicKey, 32);
        return new Keypair({
          publicKey: publicKey,
          secretKey: secretKey
        });
      }
    }]);

    return Keypair;
  }();
  /**
   * An enumeration of valid address lookup table InstructionType's
   * @internal
   */


  var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
    CreateLookupTable: {
      index: 0,
      layout: struct([u32('instruction'), u64('recentSlot'), u8('bumpSeed')])
    },
    FreezeLookupTable: {
      index: 1,
      layout: struct([u32('instruction')])
    },
    ExtendLookupTable: {
      index: 2,
      layout: struct([u32('instruction'), u64(), seq$1(publicKey(), offset(u32(), -8), 'addresses')])
    },
    DeactivateLookupTable: {
      index: 3,
      layout: struct([u32('instruction')])
    },
    CloseLookupTable: {
      index: 4,
      layout: struct([u32('instruction')])
    }
  });

  var AddressLookupTableInstruction = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function AddressLookupTableInstruction() {
      _classCallCheck(this, AddressLookupTableInstruction);
    }

    _createClass(AddressLookupTableInstruction, null, [{
      key: "decodeInstructionType",
      value: function decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        var instructionTypeLayout = u32('instruction');
        var index = instructionTypeLayout.decode(instruction.data);
        var type;

        for (var _i10 = 0, _Object$entries2 = Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS); _i10 < _Object$entries2.length; _i10++) {
          var _Object$entries2$_i2 = _slicedToArray(_Object$entries2[_i10], 2),
              layoutType = _Object$entries2$_i2[0],
              layout = _Object$entries2$_i2[1];

          if (layout.index == index) {
            type = layoutType;
            break;
          }
        }

        if (!type) {
          throw new Error('Invalid Instruction. Should be a LookupTable Instruction');
        }

        return type;
      }
    }, {
      key: "decodeCreateLookupTable",
      value: function decodeCreateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 4);

        var _decodeData$12 = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data),
            recentSlot = _decodeData$12.recentSlot;

        return {
          authority: instruction.keys[1].pubkey,
          payer: instruction.keys[2].pubkey,
          recentSlot: Number(recentSlot)
        };
      }
    }, {
      key: "decodeExtendLookupTable",
      value: function decodeExtendLookupTable(instruction) {
        this.checkProgramId(instruction.programId);

        if (instruction.keys.length < 2) {
          throw new Error("invalid instruction; found ".concat(instruction.keys.length, " keys, expected at least 2"));
        }

        var _decodeData$13 = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data),
            addresses = _decodeData$13.addresses;

        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey,
          payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,
          addresses: addresses.map(function (buffer) {
            return new PublicKey(buffer);
          })
        };
      }
    }, {
      key: "decodeCloseLookupTable",
      value: function decodeCloseLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 3);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey,
          recipient: instruction.keys[2].pubkey
        };
      }
    }, {
      key: "decodeFreezeLookupTable",
      value: function decodeFreezeLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey
        };
      }
    }, {
      key: "decodeDeactivateLookupTable",
      value: function decodeDeactivateLookupTable(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeysLength(instruction.keys, 2);
        return {
          lookupTable: instruction.keys[0].pubkey,
          authority: instruction.keys[1].pubkey
        };
      }
      /**
       * @internal
       */

    }, {
      key: "checkProgramId",
      value: function checkProgramId(programId) {
        if (!programId.equals(AddressLookupTableProgram.programId)) {
          throw new Error('invalid instruction; programId is not AddressLookupTable Program');
        }
      }
      /**
       * @internal
       */

    }, {
      key: "checkKeysLength",
      value: function checkKeysLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
        }
      }
    }]);

    return AddressLookupTableInstruction;
  }();

  var AddressLookupTableProgram = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function AddressLookupTableProgram() {
      _classCallCheck(this, AddressLookupTableProgram);
    }

    _createClass(AddressLookupTableProgram, null, [{
      key: "createLookupTable",
      value: function createLookupTable(params) {
        var _PublicKey$findProgra = PublicKey.findProgramAddressSync([params.authority.toBuffer(), toBufferLE_1(BigInt(params.recentSlot), 8)], this.programId),
            _PublicKey$findProgra2 = _slicedToArray(_PublicKey$findProgra, 2),
            lookupTableAddress = _PublicKey$findProgra2[0],
            bumpSeed = _PublicKey$findProgra2[1];

        var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;
        var data = encodeData(type, {
          recentSlot: BigInt(params.recentSlot),
          bumpSeed: bumpSeed
        });
        var keys = [{
          pubkey: lookupTableAddress,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.payer,
          isSigner: true,
          isWritable: true
        }, {
          pubkey: SystemProgram.programId,
          isSigner: false,
          isWritable: false
        }];
        return [new TransactionInstruction({
          programId: this.programId,
          keys: keys,
          data: data
        }), lookupTableAddress];
      }
    }, {
      key: "freezeLookupTable",
      value: function freezeLookupTable(params) {
        var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;
        var data = encodeData(type);
        var keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys: keys,
          data: data
        });
      }
    }, {
      key: "extendLookupTable",
      value: function extendLookupTable(params) {
        var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;
        var data = encodeData(type, {
          addresses: params.addresses.map(function (addr) {
            return addr.toBytes();
          })
        });
        var keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];

        if (params.payer) {
          keys.push({
            pubkey: params.payer,
            isSigner: true,
            isWritable: true
          }, {
            pubkey: SystemProgram.programId,
            isSigner: false,
            isWritable: false
          });
        }

        return new TransactionInstruction({
          programId: this.programId,
          keys: keys,
          data: data
        });
      }
    }, {
      key: "deactivateLookupTable",
      value: function deactivateLookupTable(params) {
        var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;
        var data = encodeData(type);
        var keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys: keys,
          data: data
        });
      }
    }, {
      key: "closeLookupTable",
      value: function closeLookupTable(params) {
        var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;
        var data = encodeData(type);
        var keys = [{
          pubkey: params.lookupTable,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: params.authority,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: params.recipient,
          isSigner: false,
          isWritable: true
        }];
        return new TransactionInstruction({
          programId: this.programId,
          keys: keys,
          data: data
        });
      }
    }]);

    return AddressLookupTableProgram;
  }();

  AddressLookupTableProgram.programId = new PublicKey('AddressLookupTab1e1111111111111111111111111');
  /**
   * Compute Budget Instruction class
   */

  var ComputeBudgetInstruction = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function ComputeBudgetInstruction() {
      _classCallCheck(this, ComputeBudgetInstruction);
    }
    /**
     * Decode a compute budget instruction and retrieve the instruction type.
     */


    _createClass(ComputeBudgetInstruction, null, [{
      key: "decodeInstructionType",
      value: function decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        var instructionTypeLayout = u8('instruction');
        var typeIndex = instructionTypeLayout.decode(instruction.data);
        var type;

        for (var _i11 = 0, _Object$entries3 = Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS); _i11 < _Object$entries3.length; _i11++) {
          var _Object$entries3$_i2 = _slicedToArray(_Object$entries3[_i11], 2),
              ixType = _Object$entries3$_i2[0],
              layout = _Object$entries3$_i2[1];

          if (layout.index == typeIndex) {
            type = ixType;
            break;
          }
        }

        if (!type) {
          throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');
        }

        return type;
      }
      /**
       * Decode request units compute budget instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeRequestUnits",
      value: function decodeRequestUnits(instruction) {
        this.checkProgramId(instruction.programId);

        var _decodeData$14 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data),
            units = _decodeData$14.units,
            additionalFee = _decodeData$14.additionalFee;

        return {
          units: units,
          additionalFee: additionalFee
        };
      }
      /**
       * Decode request heap frame compute budget instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeRequestHeapFrame",
      value: function decodeRequestHeapFrame(instruction) {
        this.checkProgramId(instruction.programId);

        var _decodeData$15 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data),
            bytes = _decodeData$15.bytes;

        return {
          bytes: bytes
        };
      }
      /**
       * Decode set compute unit limit compute budget instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeSetComputeUnitLimit",
      value: function decodeSetComputeUnitLimit(instruction) {
        this.checkProgramId(instruction.programId);

        var _decodeData$16 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data),
            units = _decodeData$16.units;

        return {
          units: units
        };
      }
      /**
       * Decode set compute unit price compute budget instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeSetComputeUnitPrice",
      value: function decodeSetComputeUnitPrice(instruction) {
        this.checkProgramId(instruction.programId);

        var _decodeData$17 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data),
            microLamports = _decodeData$17.microLamports;

        return {
          microLamports: microLamports
        };
      }
      /**
       * @internal
       */

    }, {
      key: "checkProgramId",
      value: function checkProgramId(programId) {
        if (!programId.equals(ComputeBudgetProgram.programId)) {
          throw new Error('invalid instruction; programId is not ComputeBudgetProgram');
        }
      }
    }]);

    return ComputeBudgetInstruction;
  }();
  /**
   * An enumeration of valid ComputeBudgetInstructionType's
   */

  /**
   * An enumeration of valid ComputeBudget InstructionType's
   * @internal
   */


  var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
    RequestUnits: {
      index: 0,
      layout: struct([u8('instruction'), u32('units'), u32('additionalFee')])
    },
    RequestHeapFrame: {
      index: 1,
      layout: struct([u8('instruction'), u32('bytes')])
    },
    SetComputeUnitLimit: {
      index: 2,
      layout: struct([u8('instruction'), u32('units')])
    },
    SetComputeUnitPrice: {
      index: 3,
      layout: struct([u8('instruction'), u64('microLamports')])
    }
  });
  /**
   * Factory class for transaction instructions to interact with the Compute Budget program
   */

  var ComputeBudgetProgram = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function ComputeBudgetProgram() {
      _classCallCheck(this, ComputeBudgetProgram);
    }
    /**
     * Public key that identifies the Compute Budget program
     */

    /**
     * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}
     */


    _createClass(ComputeBudgetProgram, null, [{
      key: "requestUnits",
      value: function requestUnits(params) {
        var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;
        var data = encodeData(type, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data: data
        });
      }
    }, {
      key: "requestHeapFrame",
      value: function requestHeapFrame(params) {
        var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;
        var data = encodeData(type, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data: data
        });
      }
    }, {
      key: "setComputeUnitLimit",
      value: function setComputeUnitLimit(params) {
        var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;
        var data = encodeData(type, params);
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data: data
        });
      }
    }, {
      key: "setComputeUnitPrice",
      value: function setComputeUnitPrice(params) {
        var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;
        var data = encodeData(type, {
          microLamports: BigInt(params.microLamports)
        });
        return new TransactionInstruction({
          keys: [],
          programId: this.programId,
          data: data
        });
      }
    }]);

    return ComputeBudgetProgram;
  }();

  ComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');
  var PRIVATE_KEY_BYTES$1 = 64;
  var PUBLIC_KEY_BYTES$1 = 32;
  var SIGNATURE_BYTES = 64;
  /**
   * Params for creating an ed25519 instruction using a public key
   */

  var ED25519_INSTRUCTION_LAYOUT = struct([u8('numSignatures'), u8('padding'), u16('signatureOffset'), u16('signatureInstructionIndex'), u16('publicKeyOffset'), u16('publicKeyInstructionIndex'), u16('messageDataOffset'), u16('messageDataSize'), u16('messageInstructionIndex')]);

  var Ed25519Program = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function Ed25519Program() {
      _classCallCheck(this, Ed25519Program);
    }
    /**
     * Public key that identifies the ed25519 program
     */

    /**
     * Create an ed25519 instruction with a public key and signature. The
     * public key must be a buffer that is 32 bytes long, and the signature
     * must be a buffer of 64 bytes.
     */


    _createClass(Ed25519Program, null, [{
      key: "createInstructionWithPublicKey",
      value: function createInstructionWithPublicKey(params) {
        var publicKey = params.publicKey,
            message = params.message,
            signature = params.signature,
            instructionIndex = params.instructionIndex;
        assert(publicKey.length === PUBLIC_KEY_BYTES$1, "Public Key must be ".concat(PUBLIC_KEY_BYTES$1, " bytes but received ").concat(publicKey.length, " bytes"));
        assert(signature.length === SIGNATURE_BYTES, "Signature must be ".concat(SIGNATURE_BYTES, " bytes but received ").concat(signature.length, " bytes"));
        var publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;
        var signatureOffset = publicKeyOffset + publicKey.length;
        var messageDataOffset = signatureOffset + signature.length;
        var numSignatures = 1;
        var instructionData = Buffer$1.alloc(messageDataOffset + message.length);
        var index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.
        : instructionIndex;
        ED25519_INSTRUCTION_LAYOUT.encode({
          numSignatures: numSignatures,
          padding: 0,
          signatureOffset: signatureOffset,
          signatureInstructionIndex: index,
          publicKeyOffset: publicKeyOffset,
          publicKeyInstructionIndex: index,
          messageDataOffset: messageDataOffset,
          messageDataSize: message.length,
          messageInstructionIndex: index
        }, instructionData);
        instructionData.fill(publicKey, publicKeyOffset);
        instructionData.fill(signature, signatureOffset);
        instructionData.fill(message, messageDataOffset);
        return new TransactionInstruction({
          keys: [],
          programId: Ed25519Program.programId,
          data: instructionData
        });
      }
      /**
       * Create an ed25519 instruction with a private key. The private key
       * must be a buffer that is 64 bytes long.
       */

    }, {
      key: "createInstructionWithPrivateKey",
      value: function createInstructionWithPrivateKey(params) {
        var privateKey = params.privateKey,
            message = params.message,
            instructionIndex = params.instructionIndex;
        assert(privateKey.length === PRIVATE_KEY_BYTES$1, "Private key must be ".concat(PRIVATE_KEY_BYTES$1, " bytes but received ").concat(privateKey.length, " bytes"));

        try {
          var keypair = Keypair.fromSecretKey(privateKey);

          var _publicKey2 = keypair.publicKey.toBytes();

          var _signature5 = _sign(message, keypair.secretKey);

          return this.createInstructionWithPublicKey({
            publicKey: _publicKey2,
            message: message,
            signature: _signature5,
            instructionIndex: instructionIndex
          });
        } catch (error) {
          throw new Error("Error creating instruction; ".concat(error));
        }
      }
    }]);

    return Ed25519Program;
  }();

  Ed25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111'); // Supply a synchronous hashing algorithm to make this
  // library interoperable with the synchronous APIs in web3.js.

  utils.hmacSha256Sync = function (key) {
    var h = hmac.create(sha256, key);

    for (var _len8 = arguments.length, msgs = new Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {
      msgs[_key8 - 1] = arguments[_key8];
    }

    msgs.forEach(function (msg) {
      return h.update(msg);
    });
    return h.digest();
  };

  var ecdsaSign = function ecdsaSign(msgHash, privKey) {
    return signSync(msgHash, privKey, {
      der: false,
      recovered: true
    });
  };

  utils.isValidPrivateKey;
  var publicKeyCreate = getPublicKey$1;
  var PRIVATE_KEY_BYTES = 32;
  var ETHEREUM_ADDRESS_BYTES = 20;
  var PUBLIC_KEY_BYTES = 64;
  var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;
  /**
   * Params for creating an secp256k1 instruction using a public key
   */

  var SECP256K1_INSTRUCTION_LAYOUT = struct([u8('numSignatures'), u16('signatureOffset'), u8('signatureInstructionIndex'), u16('ethAddressOffset'), u8('ethAddressInstructionIndex'), u16('messageDataOffset'), u16('messageDataSize'), u8('messageInstructionIndex'), blob$1(20, 'ethAddress'), blob$1(64, 'signature'), u8('recoveryId')]);

  var Secp256k1Program = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function Secp256k1Program() {
      _classCallCheck(this, Secp256k1Program);
    }
    /**
     * Public key that identifies the secp256k1 program
     */

    /**
     * Construct an Ethereum address from a secp256k1 public key buffer.
     * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer
     */


    _createClass(Secp256k1Program, null, [{
      key: "publicKeyToEthAddress",
      value: function publicKeyToEthAddress(publicKey) {
        assert(publicKey.length === PUBLIC_KEY_BYTES, "Public key must be ".concat(PUBLIC_KEY_BYTES, " bytes but received ").concat(publicKey.length, " bytes"));

        try {
          return Buffer$1.from(keccak_256(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);
        } catch (error) {
          throw new Error("Error constructing Ethereum address: ".concat(error));
        }
      }
      /**
       * Create an secp256k1 instruction with a public key. The public key
       * must be a buffer that is 64 bytes long.
       */

    }, {
      key: "createInstructionWithPublicKey",
      value: function createInstructionWithPublicKey(params) {
        var publicKey = params.publicKey,
            message = params.message,
            signature = params.signature,
            recoveryId = params.recoveryId,
            instructionIndex = params.instructionIndex;
        return Secp256k1Program.createInstructionWithEthAddress({
          ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),
          message: message,
          signature: signature,
          recoveryId: recoveryId,
          instructionIndex: instructionIndex
        });
      }
      /**
       * Create an secp256k1 instruction with an Ethereum address. The address
       * must be a hex string or a buffer that is 20 bytes long.
       */

    }, {
      key: "createInstructionWithEthAddress",
      value: function createInstructionWithEthAddress(params) {
        var rawAddress = params.ethAddress,
            message = params.message,
            signature = params.signature,
            recoveryId = params.recoveryId,
            _params$instructionIn = params.instructionIndex,
            instructionIndex = _params$instructionIn === void 0 ? 0 : _params$instructionIn;
        var ethAddress;

        if (typeof rawAddress === 'string') {
          if (rawAddress.startsWith('0x')) {
            ethAddress = Buffer$1.from(rawAddress.substr(2), 'hex');
          } else {
            ethAddress = Buffer$1.from(rawAddress, 'hex');
          }
        } else {
          ethAddress = rawAddress;
        }

        assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, "Address must be ".concat(ETHEREUM_ADDRESS_BYTES, " bytes but received ").concat(ethAddress.length, " bytes"));
        var dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;
        var ethAddressOffset = dataStart;
        var signatureOffset = dataStart + ethAddress.length;
        var messageDataOffset = signatureOffset + signature.length + 1;
        var numSignatures = 1;
        var instructionData = Buffer$1.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);
        SECP256K1_INSTRUCTION_LAYOUT.encode({
          numSignatures: numSignatures,
          signatureOffset: signatureOffset,
          signatureInstructionIndex: instructionIndex,
          ethAddressOffset: ethAddressOffset,
          ethAddressInstructionIndex: instructionIndex,
          messageDataOffset: messageDataOffset,
          messageDataSize: message.length,
          messageInstructionIndex: instructionIndex,
          signature: toBuffer(signature),
          ethAddress: toBuffer(ethAddress),
          recoveryId: recoveryId
        }, instructionData);
        instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);
        return new TransactionInstruction({
          keys: [],
          programId: Secp256k1Program.programId,
          data: instructionData
        });
      }
      /**
       * Create an secp256k1 instruction with a private key. The private key
       * must be a buffer that is 32 bytes long.
       */

    }, {
      key: "createInstructionWithPrivateKey",
      value: function createInstructionWithPrivateKey(params) {
        var pkey = params.privateKey,
            message = params.message,
            instructionIndex = params.instructionIndex;
        assert(pkey.length === PRIVATE_KEY_BYTES, "Private key must be ".concat(PRIVATE_KEY_BYTES, " bytes but received ").concat(pkey.length, " bytes"));

        try {
          var privateKey = toBuffer(pkey);

          var _publicKey3 = publicKeyCreate(privateKey, false
          /* isCompressed */
          ).slice(1); // throw away leading byte


          var messageHash = Buffer$1.from(keccak_256(toBuffer(message)));

          var _ecdsaSign3 = ecdsaSign(messageHash, privateKey),
              _ecdsaSign4 = _slicedToArray(_ecdsaSign3, 2),
              _signature6 = _ecdsaSign4[0],
              recoveryId = _ecdsaSign4[1];

          return this.createInstructionWithPublicKey({
            publicKey: _publicKey3,
            message: message,
            signature: _signature6,
            recoveryId: recoveryId,
            instructionIndex: instructionIndex
          });
        } catch (error) {
          throw new Error("Error creating instruction; ".concat(error));
        }
      }
    }]);

    return Secp256k1Program;
  }();

  Secp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');
  /**
   * Address of the stake config account which configures the rate
   * of stake warmup and cooldown as well as the slashing penalty.
   */

  var STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');
  /**
   * Stake account authority info
   */

  var Authorized = /*#__PURE__*/_createClass(
  /** stake authority */

  /** withdraw authority */

  /**
   * Create a new Authorized object
   * @param staker the stake authority
   * @param withdrawer the withdraw authority
   */
  function Authorized(staker, withdrawer) {
    _classCallCheck(this, Authorized);

    this.staker = void 0;
    this.withdrawer = void 0;
    this.staker = staker;
    this.withdrawer = withdrawer;
  });
  /**
   * Stake account lockup info
   */


  var Lockup = /*#__PURE__*/_createClass(
  /** Unix timestamp of lockup expiration */

  /** Epoch of lockup expiration */

  /** Lockup custodian authority */

  /**
   * Create a new Lockup object
   */
  function Lockup(unixTimestamp, epoch, custodian) {
    _classCallCheck(this, Lockup);

    this.unixTimestamp = void 0;
    this.epoch = void 0;
    this.custodian = void 0;
    this.unixTimestamp = unixTimestamp;
    this.epoch = epoch;
    this.custodian = custodian;
  }
  /**
   * Default, inactive Lockup value
   */
  );

  Lockup["default"] = new Lockup(0, 0, PublicKey["default"]);
  /**
   * Stake Instruction class
   */

  var StakeInstruction = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function StakeInstruction() {
      _classCallCheck(this, StakeInstruction);
    }
    /**
     * Decode a stake instruction and retrieve the instruction type.
     */


    _createClass(StakeInstruction, null, [{
      key: "decodeInstructionType",
      value: function decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        var instructionTypeLayout = u32('instruction');
        var typeIndex = instructionTypeLayout.decode(instruction.data);
        var type;

        for (var _i12 = 0, _Object$entries4 = Object.entries(STAKE_INSTRUCTION_LAYOUTS); _i12 < _Object$entries4.length; _i12++) {
          var _Object$entries4$_i2 = _slicedToArray(_Object$entries4[_i12], 2),
              ixType = _Object$entries4$_i2[0],
              layout = _Object$entries4$_i2[1];

          if (layout.index == typeIndex) {
            type = ixType;
            break;
          }
        }

        if (!type) {
          throw new Error('Instruction type incorrect; not a StakeInstruction');
        }

        return type;
      }
      /**
       * Decode a initialize stake instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeInitialize",
      value: function decodeInitialize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);

        var _decodeData$18 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data),
            authorized = _decodeData$18.authorized,
            lockup = _decodeData$18.lockup;

        return {
          stakePubkey: instruction.keys[0].pubkey,
          authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),
          lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))
        };
      }
      /**
       * Decode a delegate stake instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeDelegate",
      value: function decodeDelegate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 6);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          votePubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[5].pubkey
        };
      }
      /**
       * Decode an authorize stake instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeAuthorize",
      value: function decodeAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);

        var _decodeData$19 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),
            newAuthorized = _decodeData$19.newAuthorized,
            stakeAuthorizationType = _decodeData$19.stakeAuthorizationType;

        var o = {
          stakePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          stakeAuthorizationType: {
            index: stakeAuthorizationType
          }
        };

        if (instruction.keys.length > 3) {
          o.custodianPubkey = instruction.keys[3].pubkey;
        }

        return o;
      }
      /**
       * Decode an authorize-with-seed stake instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeAuthorizeWithSeed",
      value: function decodeAuthorizeWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 2);

        var _decodeData$20 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data),
            newAuthorized = _decodeData$20.newAuthorized,
            stakeAuthorizationType = _decodeData$20.stakeAuthorizationType,
            authoritySeed = _decodeData$20.authoritySeed,
            authorityOwner = _decodeData$20.authorityOwner;

        var o = {
          stakePubkey: instruction.keys[0].pubkey,
          authorityBase: instruction.keys[1].pubkey,
          authoritySeed: authoritySeed,
          authorityOwner: new PublicKey(authorityOwner),
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          stakeAuthorizationType: {
            index: stakeAuthorizationType
          }
        };

        if (instruction.keys.length > 3) {
          o.custodianPubkey = instruction.keys[3].pubkey;
        }

        return o;
      }
      /**
       * Decode a split stake instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeSplit",
      value: function decodeSplit(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);

        var _decodeData$21 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data),
            lamports = _decodeData$21.lamports;

        return {
          stakePubkey: instruction.keys[0].pubkey,
          splitStakePubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          lamports: lamports
        };
      }
      /**
       * Decode a merge stake instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeMerge",
      value: function decodeMerge(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          sourceStakePubKey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey
        };
      }
      /**
       * Decode a withdraw stake instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeWithdraw",
      value: function decodeWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 5);

        var _decodeData$22 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),
            lamports = _decodeData$22.lamports;

        var o = {
          stakePubkey: instruction.keys[0].pubkey,
          toPubkey: instruction.keys[1].pubkey,
          authorizedPubkey: instruction.keys[4].pubkey,
          lamports: lamports
        };

        if (instruction.keys.length > 5) {
          o.custodianPubkey = instruction.keys[5].pubkey;
        }

        return o;
      }
      /**
       * Decode a deactivate stake instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeDeactivate",
      value: function decodeDeactivate(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);
        return {
          stakePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey
        };
      }
      /**
       * @internal
       */

    }, {
      key: "checkProgramId",
      value: function checkProgramId(programId) {
        if (!programId.equals(StakeProgram.programId)) {
          throw new Error('invalid instruction; programId is not StakeProgram');
        }
      }
      /**
       * @internal
       */

    }, {
      key: "checkKeyLength",
      value: function checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
        }
      }
    }]);

    return StakeInstruction;
  }();
  /**
   * An enumeration of valid StakeInstructionType's
   */

  /**
   * An enumeration of valid stake InstructionType's
   * @internal
   */


  var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
    Initialize: {
      index: 0,
      layout: struct([u32('instruction'), authorized(), lockup()])
    },
    Authorize: {
      index: 1,
      layout: struct([u32('instruction'), publicKey('newAuthorized'), u32('stakeAuthorizationType')])
    },
    Delegate: {
      index: 2,
      layout: struct([u32('instruction')])
    },
    Split: {
      index: 3,
      layout: struct([u32('instruction'), ns64('lamports')])
    },
    Withdraw: {
      index: 4,
      layout: struct([u32('instruction'), ns64('lamports')])
    },
    Deactivate: {
      index: 5,
      layout: struct([u32('instruction')])
    },
    Merge: {
      index: 7,
      layout: struct([u32('instruction')])
    },
    AuthorizeWithSeed: {
      index: 8,
      layout: struct([u32('instruction'), publicKey('newAuthorized'), u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])
    }
  });
  /**
   * Stake authorization type
   */

  /**
   * An enumeration of valid StakeAuthorizationLayout's
   */

  var StakeAuthorizationLayout = Object.freeze({
    Staker: {
      index: 0
    },
    Withdrawer: {
      index: 1
    }
  });
  /**
   * Factory class for transactions to interact with the Stake program
   */

  var StakeProgram = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function StakeProgram() {
      _classCallCheck(this, StakeProgram);
    }
    /**
     * Public key that identifies the Stake program
     */

    /**
     * Generate an Initialize instruction to add to a Stake Create transaction
     */


    _createClass(StakeProgram, null, [{
      key: "initialize",
      value: function initialize(params) {
        var stakePubkey = params.stakePubkey,
            authorized = params.authorized,
            maybeLockup = params.lockup;
        var lockup = maybeLockup || Lockup["default"];
        var type = STAKE_INSTRUCTION_LAYOUTS.Initialize;
        var data = encodeData(type, {
          authorized: {
            staker: toBuffer(authorized.staker.toBuffer()),
            withdrawer: toBuffer(authorized.withdrawer.toBuffer())
          },
          lockup: {
            unixTimestamp: lockup.unixTimestamp,
            epoch: lockup.epoch,
            custodian: toBuffer(lockup.custodian.toBuffer())
          }
        });
        var instructionData = {
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }],
          programId: this.programId,
          data: data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a Transaction that creates a new Stake account at
       *   an address generated with `from`, a seed, and the Stake programId
       */

    }, {
      key: "createAccountWithSeed",
      value: function createAccountWithSeed(params) {
        var transaction = new Transaction$1();
        transaction.add(SystemProgram.createAccountWithSeed({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.stakePubkey,
          basePubkey: params.basePubkey,
          seed: params.seed,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        var stakePubkey = params.stakePubkey,
            authorized = params.authorized,
            lockup = params.lockup;
        return transaction.add(this.initialize({
          stakePubkey: stakePubkey,
          authorized: authorized,
          lockup: lockup
        }));
      }
      /**
       * Generate a Transaction that creates a new Stake account
       */

    }, {
      key: "createAccount",
      value: function createAccount(params) {
        var transaction = new Transaction$1();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.stakePubkey,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        var stakePubkey = params.stakePubkey,
            authorized = params.authorized,
            lockup = params.lockup;
        return transaction.add(this.initialize({
          stakePubkey: stakePubkey,
          authorized: authorized,
          lockup: lockup
        }));
      }
      /**
       * Generate a Transaction that delegates Stake tokens to a validator
       * Vote PublicKey. This transaction can also be used to redelegate Stake
       * to a new validator Vote PublicKey.
       */

    }, {
      key: "delegate",
      value: function delegate(params) {
        var stakePubkey = params.stakePubkey,
            authorizedPubkey = params.authorizedPubkey,
            votePubkey = params.votePubkey;
        var type = STAKE_INSTRUCTION_LAYOUTS.Delegate;
        var data = encodeData(type);
        return new Transaction$1().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: votePubkey,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: STAKE_CONFIG_ID,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a Transaction that authorizes a new PublicKey as Staker
       * or Withdrawer on the Stake account.
       */

    }, {
      key: "authorize",
      value: function authorize(params) {
        var stakePubkey = params.stakePubkey,
            authorizedPubkey = params.authorizedPubkey,
            newAuthorizedPubkey = params.newAuthorizedPubkey,
            stakeAuthorizationType = params.stakeAuthorizationType,
            custodianPubkey = params.custodianPubkey;
        var type = STAKE_INSTRUCTION_LAYOUTS.Authorize;
        var data = encodeData(type, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          stakeAuthorizationType: stakeAuthorizationType.index
        });
        var keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];

        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: false,
            isWritable: false
          });
        }

        return new Transaction$1().add({
          keys: keys,
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a Transaction that authorizes a new PublicKey as Staker
       * or Withdrawer on the Stake account.
       */

    }, {
      key: "authorizeWithSeed",
      value: function authorizeWithSeed(params) {
        var stakePubkey = params.stakePubkey,
            authorityBase = params.authorityBase,
            authoritySeed = params.authoritySeed,
            authorityOwner = params.authorityOwner,
            newAuthorizedPubkey = params.newAuthorizedPubkey,
            stakeAuthorizationType = params.stakeAuthorizationType,
            custodianPubkey = params.custodianPubkey;
        var type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
        var data = encodeData(type, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          stakeAuthorizationType: stakeAuthorizationType.index,
          authoritySeed: authoritySeed,
          authorityOwner: toBuffer(authorityOwner.toBuffer())
        });
        var keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorityBase,
          isSigner: true,
          isWritable: false
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }];

        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: false,
            isWritable: false
          });
        }

        return new Transaction$1().add({
          keys: keys,
          programId: this.programId,
          data: data
        });
      }
      /**
       * @internal
       */

    }, {
      key: "splitInstruction",
      value: function splitInstruction(params) {
        var stakePubkey = params.stakePubkey,
            authorizedPubkey = params.authorizedPubkey,
            splitStakePubkey = params.splitStakePubkey,
            lamports = params.lamports;
        var type = STAKE_INSTRUCTION_LAYOUTS.Split;
        var data = encodeData(type, {
          lamports: lamports
        });
        return new TransactionInstruction({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: splitStakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a Transaction that splits Stake tokens into another stake account
       */

    }, {
      key: "split",
      value: function split(params) {
        var transaction = new Transaction$1();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.authorizedPubkey,
          newAccountPubkey: params.splitStakePubkey,
          lamports: 0,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.splitInstruction(params));
      }
      /**
       * Generate a Transaction that splits Stake tokens into another account
       * derived from a base public key and seed
       */

    }, {
      key: "splitWithSeed",
      value: function splitWithSeed(params) {
        var stakePubkey = params.stakePubkey,
            authorizedPubkey = params.authorizedPubkey,
            splitStakePubkey = params.splitStakePubkey,
            basePubkey = params.basePubkey,
            seed = params.seed,
            lamports = params.lamports;
        var transaction = new Transaction$1();
        transaction.add(SystemProgram.allocate({
          accountPubkey: splitStakePubkey,
          basePubkey: basePubkey,
          seed: seed,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.splitInstruction({
          stakePubkey: stakePubkey,
          authorizedPubkey: authorizedPubkey,
          splitStakePubkey: splitStakePubkey,
          lamports: lamports
        }));
      }
      /**
       * Generate a Transaction that merges Stake accounts.
       */

    }, {
      key: "merge",
      value: function merge(params) {
        var stakePubkey = params.stakePubkey,
            sourceStakePubKey = params.sourceStakePubKey,
            authorizedPubkey = params.authorizedPubkey;
        var type = STAKE_INSTRUCTION_LAYOUTS.Merge;
        var data = encodeData(type);
        return new Transaction$1().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: sourceStakePubKey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a Transaction that withdraws deactivated Stake tokens.
       */

    }, {
      key: "withdraw",
      value: function withdraw(params) {
        var stakePubkey = params.stakePubkey,
            authorizedPubkey = params.authorizedPubkey,
            toPubkey = params.toPubkey,
            lamports = params.lamports,
            custodianPubkey = params.custodianPubkey;
        var type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;
        var data = encodeData(type, {
          lamports: lamports
        });
        var keys = [{
          pubkey: stakePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];

        if (custodianPubkey) {
          keys.push({
            pubkey: custodianPubkey,
            isSigner: false,
            isWritable: false
          });
        }

        return new Transaction$1().add({
          keys: keys,
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a Transaction that deactivates Stake tokens.
       */

    }, {
      key: "deactivate",
      value: function deactivate(params) {
        var stakePubkey = params.stakePubkey,
            authorizedPubkey = params.authorizedPubkey;
        var type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;
        var data = encodeData(type);
        return new Transaction$1().add({
          keys: [{
            pubkey: stakePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: authorizedPubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data: data
        });
      }
    }]);

    return StakeProgram;
  }();

  StakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');
  StakeProgram.space = 200;
  /**
   * Vote account info
   */

  var VoteInit = /*#__PURE__*/_createClass(
  /** [0, 100] */
  function VoteInit(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {
    _classCallCheck(this, VoteInit);

    this.nodePubkey = void 0;
    this.authorizedVoter = void 0;
    this.authorizedWithdrawer = void 0;
    this.commission = void 0;
    this.nodePubkey = nodePubkey;
    this.authorizedVoter = authorizedVoter;
    this.authorizedWithdrawer = authorizedWithdrawer;
    this.commission = commission;
  });
  /**
   * Create vote account transaction params
   */

  /**
   * Vote Instruction class
   */


  var VoteInstruction = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function VoteInstruction() {
      _classCallCheck(this, VoteInstruction);
    }
    /**
     * Decode a vote instruction and retrieve the instruction type.
     */


    _createClass(VoteInstruction, null, [{
      key: "decodeInstructionType",
      value: function decodeInstructionType(instruction) {
        this.checkProgramId(instruction.programId);
        var instructionTypeLayout = u32('instruction');
        var typeIndex = instructionTypeLayout.decode(instruction.data);
        var type;

        for (var _i13 = 0, _Object$entries5 = Object.entries(VOTE_INSTRUCTION_LAYOUTS); _i13 < _Object$entries5.length; _i13++) {
          var _Object$entries5$_i2 = _slicedToArray(_Object$entries5[_i13], 2),
              ixType = _Object$entries5$_i2[0],
              layout = _Object$entries5$_i2[1];

          if (layout.index == typeIndex) {
            type = ixType;
            break;
          }
        }

        if (!type) {
          throw new Error('Instruction type incorrect; not a VoteInstruction');
        }

        return type;
      }
      /**
       * Decode an initialize vote instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeInitializeAccount",
      value: function decodeInitializeAccount(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 4);

        var _decodeData$23 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data),
            voteInit = _decodeData$23.voteInit;

        return {
          votePubkey: instruction.keys[0].pubkey,
          nodePubkey: instruction.keys[3].pubkey,
          voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)
        };
      }
      /**
       * Decode an authorize instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeAuthorize",
      value: function decodeAuthorize(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);

        var _decodeData$24 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),
            newAuthorized = _decodeData$24.newAuthorized,
            voteAuthorizationType = _decodeData$24.voteAuthorizationType;

        return {
          votePubkey: instruction.keys[0].pubkey,
          authorizedPubkey: instruction.keys[2].pubkey,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          voteAuthorizationType: {
            index: voteAuthorizationType
          }
        };
      }
      /**
       * Decode an authorize instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeAuthorizeWithSeed",
      value: function decodeAuthorizeWithSeed(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);

        var _decodeData$25 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data),
            _decodeData$25$voteAu = _decodeData$25.voteAuthorizeWithSeedArgs,
            currentAuthorityDerivedKeyOwnerPubkey = _decodeData$25$voteAu.currentAuthorityDerivedKeyOwnerPubkey,
            currentAuthorityDerivedKeySeed = _decodeData$25$voteAu.currentAuthorityDerivedKeySeed,
            newAuthorized = _decodeData$25$voteAu.newAuthorized,
            voteAuthorizationType = _decodeData$25$voteAu.voteAuthorizationType;

        return {
          currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,
          currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),
          currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
          newAuthorizedPubkey: new PublicKey(newAuthorized),
          voteAuthorizationType: {
            index: voteAuthorizationType
          },
          votePubkey: instruction.keys[0].pubkey
        };
      }
      /**
       * Decode a withdraw instruction and retrieve the instruction params.
       */

    }, {
      key: "decodeWithdraw",
      value: function decodeWithdraw(instruction) {
        this.checkProgramId(instruction.programId);
        this.checkKeyLength(instruction.keys, 3);

        var _decodeData$26 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),
            lamports = _decodeData$26.lamports;

        return {
          votePubkey: instruction.keys[0].pubkey,
          authorizedWithdrawerPubkey: instruction.keys[2].pubkey,
          lamports: lamports,
          toPubkey: instruction.keys[1].pubkey
        };
      }
      /**
       * @internal
       */

    }, {
      key: "checkProgramId",
      value: function checkProgramId(programId) {
        if (!programId.equals(VoteProgram.programId)) {
          throw new Error('invalid instruction; programId is not VoteProgram');
        }
      }
      /**
       * @internal
       */

    }, {
      key: "checkKeyLength",
      value: function checkKeyLength(keys, expectedLength) {
        if (keys.length < expectedLength) {
          throw new Error("invalid instruction; found ".concat(keys.length, " keys, expected at least ").concat(expectedLength));
        }
      }
    }]);

    return VoteInstruction;
  }();
  /**
   * An enumeration of valid VoteInstructionType's
   */


  var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
    InitializeAccount: {
      index: 0,
      layout: struct([u32('instruction'), voteInit()])
    },
    Authorize: {
      index: 1,
      layout: struct([u32('instruction'), publicKey('newAuthorized'), u32('voteAuthorizationType')])
    },
    Withdraw: {
      index: 3,
      layout: struct([u32('instruction'), ns64('lamports')])
    },
    AuthorizeWithSeed: {
      index: 10,
      layout: struct([u32('instruction'), voteAuthorizeWithSeedArgs()])
    }
  });
  /**
   * VoteAuthorize type
   */

  /**
   * An enumeration of valid VoteAuthorization layouts.
   */

  var VoteAuthorizationLayout = Object.freeze({
    Voter: {
      index: 0
    },
    Withdrawer: {
      index: 1
    }
  });
  /**
   * Factory class for transactions to interact with the Vote program
   */

  var VoteProgram = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function VoteProgram() {
      _classCallCheck(this, VoteProgram);
    }
    /**
     * Public key that identifies the Vote program
     */

    /**
     * Generate an Initialize instruction.
     */


    _createClass(VoteProgram, null, [{
      key: "initializeAccount",
      value: function initializeAccount(params) {
        var votePubkey = params.votePubkey,
            nodePubkey = params.nodePubkey,
            voteInit = params.voteInit;
        var type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;
        var data = encodeData(type, {
          voteInit: {
            nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),
            authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),
            authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),
            commission: voteInit.commission
          }
        });
        var instructionData = {
          keys: [{
            pubkey: votePubkey,
            isSigner: false,
            isWritable: true
          }, {
            pubkey: SYSVAR_RENT_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: false,
            isWritable: false
          }, {
            pubkey: nodePubkey,
            isSigner: true,
            isWritable: false
          }],
          programId: this.programId,
          data: data
        };
        return new TransactionInstruction(instructionData);
      }
      /**
       * Generate a transaction that creates a new Vote account.
       */

    }, {
      key: "createAccount",
      value: function createAccount(params) {
        var transaction = new Transaction$1();
        transaction.add(SystemProgram.createAccount({
          fromPubkey: params.fromPubkey,
          newAccountPubkey: params.votePubkey,
          lamports: params.lamports,
          space: this.space,
          programId: this.programId
        }));
        return transaction.add(this.initializeAccount({
          votePubkey: params.votePubkey,
          nodePubkey: params.voteInit.nodePubkey,
          voteInit: params.voteInit
        }));
      }
      /**
       * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.
       */

    }, {
      key: "authorize",
      value: function authorize(params) {
        var votePubkey = params.votePubkey,
            authorizedPubkey = params.authorizedPubkey,
            newAuthorizedPubkey = params.newAuthorizedPubkey,
            voteAuthorizationType = params.voteAuthorizationType;
        var type = VOTE_INSTRUCTION_LAYOUTS.Authorize;
        var data = encodeData(type, {
          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
          voteAuthorizationType: voteAuthorizationType.index
        });
        var keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: authorizedPubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction$1().add({
          keys: keys,
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account
       * where the current Voter or Withdrawer authority is a derived key.
       */

    }, {
      key: "authorizeWithSeed",
      value: function authorizeWithSeed(params) {
        var currentAuthorityDerivedKeyBasePubkey = params.currentAuthorityDerivedKeyBasePubkey,
            currentAuthorityDerivedKeyOwnerPubkey = params.currentAuthorityDerivedKeyOwnerPubkey,
            currentAuthorityDerivedKeySeed = params.currentAuthorityDerivedKeySeed,
            newAuthorizedPubkey = params.newAuthorizedPubkey,
            voteAuthorizationType = params.voteAuthorizationType,
            votePubkey = params.votePubkey;
        var type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;
        var data = encodeData(type, {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),
            currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,
            newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),
            voteAuthorizationType: voteAuthorizationType.index
          }
        });
        var keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: SYSVAR_CLOCK_PUBKEY,
          isSigner: false,
          isWritable: false
        }, {
          pubkey: currentAuthorityDerivedKeyBasePubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction$1().add({
          keys: keys,
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a transaction to withdraw from a Vote account.
       */

    }, {
      key: "withdraw",
      value: function withdraw(params) {
        var votePubkey = params.votePubkey,
            authorizedWithdrawerPubkey = params.authorizedWithdrawerPubkey,
            lamports = params.lamports,
            toPubkey = params.toPubkey;
        var type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;
        var data = encodeData(type, {
          lamports: lamports
        });
        var keys = [{
          pubkey: votePubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: toPubkey,
          isSigner: false,
          isWritable: true
        }, {
          pubkey: authorizedWithdrawerPubkey,
          isSigner: true,
          isWritable: false
        }];
        return new Transaction$1().add({
          keys: keys,
          programId: this.programId,
          data: data
        });
      }
      /**
       * Generate a transaction to withdraw safely from a Vote account.
       *
       * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`
       * checks that the withdraw amount will not exceed the specified balance while leaving enough left
       * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the
       * `withdraw` method directly.
       */

    }, {
      key: "safeWithdraw",
      value: function safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {
        if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {
          throw new Error('Withdraw will leave vote account with insuffcient funds.');
        }

        return VoteProgram.withdraw(params);
      }
    }]);

    return VoteProgram;
  }();

  VoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');
  VoteProgram.space = 3731;
  var VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');
  /**
   * @internal
   */

  var InfoString = type({
    name: string(),
    website: optional(string()),
    details: optional(string()),
    keybaseUsername: optional(string())
  });
  /**
   * ValidatorInfo class
   */

  var ValidatorInfo = /*#__PURE__*/function () {
    /**
     * validator public key
     */

    /**
     * validator information
     */

    /**
     * Construct a valid ValidatorInfo
     *
     * @param key validator public key
     * @param info validator information
     */
    function ValidatorInfo(key, info) {
      _classCallCheck(this, ValidatorInfo);

      this.key = void 0;
      this.info = void 0;
      this.key = key;
      this.info = info;
    }
    /**
     * Deserialize ValidatorInfo from the config account data. Exactly two config
     * keys are required in the data.
     *
     * @param buffer config account data
     * @return null if info was not found
     */


    _createClass(ValidatorInfo, null, [{
      key: "fromConfigData",
      value: function fromConfigData(buffer) {
        var byteArray = _toConsumableArray(buffer);

        var configKeyCount = decodeLength(byteArray);
        if (configKeyCount !== 2) return null;
        var configKeys = [];

        for (var i = 0; i < 2; i++) {
          var _publicKey4 = new PublicKey(byteArray.slice(0, PUBLIC_KEY_LENGTH));

          byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);
          var isSigner = byteArray.slice(0, 1)[0] === 1;
          byteArray = byteArray.slice(1);
          configKeys.push({
            publicKey: _publicKey4,
            isSigner: isSigner
          });
        }

        if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {
          if (configKeys[1].isSigner) {
            var rawInfo = rustString().decode(Buffer$1.from(byteArray));
            var info = JSON.parse(rawInfo);
            _assert(info, InfoString);
            return new ValidatorInfo(configKeys[1].publicKey, info);
          }
        }

        return null;
      }
    }]);

    return ValidatorInfo;
  }();

  var VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');
  /**
   * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88
   *
   * @internal
   */

  var VoteAccountLayout = struct([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), u8('commission'), nu64(), // votes.length
  seq$1(struct([nu64('slot'), u32('confirmationCount')]), offset(u32(), -8), 'votes'), u8('rootSlotValid'), nu64('rootSlot'), nu64(), // authorizedVoters.length
  seq$1(struct([nu64('epoch'), publicKey('authorizedVoter')]), offset(u32(), -8), 'authorizedVoters'), struct([seq$1(struct([publicKey('authorizedPubkey'), nu64('epochOfLastAuthorizedSwitch'), nu64('targetEpoch')]), 32, 'buf'), nu64('idx'), u8('isEmpty')], 'priorVoters'), nu64(), // epochCredits.length
  seq$1(struct([nu64('epoch'), nu64('credits'), nu64('prevCredits')]), offset(u32(), -8), 'epochCredits'), struct([nu64('slot'), nu64('timestamp')], 'lastTimestamp')]);
  /**
   * VoteAccount class
   */

  var VoteAccount = /*#__PURE__*/function () {
    /**
     * @internal
     */
    function VoteAccount(args) {
      _classCallCheck(this, VoteAccount);

      this.nodePubkey = void 0;
      this.authorizedWithdrawer = void 0;
      this.commission = void 0;
      this.rootSlot = void 0;
      this.votes = void 0;
      this.authorizedVoters = void 0;
      this.priorVoters = void 0;
      this.epochCredits = void 0;
      this.lastTimestamp = void 0;
      this.nodePubkey = args.nodePubkey;
      this.authorizedWithdrawer = args.authorizedWithdrawer;
      this.commission = args.commission;
      this.rootSlot = args.rootSlot;
      this.votes = args.votes;
      this.authorizedVoters = args.authorizedVoters;
      this.priorVoters = args.priorVoters;
      this.epochCredits = args.epochCredits;
      this.lastTimestamp = args.lastTimestamp;
    }
    /**
     * Deserialize VoteAccount from the account data.
     *
     * @param buffer account data
     * @return VoteAccount
     */


    _createClass(VoteAccount, null, [{
      key: "fromAccountData",
      value: function fromAccountData(buffer) {
        var versionOffset = 4;
        var va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);
        var rootSlot = va.rootSlot;

        if (!va.rootSlotValid) {
          rootSlot = null;
        }

        return new VoteAccount({
          nodePubkey: new PublicKey(va.nodePubkey),
          authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),
          commission: va.commission,
          votes: va.votes,
          rootSlot: rootSlot,
          authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),
          priorVoters: getPriorVoters(va.priorVoters),
          epochCredits: va.epochCredits,
          lastTimestamp: va.lastTimestamp
        });
      }
    }]);

    return VoteAccount;
  }();

  function parseAuthorizedVoter(_ref46) {
    var authorizedVoter = _ref46.authorizedVoter,
        epoch = _ref46.epoch;
    return {
      epoch: epoch,
      authorizedVoter: new PublicKey(authorizedVoter)
    };
  }

  function parsePriorVoters(_ref47) {
    var authorizedPubkey = _ref47.authorizedPubkey,
        epochOfLastAuthorizedSwitch = _ref47.epochOfLastAuthorizedSwitch,
        targetEpoch = _ref47.targetEpoch;
    return {
      authorizedPubkey: new PublicKey(authorizedPubkey),
      epochOfLastAuthorizedSwitch: epochOfLastAuthorizedSwitch,
      targetEpoch: targetEpoch
    };
  }

  function getPriorVoters(_ref48) {
    var buf = _ref48.buf,
        idx = _ref48.idx,
        isEmpty = _ref48.isEmpty;

    if (isEmpty) {
      return [];
    }

    return [].concat(_toConsumableArray(buf.slice(idx + 1).map(parsePriorVoters)), _toConsumableArray(buf.slice(0, idx).map(parsePriorVoters)));
  }

  var endpoint = {
    http: {
      devnet: 'http://api.devnet.solana.com',
      testnet: 'http://api.testnet.solana.com',
      'mainnet-beta': 'http://api.mainnet-beta.solana.com/'
    },
    https: {
      devnet: 'https://api.devnet.solana.com',
      testnet: 'https://api.testnet.solana.com',
      'mainnet-beta': 'https://api.mainnet-beta.solana.com/'
    }
  };
  /**
   * Retrieves the RPC API URL for the specified cluster
   */

  function clusterApiUrl(cluster, tls) {
    var key = tls === false ? 'http' : 'https';

    if (!cluster) {
      return endpoint[key]['devnet'];
    }

    var url = endpoint[key][cluster];

    if (!url) {
      throw new Error("Unknown ".concat(key, " cluster: ").concat(cluster));
    }

    return url;
  }
  /**
   * Send and confirm a raw transaction
   *
   * If `commitment` option is not specified, defaults to 'max' commitment.
   *
   * @param {Connection} connection
   * @param {Buffer} rawTransaction
   * @param {TransactionConfirmationStrategy} confirmationStrategy
   * @param {ConfirmOptions} [options]
   * @returns {Promise<TransactionSignature>}
   */

  /**
   * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`
   * is no longer supported and will be removed in a future version.
   */
  // eslint-disable-next-line no-redeclare
  // eslint-disable-next-line no-redeclare


  function sendAndConfirmRawTransaction(_x161, _x162, _x163, _x164) {
    return _sendAndConfirmRawTransaction.apply(this, arguments);
  }
  /**
   * There are 1-billion lamports in one SOL
   */


  function _sendAndConfirmRawTransaction() {
    _sendAndConfirmRawTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee109(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {
      var confirmationStrategy, options, sendOptions, signature, commitment, confirmationPromise, status;
      return _regeneratorRuntime().wrap(function _callee109$(_context109) {
        while (1) switch (_context109.prev = _context109.next) {
          case 0:
            if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {
              confirmationStrategy = confirmationStrategyOrConfirmOptions;
              options = maybeConfirmOptions;
            } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'nonceValue')) {
              confirmationStrategy = confirmationStrategyOrConfirmOptions;
              options = maybeConfirmOptions;
            } else {
              options = confirmationStrategyOrConfirmOptions;
            }

            sendOptions = options && {
              skipPreflight: options.skipPreflight,
              preflightCommitment: options.preflightCommitment || options.commitment,
              minContextSlot: options.minContextSlot
            };
            _context109.next = 4;
            return connection.sendRawTransaction(rawTransaction, sendOptions);

          case 4:
            signature = _context109.sent;
            commitment = options && options.commitment;
            confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);
            _context109.next = 9;
            return confirmationPromise;

          case 9:
            status = _context109.sent.value;

            if (!status.err) {
              _context109.next = 12;
              break;
            }

            throw new Error("Raw transaction ".concat(signature, " failed (").concat(JSON.stringify(status), ")"));

          case 12:
            return _context109.abrupt("return", signature);

          case 13:
          case "end":
            return _context109.stop();
        }
      }, _callee109);
    }));
    return _sendAndConfirmRawTransaction.apply(this, arguments);
  }

  var LAMPORTS_PER_SOL = 1000000000;

  var index_browser_esm = /*#__PURE__*/Object.freeze({
  	__proto__: null,
  	Account: Account,
  	AddressLookupTableAccount: AddressLookupTableAccount,
  	AddressLookupTableInstruction: AddressLookupTableInstruction,
  	AddressLookupTableProgram: AddressLookupTableProgram,
  	Authorized: Authorized,
  	BLOCKHASH_CACHE_TIMEOUT_MS: BLOCKHASH_CACHE_TIMEOUT_MS,
  	BPF_LOADER_DEPRECATED_PROGRAM_ID: BPF_LOADER_DEPRECATED_PROGRAM_ID,
  	BPF_LOADER_PROGRAM_ID: BPF_LOADER_PROGRAM_ID,
  	BpfLoader: BpfLoader,
  	COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,
  	ComputeBudgetInstruction: ComputeBudgetInstruction,
  	ComputeBudgetProgram: ComputeBudgetProgram,
  	Connection: Connection,
  	Ed25519Program: Ed25519Program,
  	Enum: Enum,
  	EpochSchedule: EpochSchedule,
  	FeeCalculatorLayout: FeeCalculatorLayout,
  	Keypair: Keypair,
  	LAMPORTS_PER_SOL: LAMPORTS_PER_SOL,
  	LOOKUP_TABLE_INSTRUCTION_LAYOUTS: LOOKUP_TABLE_INSTRUCTION_LAYOUTS,
  	Loader: Loader,
  	Lockup: Lockup,
  	MAX_SEED_LENGTH: MAX_SEED_LENGTH,
  	Message: Message,
  	MessageAccountKeys: MessageAccountKeys,
  	MessageV0: MessageV0,
  	NONCE_ACCOUNT_LENGTH: NONCE_ACCOUNT_LENGTH,
  	NonceAccount: NonceAccount,
  	PACKET_DATA_SIZE: PACKET_DATA_SIZE,
  	PUBLIC_KEY_LENGTH: PUBLIC_KEY_LENGTH,
  	PublicKey: PublicKey,
  	SIGNATURE_LENGTH_IN_BYTES: SIGNATURE_LENGTH_IN_BYTES,
  	SOLANA_SCHEMA: SOLANA_SCHEMA,
  	STAKE_CONFIG_ID: STAKE_CONFIG_ID,
  	STAKE_INSTRUCTION_LAYOUTS: STAKE_INSTRUCTION_LAYOUTS,
  	SYSTEM_INSTRUCTION_LAYOUTS: SYSTEM_INSTRUCTION_LAYOUTS,
  	SYSVAR_CLOCK_PUBKEY: SYSVAR_CLOCK_PUBKEY,
  	SYSVAR_EPOCH_SCHEDULE_PUBKEY: SYSVAR_EPOCH_SCHEDULE_PUBKEY,
  	SYSVAR_INSTRUCTIONS_PUBKEY: SYSVAR_INSTRUCTIONS_PUBKEY,
  	SYSVAR_RECENT_BLOCKHASHES_PUBKEY: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
  	SYSVAR_RENT_PUBKEY: SYSVAR_RENT_PUBKEY,
  	SYSVAR_REWARDS_PUBKEY: SYSVAR_REWARDS_PUBKEY,
  	SYSVAR_SLOT_HASHES_PUBKEY: SYSVAR_SLOT_HASHES_PUBKEY,
  	SYSVAR_SLOT_HISTORY_PUBKEY: SYSVAR_SLOT_HISTORY_PUBKEY,
  	SYSVAR_STAKE_HISTORY_PUBKEY: SYSVAR_STAKE_HISTORY_PUBKEY,
  	Secp256k1Program: Secp256k1Program,
  	SendTransactionError: SendTransactionError,
  	SolanaJSONRPCError: SolanaJSONRPCError,
  	SolanaJSONRPCErrorCode: SolanaJSONRPCErrorCode,
  	StakeAuthorizationLayout: StakeAuthorizationLayout,
  	StakeInstruction: StakeInstruction,
  	StakeProgram: StakeProgram,
  	Struct: Struct,
  	SystemInstruction: SystemInstruction,
  	SystemProgram: SystemProgram,
  	Transaction: Transaction$1,
  	TransactionExpiredBlockheightExceededError: TransactionExpiredBlockheightExceededError,
  	TransactionExpiredNonceInvalidError: TransactionExpiredNonceInvalidError,
  	TransactionExpiredTimeoutError: TransactionExpiredTimeoutError,
  	TransactionInstruction: TransactionInstruction,
  	TransactionMessage: TransactionMessage,
  	get TransactionStatus () { return TransactionStatus; },
  	VALIDATOR_INFO_KEY: VALIDATOR_INFO_KEY,
  	VERSION_PREFIX_MASK: VERSION_PREFIX_MASK,
  	VOTE_PROGRAM_ID: VOTE_PROGRAM_ID,
  	ValidatorInfo: ValidatorInfo,
  	VersionedMessage: VersionedMessage,
  	VersionedTransaction: VersionedTransaction,
  	VoteAccount: VoteAccount,
  	VoteAuthorizationLayout: VoteAuthorizationLayout,
  	VoteInit: VoteInit,
  	VoteInstruction: VoteInstruction,
  	VoteProgram: VoteProgram,
  	clusterApiUrl: clusterApiUrl,
  	sendAndConfirmRawTransaction: sendAndConfirmRawTransaction,
  	sendAndConfirmTransaction: sendAndConfirmTransaction
  });

  var Layout$1 = {};

  /**
   * Base class for layout objects.
   *
   * **NOTE** This is an abstract base class; you can create instances
   * if it amuses you, but they won't support the {@link
   * Layout#encode|encode} or {@link Layout#decode|decode} functions.
   *
   * @param {Number} span - Initializer for {@link Layout#span|span}.  The
   * parameter must be an integer; a negative value signifies that the
   * span is {@link Layout#getSpan|value-specific}.
   *
   * @param {string} [property] - Initializer for {@link
   * Layout#property|property}.
   *
   * @abstract
   */


  var Layout = /*#__PURE__*/function () {
    function Layout(span, property) {
      _classCallCheck(this, Layout);

      if (!Number.isInteger(span)) {
        throw new TypeError('span must be an integer');
      }
      /** The span of the layout in bytes.
       *
       * Positive values are generally expected.
       *
       * Zero will only appear in {@link Constant}s and in {@link
       * Sequence}s where the {@link Sequence#count|count} is zero.
       *
       * A negative value indicates that the span is value-specific, and
       * must be obtained using {@link Layout#getSpan|getSpan}. */


      this.span = span;
      /** The property name used when this layout is represented in an
       * Object.
       *
       * Used only for layouts that {@link Layout#decode|decode} to Object
       * instances.  If left undefined the span of the unnamed layout will
       * be treated as padding: it will not be mutated by {@link
       * Layout#encode|encode} nor represented as a property in the
       * decoded Object. */

      this.property = property;
    }
    /** Function to create an Object into which decoded properties will
     * be written.
     *
     * Used only for layouts that {@link Layout#decode|decode} to Object
     * instances, which means:
     * * {@link Structure}
     * * {@link Union}
     * * {@link VariantLayout}
     * * {@link BitStructure}
     *
     * If left undefined the JavaScript representation of these layouts
     * will be Object instances.
     *
     * See {@link bindConstructorLayout}.
     */


    _createClass(Layout, [{
      key: "makeDestinationObject",
      value: function makeDestinationObject() {
        return {};
      }
      /**
       * Decode from a Buffer into an JavaScript value.
       *
       * @param {Buffer} b - the buffer from which encoded data is read.
       *
       * @param {Number} [offset] - the offset at which the encoded data
       * starts.  If absent a zero offset is inferred.
       *
       * @returns {(Number|Array|Object)} - the value of the decoded data.
       *
       * @abstract
       */

    }, {
      key: "decode",
      value: function decode(b, offset) {
        throw new Error('Layout is abstract');
      }
      /**
       * Encode a JavaScript value into a Buffer.
       *
       * @param {(Number|Array|Object)} src - the value to be encoded into
       * the buffer.  The type accepted depends on the (sub-)type of {@link
       * Layout}.
       *
       * @param {Buffer} b - the buffer into which encoded data will be
       * written.
       *
       * @param {Number} [offset] - the offset at which the encoded data
       * starts.  If absent a zero offset is inferred.
       *
       * @returns {Number} - the number of bytes encoded, including the
       * space skipped for internal padding, but excluding data such as
       * {@link Sequence#count|lengths} when stored {@link
       * ExternalLayout|externally}.  This is the adjustment to `offset`
       * producing the offset where data for the next layout would be
       * written.
       *
       * @abstract
       */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        throw new Error('Layout is abstract');
      }
      /**
       * Calculate the span of a specific instance of a layout.
       *
       * @param {Buffer} b - the buffer that contains an encoded instance.
       *
       * @param {Number} [offset] - the offset at which the encoded instance
       * starts.  If absent a zero offset is inferred.
       *
       * @return {Number} - the number of bytes covered by the layout
       * instance.  If this method is not overridden in a subclass the
       * definition-time constant {@link Layout#span|span} will be
       * returned.
       *
       * @throws {RangeError} - if the length of the value cannot be
       * determined.
       */

    }, {
      key: "getSpan",
      value: function getSpan(b, offset) {
        if (0 > this.span) {
          throw new RangeError('indeterminate span');
        }

        return this.span;
      }
      /**
       * Replicate the layout using a new property.
       *
       * This function must be used to get a structurally-equivalent layout
       * with a different name since all {@link Layout} instances are
       * immutable.
       *
       * **NOTE** This is a shallow copy.  All fields except {@link
       * Layout#property|property} are strictly equal to the origin layout.
       *
       * @param {String} property - the value for {@link
       * Layout#property|property} in the replica.
       *
       * @returns {Layout} - the copy with {@link Layout#property|property}
       * set to `property`.
       */

    }, {
      key: "replicate",
      value: function replicate(property) {
        var rv = Object.create(this.constructor.prototype);
        Object.assign(rv, this);
        rv.property = property;
        return rv;
      }
      /**
       * Create an object from layout properties and an array of values.
       *
       * **NOTE** This function returns `undefined` if invoked on a layout
       * that does not return its value as an Object.  Objects are
       * returned for things that are a {@link Structure}, which includes
       * {@link VariantLayout|variant layouts} if they are structures, and
       * excludes {@link Union}s.  If you want this feature for a union
       * you must use {@link Union.getVariant|getVariant} to select the
       * desired layout.
       *
       * @param {Array} values - an array of values that correspond to the
       * default order for properties.  As with {@link Layout#decode|decode}
       * layout elements that have no property name are skipped when
       * iterating over the array values.  Only the top-level properties are
       * assigned; arguments are not assigned to properties of contained
       * layouts.  Any unused values are ignored.
       *
       * @return {(Object|undefined)}
       */

    }, {
      key: "fromArray",
      value: function fromArray(values) {
        return undefined;
      }
    }]);

    return Layout;
  }();

  Layout$1.Layout = Layout;
  /* Provide text that carries a name (such as for a function that will
   * be throwing an error) annotated with the property of a given layout
   * (such as one for which the value was unacceptable).
   *
   * @ignore */

  function nameWithProperty(name, lo) {
    if (lo.property) {
      return name + '[' + lo.property + ']';
    }

    return name;
  }

  Layout$1.nameWithProperty = nameWithProperty;
  /**
   * Augment a class so that instances can be encoded/decoded using a
   * given layout.
   *
   * Calling this function couples `Class` with `layout` in several ways:
   *
   * * `Class.layout_` becomes a static member property equal to `layout`;
   * * `layout.boundConstructor_` becomes a static member property equal
   *    to `Class`;
   * * The {@link Layout#makeDestinationObject|makeDestinationObject()}
   *   property of `layout` is set to a function that returns a `new
   *   Class()`;
   * * `Class.decode(b, offset)` becomes a static member function that
   *   delegates to {@link Layout#decode|layout.decode}.  The
   *   synthesized function may be captured and extended.
   * * `Class.prototype.encode(b, offset)` provides an instance member
   *   function that delegates to {@link Layout#encode|layout.encode}
   *   with `src` set to `this`.  The synthesized function may be
   *   captured and extended, but when the extension is invoked `this`
   *   must be explicitly bound to the instance.
   *
   * @param {class} Class - a JavaScript class with a nullary
   * constructor.
   *
   * @param {Layout} layout - the {@link Layout} instance used to encode
   * instances of `Class`.
   */

  function bindConstructorLayout(Class, layout) {
    if ('function' !== typeof Class) {
      throw new TypeError('Class must be constructor');
    }

    if (Class.hasOwnProperty('layout_')) {
      throw new Error('Class is already bound to a layout');
    }

    if (!(layout && layout instanceof Layout)) {
      throw new TypeError('layout must be a Layout');
    }

    if (layout.hasOwnProperty('boundConstructor_')) {
      throw new Error('layout is already bound to a constructor');
    }

    Class.layout_ = layout;
    layout.boundConstructor_ = Class;

    layout.makeDestinationObject = function () {
      return new Class();
    };

    Object.defineProperty(Class.prototype, 'encode', {
      value: function value(b, offset) {
        return layout.encode(this, b, offset);
      },
      writable: true
    });
    Object.defineProperty(Class, 'decode', {
      value: function value(b, offset) {
        return layout.decode(b, offset);
      },
      writable: true
    });
  }

  Layout$1.bindConstructorLayout = bindConstructorLayout;
  /**
   * An object that behaves like a layout but does not consume space
   * within its containing layout.
   *
   * This is primarily used to obtain metadata about a member, such as a
   * {@link OffsetLayout} that can provide data about a {@link
   * Layout#getSpan|value-specific span}.
   *
   * **NOTE** This is an abstract base class; you can create instances
   * if it amuses you, but they won't support {@link
   * ExternalLayout#isCount|isCount} or other {@link Layout} functions.
   *
   * @param {Number} span - initializer for {@link Layout#span|span}.
   * The parameter can range from 1 through 6.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @abstract
   * @augments {Layout}
   */

  var ExternalLayout = /*#__PURE__*/function (_Layout) {
    _inherits(ExternalLayout, _Layout);

    var _super = _createSuper(ExternalLayout);

    function ExternalLayout() {
      _classCallCheck(this, ExternalLayout);

      return _super.apply(this, arguments);
    }

    _createClass(ExternalLayout, [{
      key: "isCount",
      value:
      /**
       * Return `true` iff the external layout decodes to an unsigned
       * integer layout.
       *
       * In that case it can be used as the source of {@link
       * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
       * or as {@link UnionLayoutDiscriminator#layout|external union
       * discriminators}.
       *
       * @abstract
       */
      function isCount() {
        throw new Error('ExternalLayout is abstract');
      }
    }]);

    return ExternalLayout;
  }(Layout);
  /**
   * An {@link ExternalLayout} that determines its {@link
   * Layout#decode|value} based on offset into and length of the buffer
   * on which it is invoked.
   *
   * *Factory*: {@link module:Layout.greedy|greedy}
   *
   * @param {Number} [elementSpan] - initializer for {@link
   * GreedyCount#elementSpan|elementSpan}.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {ExternalLayout}
   */


  var GreedyCount = /*#__PURE__*/function (_ExternalLayout) {
    _inherits(GreedyCount, _ExternalLayout);

    var _super2 = _createSuper(GreedyCount);

    function GreedyCount(elementSpan, property) {
      var _this;

      _classCallCheck(this, GreedyCount);

      if (undefined === elementSpan) {
        elementSpan = 1;
      }

      if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {
        throw new TypeError('elementSpan must be a (positive) integer');
      }

      _this = _super2.call(this, -1, property);
      /** The layout for individual elements of the sequence.  The value
       * must be a positive integer.  If not provided, the value will be
       * 1. */

      _this.elementSpan = elementSpan;
      return _this;
    }
    /** @override */


    _createClass(GreedyCount, [{
      key: "isCount",
      value: function isCount() {
        return true;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var rem = b.length - offset;
        return Math.floor(rem / this.elementSpan);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        return 0;
      }
    }]);

    return GreedyCount;
  }(ExternalLayout);
  /**
   * An {@link ExternalLayout} that supports accessing a {@link Layout}
   * at a fixed offset from the start of another Layout.  The offset may
   * be before, within, or after the base layout.
   *
   * *Factory*: {@link module:Layout.offset|offset}
   *
   * @param {Layout} layout - initializer for {@link
   * OffsetLayout#layout|layout}, modulo `property`.
   *
   * @param {Number} [offset] - Initializes {@link
   * OffsetLayout#offset|offset}.  Defaults to zero.
   *
   * @param {string} [property] - Optional new property name for a
   * {@link Layout#replicate| replica} of `layout` to be used as {@link
   * OffsetLayout#layout|layout}.  If not provided the `layout` is used
   * unchanged.
   *
   * @augments {Layout}
   */


  var OffsetLayout = /*#__PURE__*/function (_ExternalLayout2) {
    _inherits(OffsetLayout, _ExternalLayout2);

    var _super3 = _createSuper(OffsetLayout);

    function OffsetLayout(layout, offset, property) {
      var _this2;

      _classCallCheck(this, OffsetLayout);

      if (!(layout instanceof Layout)) {
        throw new TypeError('layout must be a Layout');
      }

      if (undefined === offset) {
        offset = 0;
      } else if (!Number.isInteger(offset)) {
        throw new TypeError('offset must be integer or undefined');
      }

      _this2 = _super3.call(this, layout.span, property || layout.property);
      /** The subordinated layout. */

      _this2.layout = layout;
      /** The location of {@link OffsetLayout#layout} relative to the
       * start of another layout.
       *
       * The value may be positive or negative, but an error will thrown
       * if at the point of use it goes outside the span of the Buffer
       * being accessed.  */

      _this2.offset = offset;
      return _this2;
    }
    /** @override */


    _createClass(OffsetLayout, [{
      key: "isCount",
      value: function isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        return this.layout.decode(b, offset + this.offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        return this.layout.encode(src, b, offset + this.offset);
      }
    }]);

    return OffsetLayout;
  }(ExternalLayout);
  /**
   * Represent an unsigned integer in little-endian format.
   *
   * *Factory*: {@link module:Layout.u8|u8}, {@link
   *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link
   *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link
   *  module:Layout.u48|u48}
   *
   * @param {Number} span - initializer for {@link Layout#span|span}.
   * The parameter can range from 1 through 6.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var UInt = /*#__PURE__*/function (_Layout2) {
    _inherits(UInt, _Layout2);

    var _super4 = _createSuper(UInt);

    function UInt(span, property) {
      var _this3;

      _classCallCheck(this, UInt);

      _this3 = _super4.call(this, span, property);

      if (6 < _this3.span) {
        throw new RangeError('span must not exceed 6 bytes');
      }

      return _this3;
    }
    /** @override */


    _createClass(UInt, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        return b.readUIntLE(offset, this.span);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        b.writeUIntLE(src, offset, this.span);
        return this.span;
      }
    }]);

    return UInt;
  }(Layout);
  /**
   * Represent an unsigned integer in big-endian format.
   *
   * *Factory*: {@link module:Layout.u8be|u8be}, {@link
   * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},
   * {@link module:Layout.u32be|u32be}, {@link
   * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}
   *
   * @param {Number} span - initializer for {@link Layout#span|span}.
   * The parameter can range from 1 through 6.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var UIntBE = /*#__PURE__*/function (_Layout3) {
    _inherits(UIntBE, _Layout3);

    var _super5 = _createSuper(UIntBE);

    function UIntBE(span, property) {
      var _this4;

      _classCallCheck(this, UIntBE);

      _this4 = _super5.call(this, span, property);

      if (6 < _this4.span) {
        throw new RangeError('span must not exceed 6 bytes');
      }

      return _this4;
    }
    /** @override */


    _createClass(UIntBE, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        return b.readUIntBE(offset, this.span);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        b.writeUIntBE(src, offset, this.span);
        return this.span;
      }
    }]);

    return UIntBE;
  }(Layout);
  /**
   * Represent a signed integer in little-endian format.
   *
   * *Factory*: {@link module:Layout.s8|s8}, {@link
   *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link
   *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link
   *  module:Layout.s48|s48}
   *
   * @param {Number} span - initializer for {@link Layout#span|span}.
   * The parameter can range from 1 through 6.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var Int = /*#__PURE__*/function (_Layout4) {
    _inherits(Int, _Layout4);

    var _super6 = _createSuper(Int);

    function Int(span, property) {
      var _this5;

      _classCallCheck(this, Int);

      _this5 = _super6.call(this, span, property);

      if (6 < _this5.span) {
        throw new RangeError('span must not exceed 6 bytes');
      }

      return _this5;
    }
    /** @override */


    _createClass(Int, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        return b.readIntLE(offset, this.span);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        b.writeIntLE(src, offset, this.span);
        return this.span;
      }
    }]);

    return Int;
  }(Layout);
  /**
   * Represent a signed integer in big-endian format.
   *
   * *Factory*: {@link module:Layout.s8be|s8be}, {@link
   * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},
   * {@link module:Layout.s32be|s32be}, {@link
   * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}
   *
   * @param {Number} span - initializer for {@link Layout#span|span}.
   * The parameter can range from 1 through 6.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var IntBE = /*#__PURE__*/function (_Layout5) {
    _inherits(IntBE, _Layout5);

    var _super7 = _createSuper(IntBE);

    function IntBE(span, property) {
      var _this6;

      _classCallCheck(this, IntBE);

      _this6 = _super7.call(this, span, property);

      if (6 < _this6.span) {
        throw new RangeError('span must not exceed 6 bytes');
      }

      return _this6;
    }
    /** @override */


    _createClass(IntBE, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        return b.readIntBE(offset, this.span);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        b.writeIntBE(src, offset, this.span);
        return this.span;
      }
    }]);

    return IntBE;
  }(Layout);

  var V2E32 = Math.pow(2, 32);
  /* True modulus high and low 32-bit words, where low word is always
   * non-negative. */

  function divmodInt64(src) {
    var hi32 = Math.floor(src / V2E32);
    var lo32 = src - hi32 * V2E32;
    return {
      hi32: hi32,
      lo32: lo32
    };
  }
  /* Reconstruct Number from quotient and non-negative remainder */


  function roundedInt64(hi32, lo32) {
    return hi32 * V2E32 + lo32;
  }
  /**
   * Represent an unsigned 64-bit integer in little-endian format when
   * encoded and as a near integral JavaScript Number when decoded.
   *
   * *Factory*: {@link module:Layout.nu64|nu64}
   *
   * **NOTE** Values with magnitude greater than 2^52 may not decode to
   * the exact value of the encoded representation.
   *
   * @augments {Layout}
   */


  var NearUInt64 = /*#__PURE__*/function (_Layout6) {
    _inherits(NearUInt64, _Layout6);

    var _super8 = _createSuper(NearUInt64);

    function NearUInt64(property) {
      _classCallCheck(this, NearUInt64);

      return _super8.call(this, 8, property);
    }
    /** @override */


    _createClass(NearUInt64, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var lo32 = b.readUInt32LE(offset);
        var hi32 = b.readUInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var split = divmodInt64(src);
        b.writeUInt32LE(split.lo32, offset);
        b.writeUInt32LE(split.hi32, offset + 4);
        return 8;
      }
    }]);

    return NearUInt64;
  }(Layout);
  /**
   * Represent an unsigned 64-bit integer in big-endian format when
   * encoded and as a near integral JavaScript Number when decoded.
   *
   * *Factory*: {@link module:Layout.nu64be|nu64be}
   *
   * **NOTE** Values with magnitude greater than 2^52 may not decode to
   * the exact value of the encoded representation.
   *
   * @augments {Layout}
   */


  var NearUInt64BE = /*#__PURE__*/function (_Layout7) {
    _inherits(NearUInt64BE, _Layout7);

    var _super9 = _createSuper(NearUInt64BE);

    function NearUInt64BE(property) {
      _classCallCheck(this, NearUInt64BE);

      return _super9.call(this, 8, property);
    }
    /** @override */


    _createClass(NearUInt64BE, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var hi32 = b.readUInt32BE(offset);
        var lo32 = b.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var split = divmodInt64(src);
        b.writeUInt32BE(split.hi32, offset);
        b.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    }]);

    return NearUInt64BE;
  }(Layout);
  /**
   * Represent a signed 64-bit integer in little-endian format when
   * encoded and as a near integral JavaScript Number when decoded.
   *
   * *Factory*: {@link module:Layout.ns64|ns64}
   *
   * **NOTE** Values with magnitude greater than 2^52 may not decode to
   * the exact value of the encoded representation.
   *
   * @augments {Layout}
   */


  var NearInt64 = /*#__PURE__*/function (_Layout8) {
    _inherits(NearInt64, _Layout8);

    var _super10 = _createSuper(NearInt64);

    function NearInt64(property) {
      _classCallCheck(this, NearInt64);

      return _super10.call(this, 8, property);
    }
    /** @override */


    _createClass(NearInt64, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var lo32 = b.readUInt32LE(offset);
        var hi32 = b.readInt32LE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var split = divmodInt64(src);
        b.writeUInt32LE(split.lo32, offset);
        b.writeInt32LE(split.hi32, offset + 4);
        return 8;
      }
    }]);

    return NearInt64;
  }(Layout);
  /**
   * Represent a signed 64-bit integer in big-endian format when
   * encoded and as a near integral JavaScript Number when decoded.
   *
   * *Factory*: {@link module:Layout.ns64be|ns64be}
   *
   * **NOTE** Values with magnitude greater than 2^52 may not decode to
   * the exact value of the encoded representation.
   *
   * @augments {Layout}
   */


  var NearInt64BE = /*#__PURE__*/function (_Layout9) {
    _inherits(NearInt64BE, _Layout9);

    var _super11 = _createSuper(NearInt64BE);

    function NearInt64BE(property) {
      _classCallCheck(this, NearInt64BE);

      return _super11.call(this, 8, property);
    }
    /** @override */


    _createClass(NearInt64BE, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var hi32 = b.readInt32BE(offset);
        var lo32 = b.readUInt32BE(offset + 4);
        return roundedInt64(hi32, lo32);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var split = divmodInt64(src);
        b.writeInt32BE(split.hi32, offset);
        b.writeUInt32BE(split.lo32, offset + 4);
        return 8;
      }
    }]);

    return NearInt64BE;
  }(Layout);
  /**
   * Represent a 32-bit floating point number in little-endian format.
   *
   * *Factory*: {@link module:Layout.f32|f32}
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var Float = /*#__PURE__*/function (_Layout10) {
    _inherits(Float, _Layout10);

    var _super12 = _createSuper(Float);

    function Float(property) {
      _classCallCheck(this, Float);

      return _super12.call(this, 4, property);
    }
    /** @override */


    _createClass(Float, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        return b.readFloatLE(offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        b.writeFloatLE(src, offset);
        return 4;
      }
    }]);

    return Float;
  }(Layout);
  /**
   * Represent a 32-bit floating point number in big-endian format.
   *
   * *Factory*: {@link module:Layout.f32be|f32be}
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var FloatBE = /*#__PURE__*/function (_Layout11) {
    _inherits(FloatBE, _Layout11);

    var _super13 = _createSuper(FloatBE);

    function FloatBE(property) {
      _classCallCheck(this, FloatBE);

      return _super13.call(this, 4, property);
    }
    /** @override */


    _createClass(FloatBE, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        return b.readFloatBE(offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        b.writeFloatBE(src, offset);
        return 4;
      }
    }]);

    return FloatBE;
  }(Layout);
  /**
   * Represent a 64-bit floating point number in little-endian format.
   *
   * *Factory*: {@link module:Layout.f64|f64}
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var Double = /*#__PURE__*/function (_Layout12) {
    _inherits(Double, _Layout12);

    var _super14 = _createSuper(Double);

    function Double(property) {
      _classCallCheck(this, Double);

      return _super14.call(this, 8, property);
    }
    /** @override */


    _createClass(Double, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        return b.readDoubleLE(offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        b.writeDoubleLE(src, offset);
        return 8;
      }
    }]);

    return Double;
  }(Layout);
  /**
   * Represent a 64-bit floating point number in big-endian format.
   *
   * *Factory*: {@link module:Layout.f64be|f64be}
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var DoubleBE = /*#__PURE__*/function (_Layout13) {
    _inherits(DoubleBE, _Layout13);

    var _super15 = _createSuper(DoubleBE);

    function DoubleBE(property) {
      _classCallCheck(this, DoubleBE);

      return _super15.call(this, 8, property);
    }
    /** @override */


    _createClass(DoubleBE, [{
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        return b.readDoubleBE(offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        b.writeDoubleBE(src, offset);
        return 8;
      }
    }]);

    return DoubleBE;
  }(Layout);
  /**
   * Represent a contiguous sequence of a specific layout as an Array.
   *
   * *Factory*: {@link module:Layout.seq|seq}
   *
   * @param {Layout} elementLayout - initializer for {@link
   * Sequence#elementLayout|elementLayout}.
   *
   * @param {(Number|ExternalLayout)} count - initializer for {@link
   * Sequence#count|count}.  The parameter must be either a positive
   * integer or an instance of {@link ExternalLayout}.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var Sequence = /*#__PURE__*/function (_Layout14) {
    _inherits(Sequence, _Layout14);

    var _super16 = _createSuper(Sequence);

    function Sequence(elementLayout, count, property) {
      var _this7;

      _classCallCheck(this, Sequence);

      if (!(elementLayout instanceof Layout)) {
        throw new TypeError('elementLayout must be a Layout');
      }

      if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {
        throw new TypeError('count must be non-negative integer ' + 'or an unsigned integer ExternalLayout');
      }

      var span = -1;

      if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {
        span = count * elementLayout.span;
      }

      _this7 = _super16.call(this, span, property);
      /** The layout for individual elements of the sequence. */

      _this7.elementLayout = elementLayout;
      /** The number of elements in the sequence.
       *
       * This will be either a non-negative integer or an instance of
       * {@link ExternalLayout} for which {@link
       * ExternalLayout#isCount|isCount()} is `true`. */

      _this7.count = count;
      return _this7;
    }
    /** @override */


    _createClass(Sequence, [{
      key: "getSpan",
      value: function getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }

        if (undefined === offset) {
          offset = 0;
        }

        var span = 0;
        var count = this.count;

        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset);
        }

        if (0 < this.elementLayout.span) {
          span = count * this.elementLayout.span;
        } else {
          var idx = 0;

          while (idx < count) {
            span += this.elementLayout.getSpan(b, offset + span);
            ++idx;
          }
        }

        return span;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var rv = [];
        var i = 0;
        var count = this.count;

        if (count instanceof ExternalLayout) {
          count = count.decode(b, offset);
        }

        while (i < count) {
          rv.push(this.elementLayout.decode(b, offset));
          offset += this.elementLayout.getSpan(b, offset);
          i += 1;
        }

        return rv;
      }
      /** Implement {@link Layout#encode|encode} for {@link Sequence}.
       *
       * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
       * the unused space in the buffer is left unchanged.  If `src` is
       * longer than {@link Sequence#count|count} the unneeded elements are
       * ignored.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var elo = this.elementLayout;
        var span = src.reduce(function (span, v) {
          return span + elo.encode(v, b, offset + span);
        }, 0);

        if (this.count instanceof ExternalLayout) {
          this.count.encode(src.length, b, offset);
        }

        return span;
      }
    }]);

    return Sequence;
  }(Layout);
  /**
   * Represent a contiguous sequence of arbitrary layout elements as an
   * Object.
   *
   * *Factory*: {@link module:Layout.struct|struct}
   *
   * **NOTE** The {@link Layout#span|span} of the structure is variable
   * if any layout in {@link Structure#fields|fields} has a variable
   * span.  When {@link Layout#encode|encoding} we must have a value for
   * all variable-length fields, or we wouldn't be able to figure out
   * how much space to use for storage.  We can only identify the value
   * for a field when it has a {@link Layout#property|property}.  As
   * such, although a structure may contain both unnamed fields and
   * variable-length fields, it cannot contain an unnamed
   * variable-length field.
   *
   * @param {Layout[]} fields - initializer for {@link
   * Structure#fields|fields}.  An error is raised if this contains a
   * variable-length field for which a {@link Layout#property|property}
   * is not defined.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @param {Boolean} [decodePrefixes] - initializer for {@link
   * Structure#decodePrefixes|property}.
   *
   * @throws {Error} - if `fields` contains an unnamed variable-length
   * layout.
   *
   * @augments {Layout}
   */


  var Structure = /*#__PURE__*/function (_Layout15) {
    _inherits(Structure, _Layout15);

    var _super17 = _createSuper(Structure);

    function Structure(fields, property, decodePrefixes) {
      var _this8;

      _classCallCheck(this, Structure);

      if (!(Array.isArray(fields) && fields.reduce(function (acc, v) {
        return acc && v instanceof Layout;
      }, true))) {
        throw new TypeError('fields must be array of Layout instances');
      }

      if ('boolean' === typeof property && undefined === decodePrefixes) {
        decodePrefixes = property;
        property = undefined;
      }
      /* Verify absence of unnamed variable-length fields. */


      var _iterator = _createForOfIteratorHelper(fields),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var fd = _step.value;

          if (0 > fd.span && undefined === fd.property) {
            throw new Error('fields cannot contain unnamed variable-length layout');
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var span = -1;

      try {
        span = fields.reduce(function (span, fd) {
          return span + fd.getSpan();
        }, 0);
      } catch (e) {}

      _this8 = _super17.call(this, span, property);
      /** The sequence of {@link Layout} values that comprise the
       * structure.
       *
       * The individual elements need not be the same type, and may be
       * either scalar or aggregate layouts.  If a member layout leaves
       * its {@link Layout#property|property} undefined the
       * corresponding region of the buffer associated with the element
       * will not be mutated.
       *
       * @type {Layout[]} */

      _this8.fields = fields;
      /** Control behavior of {@link Layout#decode|decode()} given short
       * buffers.
       *
       * In some situations a structure many be extended with additional
       * fields over time, with older installations providing only a
       * prefix of the full structure.  If this property is `true`
       * decoding will accept those buffers and leave subsequent fields
       * undefined, as long as the buffer ends at a field boundary.
       * Defaults to `false`. */

      _this8.decodePrefixes = !!decodePrefixes;
      return _this8;
    }
    /** @override */


    _createClass(Structure, [{
      key: "getSpan",
      value: function getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }

        if (undefined === offset) {
          offset = 0;
        }

        var span = 0;

        try {
          span = this.fields.reduce(function (span, fd) {
            var fsp = fd.getSpan(b, offset);
            offset += fsp;
            return span + fsp;
          }, 0);
        } catch (e) {
          throw new RangeError('indeterminate span');
        }

        return span;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var dest = this.makeDestinationObject();

        var _iterator2 = _createForOfIteratorHelper(this.fields),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var fd = _step2.value;

            if (undefined !== fd.property) {
              dest[fd.property] = fd.decode(b, offset);
            }

            offset += fd.getSpan(b, offset);

            if (this.decodePrefixes && b.length === offset) {
              break;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Structure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the buffer is
       * left unmodified. */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var firstOffset = offset;
        var lastOffset = 0;
        var lastWrote = 0;

        var _iterator3 = _createForOfIteratorHelper(this.fields),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var fd = _step3.value;
            var span = fd.span;
            lastWrote = 0 < span ? span : 0;

            if (undefined !== fd.property) {
              var fv = src[fd.property];

              if (undefined !== fv) {
                lastWrote = fd.encode(fv, b, offset);

                if (0 > span) {
                  /* Read the as-encoded span, which is not necessarily the
                   * same as what we wrote. */
                  span = fd.getSpan(b, offset);
                }
              }
            }

            lastOffset = offset;
            offset += span;
          }
          /* Use (lastOffset + lastWrote) instead of offset because the last
           * item may have had a dynamic length and we don't want to include
           * the padding between it and the end of the space reserved for
           * it. */

        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }

        return lastOffset + lastWrote - firstOffset;
      }
      /** @override */

    }, {
      key: "fromArray",
      value: function fromArray(values) {
        var dest = this.makeDestinationObject();

        var _iterator4 = _createForOfIteratorHelper(this.fields),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var fd = _step4.value;

            if (undefined !== fd.property && 0 < values.length) {
              dest[fd.property] = values.shift();
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return dest;
      }
      /**
       * Get access to the layout of a given property.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Layout} - the layout associated with `property`, or
       * undefined if there is no such property.
       */

    }, {
      key: "layoutFor",
      value: function layoutFor(property) {
        if ('string' !== typeof property) {
          throw new TypeError('property must be string');
        }

        var _iterator5 = _createForOfIteratorHelper(this.fields),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var fd = _step5.value;

            if (fd.property === property) {
              return fd;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
      /**
       * Get the offset of a structure member.
       *
       * @param {String} property - the structure member of interest.
       *
       * @return {Number} - the offset in bytes to the start of `property`
       * within the structure, or undefined if `property` is not a field
       * within the structure.  If the property is a member but follows a
       * variable-length structure member a negative number will be
       * returned.
       */

    }, {
      key: "offsetOf",
      value: function offsetOf(property) {
        if ('string' !== typeof property) {
          throw new TypeError('property must be string');
        }

        var offset = 0;

        var _iterator6 = _createForOfIteratorHelper(this.fields),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var fd = _step6.value;

            if (fd.property === property) {
              return offset;
            }

            if (0 > fd.span) {
              offset = -1;
            } else if (0 <= offset) {
              offset += fd.span;
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }
    }]);

    return Structure;
  }(Layout);
  /**
   * An object that can provide a {@link
   * Union#discriminator|discriminator} API for {@link Union}.
   *
   * **NOTE** This is an abstract base class; you can create instances
   * if it amuses you, but they won't support the {@link
   * UnionDiscriminator#encode|encode} or {@link
   * UnionDiscriminator#decode|decode} functions.
   *
   * @param {string} [property] - Default for {@link
   * UnionDiscriminator#property|property}.
   *
   * @abstract
   */


  var UnionDiscriminator = /*#__PURE__*/function () {
    function UnionDiscriminator(property) {
      _classCallCheck(this, UnionDiscriminator);

      /** The {@link Layout#property|property} to be used when the
       * discriminator is referenced in isolation (generally when {@link
       * Union#decode|Union decode} cannot delegate to a specific
       * variant). */
      this.property = property;
    }
    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
     *
     * The implementation of this method need not reference the buffer if
     * variant information is available through other means. */


    _createClass(UnionDiscriminator, [{
      key: "decode",
      value: function decode() {
        throw new Error('UnionDiscriminator is abstract');
      }
      /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
       *
       * The implementation of this method need not store the value if
       * variant information is maintained through other means. */

    }, {
      key: "encode",
      value: function encode() {
        throw new Error('UnionDiscriminator is abstract');
      }
    }]);

    return UnionDiscriminator;
  }();
  /**
   * An object that can provide a {@link
   * UnionDiscriminator|discriminator API} for {@link Union} using an
   * unsigned integral {@link Layout} instance located either inside or
   * outside the union.
   *
   * @param {ExternalLayout} layout - initializes {@link
   * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link
   * ExternalLayout#isCount|isCount()}.
   *
   * @param {string} [property] - Default for {@link
   * UnionDiscriminator#property|property}, superseding the property
   * from `layout`, but defaulting to `variant` if neither `property`
   * nor layout provide a property name.
   *
   * @augments {UnionDiscriminator}
   */


  var UnionLayoutDiscriminator = /*#__PURE__*/function (_UnionDiscriminator) {
    _inherits(UnionLayoutDiscriminator, _UnionDiscriminator);

    var _super18 = _createSuper(UnionLayoutDiscriminator);

    function UnionLayoutDiscriminator(layout, property) {
      var _this9;

      _classCallCheck(this, UnionLayoutDiscriminator);

      if (!(layout instanceof ExternalLayout && layout.isCount())) {
        throw new TypeError('layout must be an unsigned integer ExternalLayout');
      }

      _this9 = _super18.call(this, property || layout.property || 'variant');
      /** The {@link ExternalLayout} used to access the discriminator
       * value. */

      _this9.layout = layout;
      return _this9;
    }
    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */


    _createClass(UnionLayoutDiscriminator, [{
      key: "decode",
      value: function decode(b, offset) {
        return this.layout.decode(b, offset);
      }
      /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        return this.layout.encode(src, b, offset);
      }
    }]);

    return UnionLayoutDiscriminator;
  }(UnionDiscriminator);
  /**
   * Represent any number of span-compatible layouts.
   *
   * *Factory*: {@link module:Layout.union|union}
   *
   * If the union has a {@link Union#defaultLayout|default layout} that
   * layout must have a non-negative {@link Layout#span|span}.  The span
   * of a fixed-span union includes its {@link
   * Union#discriminator|discriminator} if the variant is a {@link
   * Union#usesPrefixDiscriminator|prefix of the union}, plus the span
   * of its {@link Union#defaultLayout|default layout}.
   *
   * If the union does not have a default layout then the encoded span
   * of the union depends on the encoded span of its variant (which may
   * be fixed or variable).
   *
   * {@link VariantLayout#layout|Variant layout}s are added through
   * {@link Union#addVariant|addVariant}.  If the union has a default
   * layout, the span of the {@link VariantLayout#layout|layout
   * contained by the variant} must not exceed the span of the {@link
   * Union#defaultLayout|default layout} (minus the span of a {@link
   * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The
   * span of the variant will equal the span of the union itself.
   *
   * The variant for a buffer can only be identified from the {@link
   * Union#discriminator|discriminator} {@link
   * UnionDiscriminator#property|property} (in the case of the {@link
   * Union#defaultLayout|default layout}), or by using {@link
   * Union#getVariant|getVariant} and examining the resulting {@link
   * VariantLayout} instance.
   *
   * A variant compatible with a JavaScript object can be identified
   * using {@link Union#getSourceVariant|getSourceVariant}.
   *
   * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to
   * identify the layout used to interpret the union contents.  The
   * parameter must be an instance of {@link UnionDiscriminator}, an
   * {@link ExternalLayout} that satisfies {@link
   * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link
   * UIntBE}).  When a non-external layout element is passed the layout
   * appears at the start of the union.  In all cases the (synthesized)
   * {@link UnionDiscriminator} instance is recorded as {@link
   * Union#discriminator|discriminator}.
   *
   * @param {(Layout|null)} defaultLayout - initializer for {@link
   * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.
   * If `null` there is no default layout: the union has data-dependent
   * length and attempts to decode or encode unrecognized variants will
   * throw an exception.  A {@link Layout} instance must have a
   * non-negative {@link Layout#span|span}, and if it lacks a {@link
   * Layout#property|property} the {@link
   * Union#defaultLayout|defaultLayout} will be a {@link
   * Layout#replicate|replica} with property `content`.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var Union = /*#__PURE__*/function (_Layout16) {
    _inherits(Union, _Layout16);

    var _super19 = _createSuper(Union);

    function Union(discr, defaultLayout, property) {
      var _this10;

      _classCallCheck(this, Union);

      var upv = discr instanceof UInt || discr instanceof UIntBE;

      if (upv) {
        discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));
      } else if (discr instanceof ExternalLayout && discr.isCount()) {
        discr = new UnionLayoutDiscriminator(discr);
      } else if (!(discr instanceof UnionDiscriminator)) {
        throw new TypeError('discr must be a UnionDiscriminator ' + 'or an unsigned integer layout');
      }

      if (undefined === defaultLayout) {
        defaultLayout = null;
      }

      if (!(null === defaultLayout || defaultLayout instanceof Layout)) {
        throw new TypeError('defaultLayout must be null or a Layout');
      }

      if (null !== defaultLayout) {
        if (0 > defaultLayout.span) {
          throw new Error('defaultLayout must have constant span');
        }

        if (undefined === defaultLayout.property) {
          defaultLayout = defaultLayout.replicate('content');
        }
      }
      /* The union span can be estimated only if there's a default
       * layout.  The union spans its default layout, plus any prefix
       * variant layout.  By construction both layouts, if present, have
       * non-negative span. */


      var span = -1;

      if (defaultLayout) {
        span = defaultLayout.span;

        if (0 <= span && upv) {
          span += discr.layout.span;
        }
      }

      _this10 = _super19.call(this, span, property);
      /** The interface for the discriminator value in isolation.
       *
       * This a {@link UnionDiscriminator} either passed to the
       * constructor or synthesized from the `discr` constructor
       * argument.  {@link
       * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be
       * `true` iff the `discr` parameter was a non-offset {@link
       * Layout} instance. */

      _this10.discriminator = discr;
      /** `true` if the {@link Union#discriminator|discriminator} is the
       * first field in the union.
       *
       * If `false` the discriminator is obtained from somewhere
       * else. */

      _this10.usesPrefixDiscriminator = upv;
      /** The layout for non-discriminator content when the value of the
       * discriminator is not recognized.
       *
       * This is the value passed to the constructor.  It is
       * structurally equivalent to the second component of {@link
       * Union#layout|layout} but may have a different property
       * name. */

      _this10.defaultLayout = defaultLayout;
      /** A registry of allowed variants.
       *
       * The keys are unsigned integers which should be compatible with
       * {@link Union.discriminator|discriminator}.  The property value
       * is the corresponding {@link VariantLayout} instances assigned
       * to this union by {@link Union#addVariant|addVariant}.
       *
       * **NOTE** The registry remains mutable so that variants can be
       * {@link Union#addVariant|added} at any time.  Users should not
       * manipulate the content of this property. */

      _this10.registry = {};
      /* Private variable used when invoking getSourceVariant */

      var boundGetSourceVariant = _this10.defaultGetSourceVariant.bind(_assertThisInitialized(_this10));
      /** Function to infer the variant selected by a source object.
       *
       * Defaults to {@link
       * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may
       * be overridden using {@link
       * Union#configGetSourceVariant|configGetSourceVariant}.
       *
       * @param {Object} src - as with {@link
       * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
       *
       * @returns {(undefined|VariantLayout)} The default variant
       * (`undefined`) or first registered variant that uses a property
       * available in `src`. */


      _this10.getSourceVariant = function (src) {
        return boundGetSourceVariant(src);
      };
      /** Function to override the implementation of {@link
       * Union#getSourceVariant|getSourceVariant}.
       *
       * Use this if the desired variant cannot be identified using the
       * algorithm of {@link
       * Union#defaultGetSourceVariant|defaultGetSourceVariant}.
       *
       * **NOTE** The provided function will be invoked bound to this
       * Union instance, providing local access to {@link
       * Union#registry|registry}.
       *
       * @param {Function} gsv - a function that follows the API of
       * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */


      _this10.configGetSourceVariant = function (gsv) {
        boundGetSourceVariant = gsv.bind(this);
      };

      return _this10;
    }
    /** @override */


    _createClass(Union, [{
      key: "getSpan",
      value: function getSpan(b, offset) {
        if (0 <= this.span) {
          return this.span;
        }

        if (undefined === offset) {
          offset = 0;
        }
        /* Default layouts always have non-negative span, so we don't have
         * one and we have to recognize the variant which will in turn
         * determine the span. */


        var vlo = this.getVariant(b, offset);

        if (!vlo) {
          throw new Error('unable to determine span for unrecognized variant');
        }

        return vlo.getSpan(b, offset);
      }
      /**
       * Method to infer a registered Union variant compatible with `src`.
       *
       * The first satisified rule in the following sequence defines the
       * return value:
       * * If `src` has properties matching the Union discriminator and
       *   the default layout, `undefined` is returned regardless of the
       *   value of the discriminator property (this ensures the default
       *   layout will be used);
       * * If `src` has a property matching the Union discriminator, the
       *   value of the discriminator identifies a registered variant, and
       *   either (a) the variant has no layout, or (b) `src` has the
       *   variant's property, then the variant is returned (because the
       *   source satisfies the constraints of the variant it identifies);
       * * If `src` does not have a property matching the Union
       *   discriminator, but does have a property matching a registered
       *   variant, then the variant is returned (because the source
       *   matches a variant without an explicit conflict);
       * * An error is thrown (because we either can't identify a variant,
       *   or we were explicitly told the variant but can't satisfy it).
       *
       * @param {Object} src - an object presumed to be compatible with
       * the content of the Union.
       *
       * @return {(undefined|VariantLayout)} - as described above.
       *
       * @throws {Error} - if `src` cannot be associated with a default or
       * registered variant.
       */

    }, {
      key: "defaultGetSourceVariant",
      value: function defaultGetSourceVariant(src) {
        if (src.hasOwnProperty(this.discriminator.property)) {
          if (this.defaultLayout && src.hasOwnProperty(this.defaultLayout.property)) {
            return undefined;
          }

          var vlo = this.registry[src[this.discriminator.property]];

          if (vlo && (!vlo.layout || src.hasOwnProperty(vlo.property))) {
            return vlo;
          }
        } else {
          for (var tag in this.registry) {
            var _vlo = this.registry[tag];

            if (src.hasOwnProperty(_vlo.property)) {
              return _vlo;
            }
          }
        }

        throw new Error('unable to infer src variant');
      }
      /** Implement {@link Layout#decode|decode} for {@link Union}.
       *
       * If the variant is {@link Union#addVariant|registered} the return
       * value is an instance of that variant, with no explicit
       * discriminator.  Otherwise the {@link Union#defaultLayout|default
       * layout} is used to decode the content. */

    }, {
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var dest;
        var dlo = this.discriminator;
        var discr = dlo.decode(b, offset);
        var clo = this.registry[discr];

        if (undefined === clo) {
          var contentOffset = 0;
          clo = this.defaultLayout;

          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }

          dest = this.makeDestinationObject();
          dest[dlo.property] = discr;
          dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);
        } else {
          dest = clo.decode(b, offset);
        }

        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link Union}.
       *
       * This API assumes the `src` object is consistent with the union's
       * {@link Union#defaultLayout|default layout}.  To encode variants
       * use the appropriate variant-specific {@link VariantLayout#encode}
       * method. */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var vlo = this.getSourceVariant(src);

        if (undefined === vlo) {
          var dlo = this.discriminator;
          var clo = this.defaultLayout;
          var contentOffset = 0;

          if (this.usesPrefixDiscriminator) {
            contentOffset = dlo.layout.span;
          }

          dlo.encode(src[dlo.property], b, offset);
          return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);
        }

        return vlo.encode(src, b, offset);
      }
      /** Register a new variant structure within a union.  The newly
       * created variant is returned.
       *
       * @param {Number} variant - initializer for {@link
       * VariantLayout#variant|variant}.
       *
       * @param {Layout} layout - initializer for {@link
       * VariantLayout#layout|layout}.
       *
       * @param {String} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {VariantLayout} */

    }, {
      key: "addVariant",
      value: function addVariant(variant, layout, property) {
        var rv = new VariantLayout(this, variant, layout, property);
        this.registry[variant] = rv;
        return rv;
      }
      /**
       * Get the layout associated with a registered variant.
       *
       * If `vb` does not produce a registered variant the function returns
       * `undefined`.
       *
       * @param {(Number|Buffer)} vb - either the variant number, or a
       * buffer from which the discriminator is to be read.
       *
       * @param {Number} offset - offset into `vb` for the start of the
       * union.  Used only when `vb` is an instance of {Buffer}.
       *
       * @return {({VariantLayout}|undefined)}
       */

    }, {
      key: "getVariant",
      value: function getVariant(vb, offset) {
        var variant = vb;

        if (Buffer$1.isBuffer(vb)) {
          if (undefined === offset) {
            offset = 0;
          }

          variant = this.discriminator.decode(vb, offset);
        }

        return this.registry[variant];
      }
    }]);

    return Union;
  }(Layout);
  /**
   * Represent a specific variant within a containing union.
   *
   * **NOTE** The {@link Layout#span|span} of the variant may include
   * the span of the {@link Union#discriminator|discriminator} used to
   * identify it, but values read and written using the variant strictly
   * conform to the content of {@link VariantLayout#layout|layout}.
   *
   * **NOTE** User code should not invoke this constructor directly.  Use
   * the union {@link Union#addVariant|addVariant} helper method.
   *
   * @param {Union} union - initializer for {@link
   * VariantLayout#union|union}.
   *
   * @param {Number} variant - initializer for {@link
   * VariantLayout#variant|variant}.
   *
   * @param {Layout} [layout] - initializer for {@link
   * VariantLayout#layout|layout}.  If absent the variant carries no
   * data.
   *
   * @param {String} [property] - initializer for {@link
   * Layout#property|property}.  Unlike many other layouts, variant
   * layouts normally include a property name so they can be identified
   * within their containing {@link Union}.  The property identifier may
   * be absent only if `layout` is is absent.
   *
   * @augments {Layout}
   */


  var VariantLayout = /*#__PURE__*/function (_Layout17) {
    _inherits(VariantLayout, _Layout17);

    var _super20 = _createSuper(VariantLayout);

    function VariantLayout(union, variant, layout, property) {
      var _this11;

      _classCallCheck(this, VariantLayout);

      if (!(union instanceof Union)) {
        throw new TypeError('union must be a Union');
      }

      if (!Number.isInteger(variant) || 0 > variant) {
        throw new TypeError('variant must be a (non-negative) integer');
      }

      if ('string' === typeof layout && undefined === property) {
        property = layout;
        layout = null;
      }

      if (layout) {
        if (!(layout instanceof Layout)) {
          throw new TypeError('layout must be a Layout');
        }

        if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {
          throw new Error('variant span exceeds span of containing union');
        }

        if ('string' !== typeof property) {
          throw new TypeError('variant must have a String property');
        }
      }

      var span = union.span;

      if (0 > union.span) {
        span = layout ? layout.span : 0;

        if (0 <= span && union.usesPrefixDiscriminator) {
          span += union.discriminator.layout.span;
        }
      }

      _this11 = _super20.call(this, span, property);
      /** The {@link Union} to which this variant belongs. */

      _this11.union = union;
      /** The unsigned integral value identifying this variant within
       * the {@link Union#discriminator|discriminator} of the containing
       * union. */

      _this11.variant = variant;
      /** The {@link Layout} to be used when reading/writing the
       * non-discriminator part of the {@link
       * VariantLayout#union|union}.  If `null` the variant carries no
       * data. */

      _this11.layout = layout || null;
      return _this11;
    }
    /** @override */


    _createClass(VariantLayout, [{
      key: "getSpan",
      value: function getSpan(b, offset) {
        if (0 <= this.span) {
          /* Will be equal to the containing union span if that is not
           * variable. */
          return this.span;
        }

        if (undefined === offset) {
          offset = 0;
        }

        var contentOffset = 0;

        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }
        /* Span is defined solely by the variant (and prefix discriminator) */


        return contentOffset + this.layout.getSpan(b, offset + contentOffset);
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b, offset) {
        var dest = this.makeDestinationObject();

        if (undefined === offset) {
          offset = 0;
        }

        if (this !== this.union.getVariant(b, offset)) {
          throw new Error('variant mismatch');
        }

        var contentOffset = 0;

        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }

        if (this.layout) {
          dest[this.property] = this.layout.decode(b, offset + contentOffset);
        } else if (this.property) {
          dest[this.property] = true;
        } else if (this.union.usesPrefixDiscriminator) {
          dest[this.union.discriminator.property] = this.variant;
        }

        return dest;
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var contentOffset = 0;

        if (this.union.usesPrefixDiscriminator) {
          contentOffset = this.union.discriminator.layout.span;
        }

        if (this.layout && !src.hasOwnProperty(this.property)) {
          throw new TypeError('variant lacks property ' + this.property);
        }

        this.union.discriminator.encode(this.variant, b, offset);
        var span = contentOffset;

        if (this.layout) {
          this.layout.encode(src[this.property], b, offset + contentOffset);
          span += this.layout.getSpan(b, offset + contentOffset);

          if (0 <= this.union.span && span > this.union.span) {
            throw new Error('encoded variant overruns containing union');
          }
        }

        return span;
      }
      /** Delegate {@link Layout#fromArray|fromArray} to {@link
       * VariantLayout#layout|layout}. */

    }, {
      key: "fromArray",
      value: function fromArray(values) {
        if (this.layout) {
          return this.layout.fromArray(values);
        }
      }
    }]);

    return VariantLayout;
  }(Layout);
  /** JavaScript chose to define bitwise operations as operating on
   * signed 32-bit values in 2's complement form, meaning any integer
   * with bit 31 set is going to look negative.  For right shifts that's
   * not a problem, because `>>>` is a logical shift, but for every
   * other bitwise operator we have to compensate for possible negative
   * results. */


  function fixBitwiseResult(v) {
    if (0 > v) {
      v += 0x100000000;
    }

    return v;
  }
  /**
   * Contain a sequence of bit fields as an unsigned integer.
   *
   * *Factory*: {@link module:Layout.bits|bits}
   *
   * This is a container element; within it there are {@link BitField}
   * instances that provide the extracted properties.  The container
   * simply defines the aggregate representation and its bit ordering.
   * The representation is an object containing properties with numeric
   * or {@link Boolean} values.
   *
   * {@link BitField}s are added with the {@link
   * BitStructure#addField|addField} and {@link
   * BitStructure#addBoolean|addBoolean} methods.

   * @param {Layout} word - initializer for {@link
   * BitStructure#word|word}.  The parameter must be an instance of
   * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.
   *
   * @param {bool} [msb] - `true` if the bit numbering starts at the
   * most significant bit of the containing word; `false` (default) if
   * it starts at the least significant bit of the containing word.  If
   * the parameter at this position is a string and `property` is
   * `undefined` the value of this argument will instead be used as the
   * value of `property`.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var BitStructure = /*#__PURE__*/function (_Layout18) {
    _inherits(BitStructure, _Layout18);

    var _super21 = _createSuper(BitStructure);

    function BitStructure(word, msb, property) {
      var _this12;

      _classCallCheck(this, BitStructure);

      if (!(word instanceof UInt || word instanceof UIntBE)) {
        throw new TypeError('word must be a UInt or UIntBE layout');
      }

      if ('string' === typeof msb && undefined === property) {
        property = msb;
        msb = undefined;
      }

      if (4 < word.span) {
        throw new RangeError('word cannot exceed 32 bits');
      }

      _this12 = _super21.call(this, word.span, property);
      /** The layout used for the packed value.  {@link BitField}
       * instances are packed sequentially depending on {@link
       * BitStructure#msb|msb}. */

      _this12.word = word;
      /** Whether the bit sequences are packed starting at the most
       * significant bit growing down (`true`), or the least significant
       * bit growing up (`false`).
       *
       * **NOTE** Regardless of this value, the least significant bit of
       * any {@link BitField} value is the least significant bit of the
       * corresponding section of the packed value. */

      _this12.msb = !!msb;
      /** The sequence of {@link BitField} layouts that comprise the
       * packed structure.
       *
       * **NOTE** The array remains mutable to allow fields to be {@link
       * BitStructure#addField|added} after construction.  Users should
       * not manipulate the content of this property.*/

      _this12.fields = [];
      /* Storage for the value.  Capture a variable instead of using an
       * instance property because we don't want anything to change the
       * value without going through the mutator. */

      var value = 0;

      _this12._packedSetValue = function (v) {
        value = fixBitwiseResult(v);
        return this;
      };

      _this12._packedGetValue = function () {
        return value;
      };

      return _this12;
    }
    /** @override */


    _createClass(BitStructure, [{
      key: "decode",
      value: function decode(b, offset) {
        var dest = this.makeDestinationObject();

        if (undefined === offset) {
          offset = 0;
        }

        var value = this.word.decode(b, offset);

        this._packedSetValue(value);

        var _iterator7 = _createForOfIteratorHelper(this.fields),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var fd = _step7.value;

            if (undefined !== fd.property) {
              dest[fd.property] = fd.decode(value);
            }
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }

        return dest;
      }
      /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
       *
       * If `src` is missing a property for a member with a defined {@link
       * Layout#property|property} the corresponding region of the packed
       * value is left unmodified.  Unused bits are also left unmodified. */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var value = this.word.decode(b, offset);

        this._packedSetValue(value);

        var _iterator8 = _createForOfIteratorHelper(this.fields),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var fd = _step8.value;

            if (undefined !== fd.property) {
              var fv = src[fd.property];

              if (undefined !== fv) {
                fd.encode(fv);
              }
            }
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }

        return this.word.encode(this._packedGetValue(), b, offset);
      }
      /** Register a new bitfield with a containing bit structure.  The
       * resulting bitfield is returned.
       *
       * @param {Number} bits - initializer for {@link BitField#bits|bits}.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {BitField} */

    }, {
      key: "addField",
      value: function addField(bits, property) {
        var bf = new BitField(this, bits, property);
        this.fields.push(bf);
        return bf;
      }
      /** As with {@link BitStructure#addField|addField} for single-bit
       * fields with `boolean` value representation.
       *
       * @param {string} property - initializer for {@link
       * Layout#property|property}.
       *
       * @return {Boolean} */

    }, {
      key: "addBoolean",
      value: function addBoolean(property) {
        // This is my Boolean, not the Javascript one.
        // eslint-disable-next-line no-new-wrappers
        var bf = new Boolean$1(this, property);
        this.fields.push(bf);
        return bf;
      }
      /**
       * Get access to the bit field for a given property.
       *
       * @param {String} property - the bit field of interest.
       *
       * @return {BitField} - the field associated with `property`, or
       * undefined if there is no such property.
       */

    }, {
      key: "fieldFor",
      value: function fieldFor(property) {
        if ('string' !== typeof property) {
          throw new TypeError('property must be string');
        }

        var _iterator9 = _createForOfIteratorHelper(this.fields),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var fd = _step9.value;

            if (fd.property === property) {
              return fd;
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
      }
    }]);

    return BitStructure;
  }(Layout);
  /**
   * Represent a sequence of bits within a {@link BitStructure}.
   *
   * All bit field values are represented as unsigned integers.
   *
   * **NOTE** User code should not invoke this constructor directly.
   * Use the container {@link BitStructure#addField|addField} helper
   * method.
   *
   * **NOTE** BitField instances are not instances of {@link Layout}
   * since {@link Layout#span|span} measures 8-bit units.
   *
   * @param {BitStructure} container - initializer for {@link
   * BitField#container|container}.
   *
   * @param {Number} bits - initializer for {@link BitField#bits|bits}.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   */


  var BitField = /*#__PURE__*/function () {
    function BitField(container, bits, property) {
      _classCallCheck(this, BitField);

      if (!(container instanceof BitStructure)) {
        throw new TypeError('container must be a BitStructure');
      }

      if (!Number.isInteger(bits) || 0 >= bits) {
        throw new TypeError('bits must be positive integer');
      }

      var totalBits = 8 * container.span;
      var usedBits = container.fields.reduce(function (sum, fd) {
        return sum + fd.bits;
      }, 0);

      if (bits + usedBits > totalBits) {
        throw new Error('bits too long for span remainder (' + (totalBits - usedBits) + ' of ' + totalBits + ' remain)');
      }
      /** The {@link BitStructure} instance to which this bit field
       * belongs. */


      this.container = container;
      /** The span of this value in bits. */

      this.bits = bits;
      /** A mask of {@link BitField#bits|bits} bits isolating value bits
       * that fit within the field.
       *
       * That is, it masks a value that has not yet been shifted into
       * position within its containing packed integer. */

      this.valueMask = (1 << bits) - 1;

      if (32 === bits) {
        // shifted value out of range
        this.valueMask = 0xFFFFFFFF;
      }
      /** The offset of the value within the containing packed unsigned
       * integer.  The least significant bit of the packed value is at
       * offset zero, regardless of bit ordering used. */


      this.start = usedBits;

      if (this.container.msb) {
        this.start = totalBits - usedBits - bits;
      }
      /** A mask of {@link BitField#bits|bits} isolating the field value
       * within the containing packed unsigned integer. */


      this.wordMask = fixBitwiseResult(this.valueMask << this.start);
      /** The property name used when this bitfield is represented in an
       * Object.
       *
       * Intended to be functionally equivalent to {@link
       * Layout#property}.
       *
       * If left undefined the corresponding span of bits will be
       * treated as padding: it will not be mutated by {@link
       * Layout#encode|encode} nor represented as a property in the
       * decoded Object. */

      this.property = property;
    }
    /** Store a value into the corresponding subsequence of the containing
     * bit field. */


    _createClass(BitField, [{
      key: "decode",
      value: function decode() {
        var word = this.container._packedGetValue();

        var wordValue = fixBitwiseResult(word & this.wordMask);
        var value = wordValue >>> this.start;
        return value;
      }
      /** Store a value into the corresponding subsequence of the containing
       * bit field.
       *
       * **NOTE** This is not a specialization of {@link
       * Layout#encode|Layout.encode} and there is no return value. */

    }, {
      key: "encode",
      value: function encode(value) {
        if (!Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {
          throw new TypeError(nameWithProperty('BitField.encode', this) + ' value must be integer not exceeding ' + this.valueMask);
        }

        var word = this.container._packedGetValue();

        var wordValue = fixBitwiseResult(value << this.start);

        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);
      }
    }]);

    return BitField;
  }();
  /**
   * Represent a single bit within a {@link BitStructure} as a
   * JavaScript boolean.
   *
   * **NOTE** User code should not invoke this constructor directly.
   * Use the container {@link BitStructure#addBoolean|addBoolean} helper
   * method.
   *
   * @param {BitStructure} container - initializer for {@link
   * BitField#container|container}.
   *
   * @param {string} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {BitField}
   */

  /* eslint-disable no-extend-native */


  var Boolean$1 = /*#__PURE__*/function (_BitField) {
    _inherits(Boolean, _BitField);

    var _super22 = _createSuper(Boolean);

    function Boolean(container, property) {
      _classCallCheck(this, Boolean);

      return _super22.call(this, container, 1, property);
    }
    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
     *
     * @returns {boolean} */


    _createClass(Boolean, [{
      key: "decode",
      value: function decode(b, offset) {
        return !!BitField.prototype.decode.call(this, b, offset);
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(value) {
        if ('boolean' === typeof value) {
          // BitField requires integer values
          value = +value;
        }

        return BitField.prototype.encode.call(this, value);
      }
    }]);

    return Boolean;
  }(BitField);
  /* eslint-enable no-extend-native */

  /**
   * Contain a fixed-length block of arbitrary data, represented as a
   * Buffer.
   *
   * *Factory*: {@link module:Layout.blob|blob}
   *
   * @param {(Number|ExternalLayout)} length - initializes {@link
   * Blob#length|length}.
   *
   * @param {String} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var Blob = /*#__PURE__*/function (_Layout19) {
    _inherits(Blob, _Layout19);

    var _super23 = _createSuper(Blob);

    function Blob(length, property) {
      var _this13;

      _classCallCheck(this, Blob);

      if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {
        throw new TypeError('length must be positive integer ' + 'or an unsigned integer ExternalLayout');
      }

      var span = -1;

      if (!(length instanceof ExternalLayout)) {
        span = length;
      }

      _this13 = _super23.call(this, span, property);
      /** The number of bytes in the blob.
       *
       * This may be a non-negative integer, or an instance of {@link
       * ExternalLayout} that satisfies {@link
       * ExternalLayout#isCount|isCount()}. */

      _this13.length = length;
      return _this13;
    }
    /** @override */


    _createClass(Blob, [{
      key: "getSpan",
      value: function getSpan(b, offset) {
        var span = this.span;

        if (0 > span) {
          span = this.length.decode(b, offset);
        }

        return span;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b, offset) {
        if (undefined === offset) {
          offset = 0;
        }

        var span = this.span;

        if (0 > span) {
          span = this.length.decode(b, offset);
        }

        return b.slice(offset, offset + span);
      }
      /** Implement {@link Layout#encode|encode} for {@link Blob}.
       *
       * **NOTE** If {@link Layout#count|count} is an instance of {@link
       * ExternalLayout} then the length of `src` will be encoded as the
       * count after `src` is encoded. */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        var span = this.length;

        if (this.length instanceof ExternalLayout) {
          span = src.length;
        }

        if (!(Buffer$1.isBuffer(src) && span === src.length)) {
          throw new TypeError(nameWithProperty('Blob.encode', this) + ' requires (length ' + span + ') Buffer as src');
        }

        if (offset + span > b.length) {
          throw new RangeError('encoding overruns Buffer');
        }

        b.write(src.toString('hex'), offset, span, 'hex');

        if (this.length instanceof ExternalLayout) {
          this.length.encode(span, b, offset);
        }

        return span;
      }
    }]);

    return Blob;
  }(Layout);
  /**
   * Contain a `NUL`-terminated UTF8 string.
   *
   * *Factory*: {@link module:Layout.cstr|cstr}
   *
   * **NOTE** Any UTF8 string that incorporates a zero-valued byte will
   * not be correctly decoded by this layout.
   *
   * @param {String} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var CString = /*#__PURE__*/function (_Layout20) {
    _inherits(CString, _Layout20);

    var _super24 = _createSuper(CString);

    function CString(property) {
      _classCallCheck(this, CString);

      return _super24.call(this, -1, property);
    }
    /** @override */


    _createClass(CString, [{
      key: "getSpan",
      value: function getSpan(b, offset) {
        if (!Buffer$1.isBuffer(b)) {
          throw new TypeError('b must be a Buffer');
        }

        if (undefined === offset) {
          offset = 0;
        }

        var idx = offset;

        while (idx < b.length && 0 !== b[idx]) {
          idx += 1;
        }

        return 1 + idx - offset;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b, offset, dest) {
        if (undefined === offset) {
          offset = 0;
        }

        var span = this.getSpan(b, offset);
        return b.slice(offset, offset + span - 1).toString('utf-8');
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }
        /* Must force this to a string, lest it be a number and the
         * "utf8-encoding" below actually allocate a buffer of length
         * src */


        if ('string' !== typeof src) {
          src = src.toString();
        }

        var srcb = new Buffer$1(src, 'utf8');
        var span = srcb.length;

        if (offset + span > b.length) {
          throw new RangeError('encoding overruns Buffer');
        }

        srcb.copy(b, offset);
        b[offset + span] = 0;
        return span + 1;
      }
    }]);

    return CString;
  }(Layout);
  /**
   * Contain a UTF8 string with implicit length.
   *
   * *Factory*: {@link module:Layout.utf8|utf8}
   *
   * **NOTE** Because the length is implicit in the size of the buffer
   * this layout should be used only in isolation, or in a situation
   * where the length can be expressed by operating on a slice of the
   * containing buffer.
   *
   * @param {Number} [maxSpan] - the maximum length allowed for encoded
   * string content.  If not provided there is no bound on the allowed
   * content.
   *
   * @param {String} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var UTF8 = /*#__PURE__*/function (_Layout21) {
    _inherits(UTF8, _Layout21);

    var _super25 = _createSuper(UTF8);

    function UTF8(maxSpan, property) {
      var _this14;

      _classCallCheck(this, UTF8);

      if ('string' === typeof maxSpan && undefined === property) {
        property = maxSpan;
        maxSpan = undefined;
      }

      if (undefined === maxSpan) {
        maxSpan = -1;
      } else if (!Number.isInteger(maxSpan)) {
        throw new TypeError('maxSpan must be an integer');
      }

      _this14 = _super25.call(this, -1, property);
      /** The maximum span of the layout in bytes.
       *
       * Positive values are generally expected.  Zero is abnormal.
       * Attempts to encode or decode a value that exceeds this length
       * will throw a `RangeError`.
       *
       * A negative value indicates that there is no bound on the length
       * of the content. */

      _this14.maxSpan = maxSpan;
      return _this14;
    }
    /** @override */


    _createClass(UTF8, [{
      key: "getSpan",
      value: function getSpan(b, offset) {
        if (!Buffer$1.isBuffer(b)) {
          throw new TypeError('b must be a Buffer');
        }

        if (undefined === offset) {
          offset = 0;
        }

        return b.length - offset;
      }
      /** @override */

    }, {
      key: "decode",
      value: function decode(b, offset, dest) {
        if (undefined === offset) {
          offset = 0;
        }

        var span = this.getSpan(b, offset);

        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError('text length exceeds maxSpan');
        }

        return b.slice(offset, offset + span).toString('utf-8');
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        if (undefined === offset) {
          offset = 0;
        }
        /* Must force this to a string, lest it be a number and the
         * "utf8-encoding" below actually allocate a buffer of length
         * src */


        if ('string' !== typeof src) {
          src = src.toString();
        }

        var srcb = new Buffer$1(src, 'utf8');
        var span = srcb.length;

        if (0 <= this.maxSpan && this.maxSpan < span) {
          throw new RangeError('text length exceeds maxSpan');
        }

        if (offset + span > b.length) {
          throw new RangeError('encoding overruns Buffer');
        }

        srcb.copy(b, offset);
        return span;
      }
    }]);

    return UTF8;
  }(Layout);
  /**
   * Contain a constant value.
   *
   * This layout may be used in cases where a JavaScript value can be
   * inferred without an expression in the binary encoding.  An example
   * would be a {@link VariantLayout|variant layout} where the content
   * is implied by the union {@link Union#discriminator|discriminator}.
   *
   * @param {Object|Number|String} value - initializer for {@link
   * Constant#value|value}.  If the value is an object (or array) and
   * the application intends the object to remain unchanged regardless
   * of what is done to values decoded by this layout, the value should
   * be frozen prior passing it to this constructor.
   *
   * @param {String} [property] - initializer for {@link
   * Layout#property|property}.
   *
   * @augments {Layout}
   */


  var Constant = /*#__PURE__*/function (_Layout22) {
    _inherits(Constant, _Layout22);

    var _super26 = _createSuper(Constant);

    function Constant(value, property) {
      var _this15;

      _classCallCheck(this, Constant);

      _this15 = _super26.call(this, 0, property);
      /** The value produced by this constant when the layout is {@link
       * Constant#decode|decoded}.
       *
       * Any JavaScript value including `null` and `undefined` is
       * permitted.
       *
       * **WARNING** If `value` passed in the constructor was not
       * frozen, it is possible for users of decoded values to change
       * the content of the value. */

      _this15.value = value;
      return _this15;
    }
    /** @override */


    _createClass(Constant, [{
      key: "decode",
      value: function decode(b, offset, dest) {
        return this.value;
      }
      /** @override */

    }, {
      key: "encode",
      value: function encode(src, b, offset) {
        /* Constants take no space */
        return 0;
      }
    }]);

    return Constant;
  }(Layout);

  Layout$1.ExternalLayout = ExternalLayout;
  Layout$1.GreedyCount = GreedyCount;
  Layout$1.OffsetLayout = OffsetLayout;
  Layout$1.UInt = UInt;
  Layout$1.UIntBE = UIntBE;
  Layout$1.Int = Int;
  Layout$1.IntBE = IntBE;
  Layout$1.Float = Float;
  Layout$1.FloatBE = FloatBE;
  Layout$1.Double = Double;
  Layout$1.DoubleBE = DoubleBE;
  Layout$1.Sequence = Sequence;
  Layout$1.Structure = Structure;
  Layout$1.UnionDiscriminator = UnionDiscriminator;
  Layout$1.UnionLayoutDiscriminator = UnionLayoutDiscriminator;
  Layout$1.Union = Union;
  Layout$1.VariantLayout = VariantLayout;
  Layout$1.BitStructure = BitStructure;
  Layout$1.BitField = BitField;

  Layout$1.Boolean = Boolean$1;

  Layout$1.Blob = Blob;
  Layout$1.CString = CString;
  Layout$1.UTF8 = UTF8;
  Layout$1.Constant = Constant;
  /** Factory for {@link GreedyCount}. */

  Layout$1.greedy = function (elementSpan, property) {
    return new GreedyCount(elementSpan, property);
  };
  /** Factory for {@link OffsetLayout}. */


  Layout$1.offset = function (layout, offset, property) {
    return new OffsetLayout(layout, offset, property);
  };
  /** Factory for {@link UInt|unsigned int layouts} spanning one
   * byte. */


  Layout$1.u8 = function (property) {
    return new UInt(1, property);
  };
  /** Factory for {@link UInt|little-endian unsigned int layouts}
   * spanning two bytes. */


  Layout$1.u16 = function (property) {
    return new UInt(2, property);
  };
  /** Factory for {@link UInt|little-endian unsigned int layouts}
   * spanning three bytes. */


  Layout$1.u24 = function (property) {
    return new UInt(3, property);
  };
  /** Factory for {@link UInt|little-endian unsigned int layouts}
   * spanning four bytes. */


  Layout$1.u32 = function (property) {
    return new UInt(4, property);
  };
  /** Factory for {@link UInt|little-endian unsigned int layouts}
   * spanning five bytes. */


  Layout$1.u40 = function (property) {
    return new UInt(5, property);
  };
  /** Factory for {@link UInt|little-endian unsigned int layouts}
   * spanning six bytes. */


  Layout$1.u48 = function (property) {
    return new UInt(6, property);
  };
  /** Factory for {@link NearUInt64|little-endian unsigned int
   * layouts} interpreted as Numbers. */


  Layout$1.nu64 = function (property) {
    return new NearUInt64(property);
  };
  /** Factory for {@link UInt|big-endian unsigned int layouts}
   * spanning two bytes. */


  Layout$1.u16be = function (property) {
    return new UIntBE(2, property);
  };
  /** Factory for {@link UInt|big-endian unsigned int layouts}
   * spanning three bytes. */


  Layout$1.u24be = function (property) {
    return new UIntBE(3, property);
  };
  /** Factory for {@link UInt|big-endian unsigned int layouts}
   * spanning four bytes. */


  Layout$1.u32be = function (property) {
    return new UIntBE(4, property);
  };
  /** Factory for {@link UInt|big-endian unsigned int layouts}
   * spanning five bytes. */


  Layout$1.u40be = function (property) {
    return new UIntBE(5, property);
  };
  /** Factory for {@link UInt|big-endian unsigned int layouts}
   * spanning six bytes. */


  Layout$1.u48be = function (property) {
    return new UIntBE(6, property);
  };
  /** Factory for {@link NearUInt64BE|big-endian unsigned int
   * layouts} interpreted as Numbers. */


  Layout$1.nu64be = function (property) {
    return new NearUInt64BE(property);
  };
  /** Factory for {@link Int|signed int layouts} spanning one
   * byte. */


  Layout$1.s8 = function (property) {
    return new Int(1, property);
  };
  /** Factory for {@link Int|little-endian signed int layouts}
   * spanning two bytes. */


  Layout$1.s16 = function (property) {
    return new Int(2, property);
  };
  /** Factory for {@link Int|little-endian signed int layouts}
   * spanning three bytes. */


  Layout$1.s24 = function (property) {
    return new Int(3, property);
  };
  /** Factory for {@link Int|little-endian signed int layouts}
   * spanning four bytes. */


  Layout$1.s32 = function (property) {
    return new Int(4, property);
  };
  /** Factory for {@link Int|little-endian signed int layouts}
   * spanning five bytes. */


  Layout$1.s40 = function (property) {
    return new Int(5, property);
  };
  /** Factory for {@link Int|little-endian signed int layouts}
   * spanning six bytes. */


  Layout$1.s48 = function (property) {
    return new Int(6, property);
  };
  /** Factory for {@link NearInt64|little-endian signed int layouts}
   * interpreted as Numbers. */


  Layout$1.ns64 = function (property) {
    return new NearInt64(property);
  };
  /** Factory for {@link Int|big-endian signed int layouts}
   * spanning two bytes. */


  Layout$1.s16be = function (property) {
    return new IntBE(2, property);
  };
  /** Factory for {@link Int|big-endian signed int layouts}
   * spanning three bytes. */


  Layout$1.s24be = function (property) {
    return new IntBE(3, property);
  };
  /** Factory for {@link Int|big-endian signed int layouts}
   * spanning four bytes. */


  Layout$1.s32be = function (property) {
    return new IntBE(4, property);
  };
  /** Factory for {@link Int|big-endian signed int layouts}
   * spanning five bytes. */


  Layout$1.s40be = function (property) {
    return new IntBE(5, property);
  };
  /** Factory for {@link Int|big-endian signed int layouts}
   * spanning six bytes. */


  Layout$1.s48be = function (property) {
    return new IntBE(6, property);
  };
  /** Factory for {@link NearInt64BE|big-endian signed int layouts}
   * interpreted as Numbers. */


  Layout$1.ns64be = function (property) {
    return new NearInt64BE(property);
  };
  /** Factory for {@link Float|little-endian 32-bit floating point} values. */


  Layout$1.f32 = function (property) {
    return new Float(property);
  };
  /** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */


  Layout$1.f32be = function (property) {
    return new FloatBE(property);
  };
  /** Factory for {@link Double|little-endian 64-bit floating point} values. */


  Layout$1.f64 = function (property) {
    return new Double(property);
  };
  /** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */


  Layout$1.f64be = function (property) {
    return new DoubleBE(property);
  };
  /** Factory for {@link Structure} values. */


  Layout$1.struct = function (fields, property, decodePrefixes) {
    return new Structure(fields, property, decodePrefixes);
  };
  /** Factory for {@link BitStructure} values. */


  Layout$1.bits = function (word, msb, property) {
    return new BitStructure(word, msb, property);
  };
  /** Factory for {@link Sequence} values. */


  Layout$1.seq = function (elementLayout, count, property) {
    return new Sequence(elementLayout, count, property);
  };
  /** Factory for {@link Union} values. */


  Layout$1.union = function (discr, defaultLayout, property) {
    return new Union(discr, defaultLayout, property);
  };
  /** Factory for {@link UnionLayoutDiscriminator} values. */


  Layout$1.unionLayoutDiscriminator = function (layout, property) {
    return new UnionLayoutDiscriminator(layout, property);
  };
  /** Factory for {@link Blob} values. */


  Layout$1.blob = function (length, property) {
    return new Blob(length, property);
  };
  /** Factory for {@link CString} values. */


  Layout$1.cstr = function (property) {
    return new CString(property);
  };
  /** Factory for {@link UTF8} values. */


  Layout$1.utf8 = function (maxSpan, property) {
    return new UTF8(maxSpan, property);
  };
  /** Factory for {@link Constant} values. */


  Layout$1["const"] = function (value, property) {
    return new Constant(value, property);
  };

  var lib = {};

  var require$$1 = /*@__PURE__*/getAugmentedNamespace(index_browser_esm);

  var bn = {exports: {}};

  (function (module) {
    (function (module, exports) {

      function assert(val, msg) {
        if (!val) throw new Error(msg || 'Assertion failed');
      } // Could use `inherits` module, but don't want to move from single file
      // architecture yet.


      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function TempCtor() {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      } // BN


      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }

        this.negative = 0;
        this.words = null;
        this.length = 0; // Reduction context

        this.red = null;

        if (number !== null) {
          if (base === 'le' || base === 'be') {
            endian = base;
            base = 10;
          }

          this._init(number || 0, base || 10, endian || 'be');
        }
      }

      if (_typeof$1(module) === 'object') {
        module.exports = BN;
      } else {
        exports.BN = BN;
      }

      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer;

      try {
        if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
          Buffer = window.Buffer;
        } else {
          Buffer = require$$0$1.Buffer;
        }
      } catch (e) {}

      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }

        return num !== null && _typeof$1(num) === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };

      BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };

      BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };

      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === 'number') {
          return this._initNumber(number, base, endian);
        }

        if (_typeof$1(number) === 'object') {
          return this._initArray(number, base, endian);
        }

        if (base === 'hex') {
          base = 16;
        }

        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, '');
        var start = 0;

        if (number[0] === '-') {
          start++;
          this.negative = 1;
        }

        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);

            if (endian === 'le') {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };

      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }

        if (number < 0x4000000) {
          this.words = [number & 0x3ffffff];
          this.length = 1;
        } else if (number < 0x10000000000000) {
          this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
          this.length = 2;
        } else {
          assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)

          this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
          this.length = 3;
        }

        if (endian !== 'le') return; // Reverse the bytes

        this._initArray(this.toArray(), base, endian);
      };

      BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === 'number');

        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }

        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }

        var j, w;
        var off = 0;

        if (endian === 'be') {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;

            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === 'le') {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 0x3ffffff;
            this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
            off += 24;

            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }

        return this._strip();
      };

      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index); // '0' - '9'

        if (c >= 48 && c <= 57) {
          return c - 48; // 'A' - 'F'
        } else if (c >= 65 && c <= 70) {
          return c - 55; // 'a' - 'f'
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          assert(false, 'Invalid character in ' + string);
        }
      }

      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);

        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }

        return r;
      }

      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        } // 24-bits chunks


        var off = 0;
        var j = 0;
        var w;

        if (endian === 'be') {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;

            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;

          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 0x3ffffff;

            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }

        this._strip();
      };

      function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);

        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul; // 'a'

          if (c >= 49) {
            b = c - 49 + 0xa; // 'A'
          } else if (c >= 17) {
            b = c - 17 + 0xa; // '0' - '9'
          } else {
            b = c;
          }

          assert(c >= 0 && b < mul, 'Invalid character');
          r += b;
        }

        return r;
      }

      BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [0];
        this.length = 1; // Find length of limb in base

        for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
          limbLen++;
        }

        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;

        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);

          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }

        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);

          for (i = 0; i < mod; i++) {
            pow *= base;
          }

          this.imuln(pow);

          if (this.words[0] + word < 0x4000000) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }

        this._strip();
      };

      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);

        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }

        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };

      function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
      }

      BN.prototype._move = function _move(dest) {
        move(dest, this);
      };

      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };

      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }

        return this;
      }; // Remove leading `0` from `this`


      BN.prototype._strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }

        return this._normSign();
      };

      BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }

        return this;
      }; // Check Symbol.for because not everywhere where Symbol defined
      // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility


      if (typeof Symbol !== 'undefined' && typeof Symbol["for"] === 'function') {
        try {
          BN.prototype[Symbol["for"]('nodejs.util.inspect.custom')] = inspect;
        } catch (e) {
          BN.prototype.inspect = inspect;
        }
      } else {
        BN.prototype.inspect = inspect;
      }

      function inspect() {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
      }
      /*
       var zeros = [];
      var groupSizes = [];
      var groupBases = [];
       var s = '';
      var i = -1;
      while (++i < BN.wordSize) {
        zeros[i] = s;
        s += '0';
      }
      groupSizes[0] = 0;
      groupSizes[1] = 0;
      groupBases[0] = 0;
      groupBases[1] = 0;
      var base = 2 - 1;
      while (++base < 36 + 1) {
        var groupSize = 0;
        var groupBase = 1;
        while (groupBase < (1 << BN.wordSize) / base) {
          groupBase *= base;
          groupSize += 1;
        }
        groupSizes[base] = groupSize;
        groupBases[base] = groupBase;
      }
       */


      var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
      var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
      var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;

        if (base === 16 || base === 'hex') {
          out = '';
          var off = 0;
          var carry = 0;

          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 0xffffff).toString(16);
            carry = w >>> 24 - off & 0xffffff;
            off += 2;

            if (off >= 26) {
              off -= 26;
              i--;
            }

            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }

          if (carry !== 0) {
            out = carry.toString(16) + out;
          }

          while (out.length % padding !== 0) {
            out = '0' + out;
          }

          if (this.negative !== 0) {
            out = '-' + out;
          }

          return out;
        }

        if (base === (base | 0) && base >= 2 && base <= 36) {
          // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
          var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

          var groupBase = groupBases[base];
          out = '';
          var c = this.clone();
          c.negative = 0;

          while (!c.isZero()) {
            var r = c.modrn(groupBase).toString(base);
            c = c.idivn(groupBase);

            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }

          if (this.isZero()) {
            out = '0' + out;
          }

          while (out.length % padding !== 0) {
            out = '0' + out;
          }

          if (this.negative !== 0) {
            out = '-' + out;
          }

          return out;
        }

        assert(false, 'Base should be between 2 and 36');
      };

      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];

        if (this.length === 2) {
          ret += this.words[1] * 0x4000000;
        } else if (this.length === 3 && this.words[2] === 0x01) {
          // NOTE: at this stage it is known that the top bit is set
          ret += 0x10000000000000 + this.words[1] * 0x4000000;
        } else if (this.length > 2) {
          assert(false, 'Number can only safely store up to 53 bits');
        }

        return this.negative !== 0 ? -ret : ret;
      };

      BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
      };

      if (Buffer) {
        BN.prototype.toBuffer = function toBuffer(endian, length) {
          return this.toArrayLike(Buffer, endian, length);
        };
      }

      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };

      var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
          return ArrayType.allocUnsafe(size);
        }

        return new ArrayType(size);
      };

      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();

        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, 'byte array longer than desired length');
        assert(reqLength > 0, 'Requested array length <= 0');
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === 'le' ? 'LE' : 'BE';
        this['_toArrayLike' + postfix](res, byteLength);
        return res;
      };

      BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;

        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position++] = word & 0xff;

          if (position < res.length) {
            res[position++] = word >> 8 & 0xff;
          }

          if (position < res.length) {
            res[position++] = word >> 16 & 0xff;
          }

          if (shift === 6) {
            if (position < res.length) {
              res[position++] = word >> 24 & 0xff;
            }

            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }

        if (position < res.length) {
          res[position++] = carry;

          while (position < res.length) {
            res[position++] = 0;
          }
        }
      };

      BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;

        for (var i = 0, shift = 0; i < this.length; i++) {
          var word = this.words[i] << shift | carry;
          res[position--] = word & 0xff;

          if (position >= 0) {
            res[position--] = word >> 8 & 0xff;
          }

          if (position >= 0) {
            res[position--] = word >> 16 & 0xff;
          }

          if (shift === 6) {
            if (position >= 0) {
              res[position--] = word >> 24 & 0xff;
            }

            carry = 0;
            shift = 0;
          } else {
            carry = word >>> 24;
            shift += 2;
          }
        }

        if (position >= 0) {
          res[position--] = carry;

          while (position >= 0) {
            res[position--] = 0;
          }
        }
      };

      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;

          if (t >= 0x1000) {
            r += 13;
            t >>>= 13;
          }

          if (t >= 0x40) {
            r += 7;
            t >>>= 7;
          }

          if (t >= 0x8) {
            r += 4;
            t >>>= 4;
          }

          if (t >= 0x02) {
            r += 2;
            t >>>= 2;
          }

          return r + t;
        };
      }

      BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;

        if ((t & 0x1fff) === 0) {
          r += 13;
          t >>>= 13;
        }

        if ((t & 0x7f) === 0) {
          r += 7;
          t >>>= 7;
        }

        if ((t & 0xf) === 0) {
          r += 4;
          t >>>= 4;
        }

        if ((t & 0x3) === 0) {
          r += 2;
          t >>>= 2;
        }

        if ((t & 0x1) === 0) {
          r++;
        }

        return r;
      }; // Return number of used bits in a BN


      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];

        var hi = this._countBits(w);

        return (this.length - 1) * 26 + hi;
      };

      function toBitArray(num) {
        var w = new Array(num.bitLength());

        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = num.words[off] >>> wbit & 0x01;
        }

        return w;
      } // Number of trailing zero bits


      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;

        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);

          r += b;
          if (b !== 26) break;
        }

        return r;
      };

      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };

      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }

        return this.clone();
      };

      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }

        return this.clone();
      };

      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      }; // Return negative clone of `this`


      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };

      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }

        return this;
      }; // Or `num` with `this` in-place


      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }

        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }

        return this._strip();
      };

      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      }; // Or `num` with `this`


      BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };

      BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      }; // And `num` with `this` in-place


      BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;

        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }

        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }

        this.length = b.length;
        return this._strip();
      };

      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      }; // And `num` with `this`


      BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };

      BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      }; // Xor `num` with `this` in-place


      BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;

        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }

        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        this.length = a.length;
        return this._strip();
      };

      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      }; // Xor `num` with `this`


      BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };

      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      }; // Not ``this`` with ``width`` bitwidth


      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === 'number' && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26; // Extend the buffer with leading zeroes

        this._expand(bytesNeeded);

        if (bitsLeft > 0) {
          bytesNeeded--;
        } // Handle complete words


        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 0x3ffffff;
        } // Handle the residue


        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        } // And remove leading zeroes


        return this._strip();
      };

      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      }; // Set `bit` of `this`


      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === 'number' && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;

        this._expand(off + 1);

        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }

        return this._strip();
      }; // Add `num` to `this` in-place


      BN.prototype.iadd = function iadd(num) {
        var r; // negative + positive

        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign(); // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        } // a.length > b.length


        var a, b;

        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        var carry = 0;

        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }

        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 0x3ffffff;
          carry = r >>> 26;
        }

        this.length = a.length;

        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++; // Copy the rest of the words
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        return this;
      }; // Add `num` to `this`


      BN.prototype.add = function add(num) {
        var res;

        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }

        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      }; // Subtract `num` from `this` in-place


      BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign(); // -this - num = -(this + num)
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        } // At this point both numbers are positive


        var cmp = this.cmp(num); // Optimization - zeroify

        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        } // a > b


        var a, b;

        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }

        var carry = 0;

        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        }

        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 0x3ffffff;
        } // Copy rest of the words


        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }

        this.length = Math.max(this.length, i);

        if (a !== this) {
          this.negative = 1;
        }

        return this._strip();
      }; // Subtract `num` from `this`


      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };

      function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;

        for (var k = 1; k < len; k++) {
          // Sum all words with the same `i + j = k` and accumulate `ncarry`,
          // note that ncarry could be >= 0x3ffffff
          var ncarry = carry >>> 26;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);

          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 0x4000000 | 0;
            rword = r & 0x3ffffff;
          }

          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }

        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }

        return out._strip();
      } // TODO(indutny): it may be reasonable to omit it for users who don't need
      // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
      // multiplication (like elliptic secp256k1).


      var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */

        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */

        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */

        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */

        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */

        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */

        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */

        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */

        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */

        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */

        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */

        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */

        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */

        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */

        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */

        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */

        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */

        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */

        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */

        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;

        if (c !== 0) {
          o[19] = c;
          out.length++;
        }

        return out;
      }; // Polyfill comb


      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }

      function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;

        for (var k = 0; k < out.length - 1; k++) {
          // Sum all words with the same `i + j = k` and accumulate `ncarry`,
          // note that ncarry could be >= 0x3ffffff
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 0x3ffffff;
          var maxJ = Math.min(k, num.length - 1);

          for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 0x3ffffff;
            ncarry = ncarry + (r / 0x4000000 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 0x3ffffff;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 0x3ffffff;
          }

          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }

        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }

        return out._strip();
      }

      function jumboMulTo(self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
      }

      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;

        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }

        return res;
      }; // Cooley-Tukey algorithm for FFT


      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      }; // Multiply employing FFT


      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      }; // In-place Multiplication


      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };

      BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === 'number');
        assert(num < 0x4000000); // Carry

        var carry = 0;

        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
          carry >>= 26;
          carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum

          carry += lo >>> 26;
          this.words[i] = lo & 0x3ffffff;
        }

        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }

        return isNegNum ? this.ineg() : this;
      };

      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      }; // `this` * `this`


      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      }; // `this` * `this` in-place


      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      }; // Math.pow(`this`, `num`)


      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1); // Skip leading zeroes

        var res = this;

        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0) break;
        }

        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0) continue;
            res = res.mul(q);
          }
        }

        return res;
      }; // Shift-left in-place


      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;

        if (r !== 0) {
          var carry = 0;

          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }

          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }

        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }

          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }

          this.length += s;
        }

        return this._strip();
      };

      BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
      }; // Shift-right in-place
      // NOTE: `hint` is a lowest bit before trailing zeroes
      // NOTE: if `extended` is present - it will be filled with destroyed bits


      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        var h;

        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }

        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h); // Extended mode, copy masked part

        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }

          maskedWords.length = s;
        }

        if (s === 0) ; else if (this.length > s) {
          this.length -= s;

          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }

        var carry = 0;

        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        } // Push carried bits as a mask


        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }

        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }

        return this._strip();
      };

      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      }; // Shift-left


      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };

      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      }; // Shift-right


      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };

      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      }; // Test if n bit is set


      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r; // Fast case: bit is much higher than all existing words

        if (this.length <= s) return false; // Check bit and return

        var w = this.words[s];
        return !!(w & q);
      }; // Return only lowers bits of number (in-place)


      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, 'imaskn works only with positive numbers');

        if (this.length <= s) {
          return this;
        }

        if (r !== 0) {
          s++;
        }

        this.length = Math.min(s, this.length);

        if (r !== 0) {
          var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
          this.words[this.length - 1] &= mask;
        }

        return this._strip();
      }; // Return only lowers bits of number


      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      }; // Add plain number `num` to `this`


      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num); // Possible sign change

        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) <= num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }

          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        } // Add without checks


        return this._iaddn(num);
      };

      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num; // Carry

        for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
          this.words[i] -= 0x4000000;

          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }

        this.length = Math.max(this.length, i + 1);
        return this;
      }; // Subtract plain number `num` from `this`


      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);

        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }

        this.words[0] -= num;

        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          // Carry
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 0x4000000;
            this.words[i + 1] -= 1;
          }
        }

        return this._strip();
      };

      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };

      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };

      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };

      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };

      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;

        this._expand(len);

        var w;
        var carry = 0;

        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 0x3ffffff;
          carry = (w >> 26) - (right / 0x4000000 | 0);
          this.words[i + shift] = w & 0x3ffffff;
        }

        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 0x3ffffff;
        }

        if (carry === 0) return this._strip(); // Subtraction overflow

        assert(carry === -1);
        carry = 0;

        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 0x3ffffff;
        }

        this.negative = 1;
        return this._strip();
      };

      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num; // Normalize

        var bhi = b.words[b.length - 1] | 0;

        var bhiBits = this._countBits(bhi);

        shift = 26 - bhiBits;

        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        } // Initialize quotient


        var m = a.length - b.length;
        var q;

        if (mode !== 'mod') {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);

          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }

        var diff = a.clone()._ishlnsubmul(b, 1, m);

        if (diff.negative === 0) {
          a = diff;

          if (q) {
            q.words[m] = 1;
          }
        }

        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
          // (0x7ffffff)

          qj = Math.min(qj / bhi | 0, 0x3ffffff);

          a._ishlnsubmul(b, qj, j);

          while (a.negative !== 0) {
            qj--;
            a.negative = 0;

            a._ishlnsubmul(b, 1, j);

            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }

          if (q) {
            q.words[j] = qj;
          }
        }

        if (q) {
          q._strip();
        }

        a._strip(); // Denormalize


        if (mode !== 'div' && shift !== 0) {
          a.iushrn(shift);
        }

        return {
          div: q || null,
          mod: a
        };
      }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
      //       to `div` to request div only, or be absent to
      //       request both div & mod
      //       2) `positive` is true if unsigned mod is requested


      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());

        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }

        var div, mod, res;

        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);

          if (mode !== 'mod') {
            div = res.div.neg();
          }

          if (mode !== 'div') {
            mod = res.mod.neg();

            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }

          return {
            div: div,
            mod: mod
          };
        }

        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);

          if (mode !== 'mod') {
            div = res.div.neg();
          }

          return {
            div: div,
            mod: res.mod
          };
        }

        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);

          if (mode !== 'div') {
            mod = res.mod.neg();

            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }

          return {
            div: res.div,
            mod: mod
          };
        } // Both numbers are positive at this point
        // Strip both numbers to approximate shift value


        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        } // Very short reduction


        if (num.length === 1) {
          if (mode === 'div') {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }

          if (mode === 'mod') {
            return {
              div: null,
              mod: new BN(this.modrn(num.words[0]))
            };
          }

          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modrn(num.words[0]))
          };
        }

        return this._wordDiv(num, mode);
      }; // Find `this` / `num`


      BN.prototype.div = function div(num) {
        return this.divmod(num, 'div', false).div;
      }; // Find `this` % `num`


      BN.prototype.mod = function mod(num) {
        return this.divmod(num, 'mod', false).mod;
      };

      BN.prototype.umod = function umod(num) {
        return this.divmod(num, 'mod', true).mod;
      }; // Find Round(`this` / `num`)


      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num); // Fast case - exact division

        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half); // Round down

        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };

      BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var p = (1 << 26) % num;
        var acc = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }

        return isNegNum ? -acc : acc;
      }; // WARNING: DEPRECATED


      BN.prototype.modn = function modn(num) {
        return this.modrn(num);
      }; // In-place division by number


      BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var carry = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 0x4000000;
          this.words[i] = w / num | 0;
          carry = w % num;
        }

        this._strip();

        return isNegNum ? this.ineg() : this;
      };

      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };

      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();

        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        } // A * x + B * y = x


        var A = new BN(1);
        var B = new BN(0); // C * x + D * y = y

        var C = new BN(0);
        var D = new BN(1);
        var g = 0;

        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }

        var yp = y.clone();
        var xp = x.clone();

        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

          if (i > 0) {
            x.iushrn(i);

            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }

              A.iushrn(1);
              B.iushrn(1);
            }
          }

          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

          if (j > 0) {
            y.iushrn(j);

            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }

              C.iushrn(1);
              D.iushrn(1);
            }
          }

          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }

        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      }; // This is reduced incarnation of the binary EEA
      // above, designated to invert members of the
      // _prime_ fields F(p) at a maximal speed


      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();

        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }

        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();

        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

          if (i > 0) {
            a.iushrn(i);

            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }

              x1.iushrn(1);
            }
          }

          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

          if (j > 0) {
            b.iushrn(j);

            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }

              x2.iushrn(1);
            }
          }

          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }

        var res;

        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }

        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }

        return res;
      };

      BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0; // Remove common factor of two

        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }

        do {
          while (a.isEven()) {
            a.iushrn(1);
          }

          while (b.isEven()) {
            b.iushrn(1);
          }

          var r = a.cmp(b);

          if (r < 0) {
            // Swap `a` and `b` to make `a` always bigger than `b`
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }

          a.isub(b);
        } while (true);

        return b.iushln(shift);
      }; // Invert number in the field F(num)


      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };

      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };

      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      }; // And first word and num


      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      }; // Increment at the bit position in-line


      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r; // Fast case: bit is much higher than all existing words

        if (this.length <= s) {
          this._expand(s + 1);

          this.words[s] |= q;
          return this;
        } // Add bit and propagate, if needed


        var carry = q;

        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 0x3ffffff;
          this.words[i] = w;
        }

        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }

        return this;
      };

      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };

      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;

        this._strip();

        var res;

        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }

          assert(num <= 0x3ffffff, 'Number is too big');
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }

        if (this.negative !== 0) return -res | 0;
        return res;
      }; // Compare two numbers and return:
      // 1 - if `this` > `num`
      // 0 - if `this` == `num`
      // -1 - if `this` < `num`


      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      }; // Unsigned comparison


      BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;

        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b) continue;

          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }

          break;
        }

        return res;
      };

      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };

      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };

      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };

      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };

      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };

      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };

      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };

      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };

      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };

      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      }; //
      // A reduce context, could be using montgomery or something better, depending
      // on the `m` itself.
      //


      BN.red = function red(num) {
        return new Red(num);
      };

      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(this.negative === 0, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
      };

      BN.prototype.fromRed = function fromRed() {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
      };

      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };

      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
      };

      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
      };

      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
      };

      BN.prototype.redSub = function redSub(num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
      };

      BN.prototype.redISub = function redISub(num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
      };

      BN.prototype.redShl = function redShl(num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
      };

      BN.prototype.redMul = function redMul(num) {
        assert(this.red, 'redMul works only with red numbers');

        this.red._verify2(this, num);

        return this.red.mul(this, num);
      };

      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, 'redMul works only with red numbers');

        this.red._verify2(this, num);

        return this.red.imul(this, num);
      };

      BN.prototype.redSqr = function redSqr() {
        assert(this.red, 'redSqr works only with red numbers');

        this.red._verify1(this);

        return this.red.sqr(this);
      };

      BN.prototype.redISqr = function redISqr() {
        assert(this.red, 'redISqr works only with red numbers');

        this.red._verify1(this);

        return this.red.isqr(this);
      }; // Square root over p


      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, 'redSqrt works only with red numbers');

        this.red._verify1(this);

        return this.red.sqrt(this);
      };

      BN.prototype.redInvm = function redInvm() {
        assert(this.red, 'redInvm works only with red numbers');

        this.red._verify1(this);

        return this.red.invm(this);
      }; // Return negative clone of `this` % `red modulo`


      BN.prototype.redNeg = function redNeg() {
        assert(this.red, 'redNeg works only with red numbers');

        this.red._verify1(this);

        return this.red.neg(this);
      };

      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, 'redPow(normalNum)');

        this.red._verify1(this);

        return this.red.pow(this, num);
      }; // Prime numbers with efficient reduction


      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      }; // Pseudo-Mersenne prime

      function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }

      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };

      MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;

        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);

        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);

        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== undefined) {
            // r is a BN v4 instance
            r.strip();
          } else {
            // r is a BN v5 instance
            r._strip();
          }
        }

        return r;
      };

      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };

      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };

      function K256() {
        MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
      }

      inherits(K256, MPrime);

      K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);

        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }

        output.length = outLen;

        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        } // Shift by 9 limbs


        var prev = input.words[9];
        output.words[output.length++] = prev & mask;

        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }

        prev >>>= 22;
        input.words[i - 10] = prev;

        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };

      K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

        var lo = 0;

        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 0x3d1;
          num.words[i] = lo & 0x3ffffff;
          lo = w * 0x40 + (lo / 0x4000000 | 0);
        } // Fast length reduction


        if (num.words[num.length - 1] === 0) {
          num.length--;

          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }

        return num;
      };

      function P224() {
        MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
      }

      inherits(P224, MPrime);

      function P192() {
        MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
      }

      inherits(P192, MPrime);

      function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
      }

      inherits(P25519, MPrime);

      P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;

        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 0x13 + carry;
          var lo = hi & 0x3ffffff;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }

        if (carry !== 0) {
          num.words[num.length++] = carry;
        }

        return num;
      }; // Exported mostly for testing purposes, use plain name instead


      BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;

        if (name === 'k256') {
          prime = new K256();
        } else if (name === 'p224') {
          prime = new P224();
        } else if (name === 'p192') {
          prime = new P192();
        } else if (name === 'p25519') {
          prime = new P25519();
        } else {
          throw new Error('Unknown prime ' + name);
        }

        primes[name] = prime;
        return prime;
      }; //
      // Base reduction engine
      //


      function Red(m) {
        if (typeof m === 'string') {
          var prime = BN._prime(m);

          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), 'modulus must be greater than 1');
          this.m = m;
          this.prime = null;
        }
      }

      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
      };

      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, 'red works only with positives');
        assert(a.red && a.red === b.red, 'red works only with red numbers');
      };

      Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
      };

      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }

        return this.m.sub(a)._forceRed(this);
      };

      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);

        var res = a.add(b);

        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }

        return res._forceRed(this);
      };

      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);

        var res = a.iadd(b);

        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }

        return res;
      };

      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);

        var res = a.sub(b);

        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);

        var res = a.isub(b);

        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }

        return res;
      };

      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);

        return this.imod(a.ushln(num));
      };

      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);

        return this.imod(a.imul(b));
      };

      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);

        return this.imod(a.mul(b));
      };

      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };

      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };

      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1); // Fast case

        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)


        var q = this.m.subn(1);
        var s = 0;

        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }

        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg(); // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.

        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);

        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }

        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;

        while (t.cmp(one) !== 0) {
          var tmp = t;

          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }

          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }

        return r;
      };

      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);

        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };

      Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;

        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }

        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;

        if (start === 0) {
          start = 26;
        }

        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];

          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;

            if (res !== wnd[0]) {
              res = this.sqr(res);
            }

            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }

            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }

          start = 26;
        }

        return res;
      };

      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };

      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      }; //
      // Montgomery method engine
      //


      BN.mont = function mont(num) {
        return new Mont(num);
      };

      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();

        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }

        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }

      inherits(Mont, Red);

      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };

      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };

      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }

        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;

        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;

        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }

        return res._forceRed(this);
      };

      Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(module, commonjsGlobal);
  })(bn);

  (function (exports) {

    var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
      return mod && mod.__esModule ? mod : {
        "default": mod
      };
    };

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.map = exports.array = exports.rustEnum = exports.str = exports.vecU8 = exports.tagged = exports.vec = exports.bool = exports.option = exports.publicKey = exports.i128 = exports.u128 = exports.i64 = exports.u64 = exports.struct = exports.f64 = exports.f32 = exports.i32 = exports.u32 = exports.i16 = exports.u16 = exports.i8 = exports.u8 = void 0;
    var buffer_layout_1 = Layout$1;
    var web3_js_1 = require$$1;

    var bn_js_1 = __importDefault(bn.exports);

    var buffer_layout_2 = Layout$1;
    Object.defineProperty(exports, "u8", {
      enumerable: true,
      get: function get() {
        return buffer_layout_2.u8;
      }
    });
    Object.defineProperty(exports, "i8", {
      enumerable: true,
      get: function get() {
        return buffer_layout_2.s8;
      }
    });
    Object.defineProperty(exports, "u16", {
      enumerable: true,
      get: function get() {
        return buffer_layout_2.u16;
      }
    });
    Object.defineProperty(exports, "i16", {
      enumerable: true,
      get: function get() {
        return buffer_layout_2.s16;
      }
    });
    Object.defineProperty(exports, "u32", {
      enumerable: true,
      get: function get() {
        return buffer_layout_2.u32;
      }
    });
    Object.defineProperty(exports, "i32", {
      enumerable: true,
      get: function get() {
        return buffer_layout_2.s32;
      }
    });
    Object.defineProperty(exports, "f32", {
      enumerable: true,
      get: function get() {
        return buffer_layout_2.f32;
      }
    });
    Object.defineProperty(exports, "f64", {
      enumerable: true,
      get: function get() {
        return buffer_layout_2.f64;
      }
    });
    Object.defineProperty(exports, "struct", {
      enumerable: true,
      get: function get() {
        return buffer_layout_2.struct;
      }
    });

    var BNLayout = /*#__PURE__*/function (_buffer_layout_1$Layo) {
      _inherits(BNLayout, _buffer_layout_1$Layo);

      var _super = _createSuper(BNLayout);

      function BNLayout(span, signed, property) {
        var _this;

        _classCallCheck(this, BNLayout);

        _this = _super.call(this, span, property);
        _this.blob = buffer_layout_1.blob(span);
        _this.signed = signed;
        return _this;
      }

      _createClass(BNLayout, [{
        key: "decode",
        value: function decode(b) {
          var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var num = new bn_js_1["default"](this.blob.decode(b, offset), 10, 'le');

          if (this.signed) {
            return num.fromTwos(this.span * 8).clone();
          }

          return num;
        }
      }, {
        key: "encode",
        value: function encode(src, b) {
          var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

          if (this.signed) {
            src = src.toTwos(this.span * 8);
          }

          return this.blob.encode(src.toArrayLike(Buffer$1, 'le', this.span), b, offset);
        }
      }]);

      return BNLayout;
    }(buffer_layout_1.Layout);

    function u64(property) {
      return new BNLayout(8, false, property);
    }

    exports.u64 = u64;

    function i64(property) {
      return new BNLayout(8, true, property);
    }

    exports.i64 = i64;

    function u128(property) {
      return new BNLayout(16, false, property);
    }

    exports.u128 = u128;

    function i128(property) {
      return new BNLayout(16, true, property);
    }

    exports.i128 = i128;

    var WrappedLayout = /*#__PURE__*/function (_buffer_layout_1$Layo2) {
      _inherits(WrappedLayout, _buffer_layout_1$Layo2);

      var _super2 = _createSuper(WrappedLayout);

      function WrappedLayout(layout, decoder, encoder, property) {
        var _this2;

        _classCallCheck(this, WrappedLayout);

        _this2 = _super2.call(this, layout.span, property);
        _this2.layout = layout;
        _this2.decoder = decoder;
        _this2.encoder = encoder;
        return _this2;
      }

      _createClass(WrappedLayout, [{
        key: "decode",
        value: function decode(b, offset) {
          return this.decoder(this.layout.decode(b, offset));
        }
      }, {
        key: "encode",
        value: function encode(src, b, offset) {
          return this.layout.encode(this.encoder(src), b, offset);
        }
      }, {
        key: "getSpan",
        value: function getSpan(b, offset) {
          return this.layout.getSpan(b, offset);
        }
      }]);

      return WrappedLayout;
    }(buffer_layout_1.Layout);

    function publicKey(property) {
      return new WrappedLayout(buffer_layout_1.blob(32), function (b) {
        return new web3_js_1.PublicKey(b);
      }, function (key) {
        return key.toBuffer();
      }, property);
    }

    exports.publicKey = publicKey;

    var OptionLayout = /*#__PURE__*/function (_buffer_layout_1$Layo3) {
      _inherits(OptionLayout, _buffer_layout_1$Layo3);

      var _super3 = _createSuper(OptionLayout);

      function OptionLayout(layout, property) {
        var _this3;

        _classCallCheck(this, OptionLayout);

        _this3 = _super3.call(this, -1, property);
        _this3.layout = layout;
        _this3.discriminator = buffer_layout_1.u8();
        return _this3;
      }

      _createClass(OptionLayout, [{
        key: "encode",
        value: function encode(src, b) {
          var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

          if (src === null || src === undefined) {
            return this.discriminator.encode(0, b, offset);
          }

          this.discriminator.encode(1, b, offset);
          return this.layout.encode(src, b, offset + 1) + 1;
        }
      }, {
        key: "decode",
        value: function decode(b) {
          var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var discriminator = this.discriminator.decode(b, offset);

          if (discriminator === 0) {
            return null;
          } else if (discriminator === 1) {
            return this.layout.decode(b, offset + 1);
          }

          throw new Error('Invalid option ' + this.property);
        }
      }, {
        key: "getSpan",
        value: function getSpan(b) {
          var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var discriminator = this.discriminator.decode(b, offset);

          if (discriminator === 0) {
            return 1;
          } else if (discriminator === 1) {
            return this.layout.getSpan(b, offset + 1) + 1;
          }

          throw new Error('Invalid option ' + this.property);
        }
      }]);

      return OptionLayout;
    }(buffer_layout_1.Layout);

    function option(layout, property) {
      return new OptionLayout(layout, property);
    }

    exports.option = option;

    function bool(property) {
      return new WrappedLayout(buffer_layout_1.u8(), decodeBool, encodeBool, property);
    }

    exports.bool = bool;

    function decodeBool(value) {
      if (value === 0) {
        return false;
      } else if (value === 1) {
        return true;
      }

      throw new Error('Invalid bool: ' + value);
    }

    function encodeBool(value) {
      return value ? 1 : 0;
    }

    function vec(elementLayout, property) {
      var length = buffer_layout_1.u32('length');
      var layout = buffer_layout_1.struct([length, buffer_layout_1.seq(elementLayout, buffer_layout_1.offset(length, -length.span), 'values')]);
      return new WrappedLayout(layout, function (_ref) {
        var values = _ref.values;
        return values;
      }, function (values) {
        return {
          values: values
        };
      }, property);
    }

    exports.vec = vec;

    function tagged(tag, layout, property) {
      var wrappedLayout = buffer_layout_1.struct([u64('tag'), layout.replicate('data')]);

      function decodeTag(_ref2) {
        var receivedTag = _ref2.tag,
            data = _ref2.data;

        if (!receivedTag.eq(tag)) {
          throw new Error('Invalid tag, expected: ' + tag.toString('hex') + ', got: ' + receivedTag.toString('hex'));
        }

        return data;
      }

      return new WrappedLayout(wrappedLayout, decodeTag, function (data) {
        return {
          tag: tag,
          data: data
        };
      }, property);
    }

    exports.tagged = tagged;

    function vecU8(property) {
      var length = buffer_layout_1.u32('length');
      var layout = buffer_layout_1.struct([length, buffer_layout_1.blob(buffer_layout_1.offset(length, -length.span), 'data')]);
      return new WrappedLayout(layout, function (_ref3) {
        var data = _ref3.data;
        return data;
      }, function (data) {
        return {
          data: data
        };
      }, property);
    }

    exports.vecU8 = vecU8;

    function str(property) {
      return new WrappedLayout(vecU8(), function (data) {
        return data.toString('utf-8');
      }, function (s) {
        return Buffer$1.from(s, 'utf-8');
      }, property);
    }

    exports.str = str;

    function rustEnum(variants, property, discriminant) {
      var unionLayout = buffer_layout_1.union(discriminant !== null && discriminant !== void 0 ? discriminant : buffer_layout_1.u8(), property);
      variants.forEach(function (variant, index) {
        return unionLayout.addVariant(index, variant, variant.property);
      });
      return unionLayout;
    }

    exports.rustEnum = rustEnum;

    function array(elementLayout, length, property) {
      var layout = buffer_layout_1.struct([buffer_layout_1.seq(elementLayout, length, 'values')]);
      return new WrappedLayout(layout, function (_ref4) {
        var values = _ref4.values;
        return values;
      }, function (values) {
        return {
          values: values
        };
      }, property);
    }

    exports.array = array;

    var MapEntryLayout = /*#__PURE__*/function (_buffer_layout_1$Layo4) {
      _inherits(MapEntryLayout, _buffer_layout_1$Layo4);

      var _super4 = _createSuper(MapEntryLayout);

      function MapEntryLayout(keyLayout, valueLayout, property) {
        var _this4;

        _classCallCheck(this, MapEntryLayout);

        _this4 = _super4.call(this, keyLayout.span + valueLayout.span, property);
        _this4.keyLayout = keyLayout;
        _this4.valueLayout = valueLayout;
        return _this4;
      }

      _createClass(MapEntryLayout, [{
        key: "decode",
        value: function decode(b, offset) {
          offset = offset || 0;
          var key = this.keyLayout.decode(b, offset);
          var value = this.valueLayout.decode(b, offset + this.keyLayout.getSpan(b, offset));
          return [key, value];
        }
      }, {
        key: "encode",
        value: function encode(src, b, offset) {
          offset = offset || 0;
          var keyBytes = this.keyLayout.encode(src[0], b, offset);
          var valueBytes = this.valueLayout.encode(src[1], b, offset + keyBytes);
          return keyBytes + valueBytes;
        }
      }, {
        key: "getSpan",
        value: function getSpan(b, offset) {
          return this.keyLayout.getSpan(b, offset) + this.valueLayout.getSpan(b, offset);
        }
      }]);

      return MapEntryLayout;
    }(buffer_layout_1.Layout);

    function map(keyLayout, valueLayout, property) {
      var length = buffer_layout_1.u32('length');
      var layout = buffer_layout_1.struct([length, buffer_layout_1.seq(new MapEntryLayout(keyLayout, valueLayout), buffer_layout_1.offset(length, -length.span), 'values')]);
      return new WrappedLayout(layout, function (_ref5) {
        var values = _ref5.values;
        return new Map(values);
      }, function (values) {
        return {
          values: Array.from(values.entries())
        };
      }, property);
    }

    exports.map = map;
  })(lib);

  require$$0$1.Buffer;
  bn$1.exports;
  var ACCOUNT_LAYOUT = lib.struct([lib.publicKey('mint'), lib.publicKey('owner'), lib.u64('amount'), lib.u32('delegateOption'), lib.publicKey('delegate'), lib.u8('state'), lib.u32('isNativeOption'), lib.u64('isNative'), lib.u64('delegatedAmount'), lib.u32('closeAuthorityOption'), lib.publicKey('closeAuthority')]);

  lib.array;
  lib.bool;
  lib.i128;
  lib.i16;
  lib.i32;
  lib.i64;
  lib.i8;
  lib.map;
  lib.option;
  lib.publicKey;
  lib.rustEnum;
  lib.str;
  lib.struct;
  lib.tagged;
  lib.u128;
  lib.u16;
  lib.u32;
  lib.u64;
  lib.u8;
  lib.vec;
  lib.vecU8;

  let _window;

  let getWindow = () => {
    if(_window) { return _window }
    if (typeof global == 'object') {
      _window = global;
    } else {
      _window = window;
    }
    return _window
  };

  const getConfiguration = () =>{
    if(getWindow()._Web3ClientConfiguration === undefined) {
      getWindow()._Web3ClientConfiguration = {};
    }
    return getWindow()._Web3ClientConfiguration
  };

  const BATCH_INTERVAL$1 = 10;
  const CHUNK_SIZE$1 = 99;

  class StaticJsonRpcBatchProvider extends ethers.ethers.providers.JsonRpcProvider {

    constructor(url, network, endpoints, failover) {
      super(url);
      this._network = network;
      this._endpoint = url;
      this._endpoints = endpoints;
      this._failover = failover;
      this._pendingBatch = [];
    }

    detectNetwork() {
      return Promise.resolve(Blockchains__default['default'].findByName(this._network).id)
    }

    requestChunk(chunk, endpoint) {
      
      const request = chunk.map((inflight) => inflight.request);

      return ethers.ethers.utils.fetchJson(endpoint, JSON.stringify(request))
        .then((result) => {
          // For each result, feed it to the correct Promise, depending
          // on whether it was a success or error
          chunk.forEach((inflightRequest, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest.reject(error);
            }
            else {
              inflightRequest.resolve(payload.result);
            }
          });
        }).catch((error) => {
          if(error && error.code == 'SERVER_ERROR') {
            const index = this._endpoints.indexOf(this._endpoint)+1;
            this._failover();
            this._endpoint = index >= this._endpoints.length ? this._endpoints[0] : this._endpoints[index];
            this.requestChunk(chunk, this._endpoint);
          } else {
            chunk.forEach((inflightRequest) => {
              inflightRequest.reject(error);
            });
          }
        })
    }
      
    send(method, params) {

      const request = {
        method: method,
        params: params,
        id: (this._nextId++),
        jsonrpc: "2.0"
      };

      if (this._pendingBatch == null) {
        this._pendingBatch = [];
      }

      const inflightRequest = { request, resolve: null, reject: null };

      const promise = new Promise((resolve, reject) => {
        inflightRequest.resolve = resolve;
        inflightRequest.reject = reject;
      });

      this._pendingBatch.push(inflightRequest);

      if (!this._pendingBatchAggregator) {
        // Schedule batch for next event loop + short duration
        this._pendingBatchAggregator = setTimeout(() => {
          // Get the current batch and clear it, so new requests
          // go into the next batch
          const batch = this._pendingBatch;
          this._pendingBatch = [];
          this._pendingBatchAggregator = null;
          // Prepare Chunks of CHUNK_SIZE
          const chunks = [];
          for (let i = 0; i < Math.ceil(batch.length / CHUNK_SIZE$1); i++) {
            chunks[i] = batch.slice(i*CHUNK_SIZE$1, (i+1)*CHUNK_SIZE$1);
          }
          chunks.forEach((chunk)=>{
            // Get the request as an array of requests
            chunk.map((inflight) => inflight.request);
            return this.requestChunk(chunk, this._endpoint)
          });
        }, getConfiguration().batchInterval || BATCH_INTERVAL$1);
      }

      return promise
    }

  }

  const getAllProviders$1 = ()=> {
    if(getWindow()._Web3ClientProviders == undefined) {
      getWindow()._Web3ClientProviders = {};
    }
    return getWindow()._Web3ClientProviders
  };

  const setProvider$2 = (blockchain, provider)=> {
    if(getAllProviders$1()[blockchain] === undefined) { getAllProviders$1()[blockchain] = []; }
    const index = getAllProviders$1()[blockchain].indexOf(provider);
    if(index > -1) {
      getAllProviders$1()[blockchain].splice(index, 1);
    }
    getAllProviders$1()[blockchain].unshift(provider);
  };

  const setProviderEndpoints$2 = async (blockchain, endpoints, detectFastest = true)=> {
    
    getAllProviders$1()[blockchain] = endpoints.map((endpoint, index)=>
      new StaticJsonRpcBatchProvider(endpoint, blockchain, endpoints, ()=>{
        if(getAllProviders$1()[blockchain].length === 1) {
          setProviderEndpoints$2(blockchain, endpoints, detectFastest);
        } else {
          getAllProviders$1()[blockchain].splice(index, 1);
        }
      })
    );
    
    let provider;
    let window = getWindow();

    if(
      window.fetch == undefined ||
      (typeof process != 'undefined' && process['env'] && process['env']['NODE_ENV'] == 'test') ||
      (typeof window.cy != 'undefined') ||
      detectFastest === false
    ) {
      provider = getAllProviders$1()[blockchain][0];
    } else {
      
      let responseTimes = await Promise.all(endpoints.map((endpoint)=>{
        return new Promise(async (resolve)=>{
          let timeout = 900;
          let before = new Date().getTime();
          setTimeout(()=>resolve(timeout), timeout);
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ method: 'net_version', id: 1, jsonrpc: '2.0' })
          });
          if(!response.ok) { return resolve(999) }
          let after = new Date().getTime();
          resolve(after-before);
        })
      }));

      const fastestResponse = Math.min(...responseTimes);
      const fastestIndex = responseTimes.indexOf(fastestResponse);
      provider = getAllProviders$1()[blockchain][fastestIndex];
    }
    
    setProvider$2(blockchain, provider);
  };

  const getProvider$2 = async (blockchain)=> {

    let providers = getAllProviders$1();
    if(providers && providers[blockchain]){ return providers[blockchain][0] }
    
    let window = getWindow();
    if(window._Web3ClientGetProviderPromise && window._Web3ClientGetProviderPromise[blockchain]) { return await window._Web3ClientGetProviderPromise[blockchain] }

    if(!window._Web3ClientGetProviderPromise){ window._Web3ClientGetProviderPromise = {}; }
    window._Web3ClientGetProviderPromise[blockchain] = new Promise(async(resolve)=> {
      await setProviderEndpoints$2(blockchain, Blockchains__default['default'][blockchain].endpoints);
      resolve(getWindow()._Web3ClientProviders[blockchain][0]);
    });

    return await window._Web3ClientGetProviderPromise[blockchain]
  };

  const getProviders$2 = async(blockchain)=>{

    let providers = getAllProviders$1();
    if(providers && providers[blockchain]){ return providers[blockchain] }
    
    let window = getWindow();
    if(window._Web3ClientGetProvidersPromise && window._Web3ClientGetProvidersPromise[blockchain]) { return await window._Web3ClientGetProvidersPromise[blockchain] }

    if(!window._Web3ClientGetProvidersPromise){ window._Web3ClientGetProvidersPromise = {}; }
    window._Web3ClientGetProvidersPromise[blockchain] = new Promise(async(resolve)=> {
      await setProviderEndpoints$2(blockchain, Blockchains__default['default'][blockchain].endpoints);
      resolve(getWindow()._Web3ClientProviders[blockchain]);
    });

    return await window._Web3ClientGetProvidersPromise[blockchain]
  };

  var EVM = {
    getProvider: getProvider$2,
    getProviders: getProviders$2,
    setProviderEndpoints: setProviderEndpoints$2,
    setProvider: setProvider$2,
  };

  const BATCH_INTERVAL = 10;
  const CHUNK_SIZE = 99;

  class StaticJsonRpcSequentialProvider extends Connection {

    constructor(url, network, endpoints, failover) {
      super(url);
      this._provider = new Connection(url);
      this._network = network;
      this._endpoint = url;
      this._endpoints = endpoints;
      this._failover = failover;
      this._pendingBatch = [];
      this._rpcRequest = this._rpcRequestReplacement.bind(this);
    }

    requestChunk(chunk) {

      const batch = chunk.map((inflight) => inflight.request);

      return this._provider._rpcBatchRequest(batch)
        .then((result) => {
          // For each result, feed it to the correct Promise, depending
          // on whether it was a success or error
          chunk.forEach((inflightRequest, index) => {
            const payload = result[index];
            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest.reject(error);
            } else {
              inflightRequest.resolve(payload);
            }
          });
        }).catch((error) => {
          if(error && [
            'Failed to fetch', '504', '503', '502', '500', '429', '426', '422', '413', '409', '408', '406', '405', '404', '403', '402', '401', '400'
          ].some((errorType)=>error.toString().match(errorType))) {
            const index = this._endpoints.indexOf(this._endpoint)+1;
            this._endpoint = index >= this._endpoints.length ? this._endpoints[0] : this._endpoints[index];
            this._provider = new Connection(this._endpoint);
            this.requestChunk(chunk);
          } else {
            chunk.forEach((inflightRequest) => {
              inflightRequest.reject(error);
            });
          }
        })
    }
      
    _rpcRequestReplacement(methodName, args) {

      const request = { methodName, args };

      if (this._pendingBatch == null) {
        this._pendingBatch = [];
      }

      const inflightRequest = { request, resolve: null, reject: null };

      const promise = new Promise((resolve, reject) => {
        inflightRequest.resolve = resolve;
        inflightRequest.reject = reject;
      });

      this._pendingBatch.push(inflightRequest);

      if (!this._pendingBatchAggregator) {
        // Schedule batch for next event loop + short duration
        this._pendingBatchAggregator = setTimeout(() => {
          // Get the current batch and clear it, so new requests
          // go into the next batch
          const batch = this._pendingBatch;
          this._pendingBatch = [];
          this._pendingBatchAggregator = null;
          // Prepare Chunks of CHUNK_SIZE
          const chunks = [];
          for (let i = 0; i < Math.ceil(batch.length / CHUNK_SIZE); i++) {
            chunks[i] = batch.slice(i*CHUNK_SIZE, (i+1)*CHUNK_SIZE);
          }
          chunks.forEach((chunk)=>{
            // Get the request as an array of requests
            chunk.map((inflight) => inflight.request);
            return this.requestChunk(chunk)
          });
        }, getConfiguration().batchInterval || BATCH_INTERVAL);
      }

      return promise
    }
  }

  const getAllProviders = ()=> {
    if(getWindow()._Web3ClientProviders == undefined) {
      getWindow()._Web3ClientProviders = {};
    }
    return getWindow()._Web3ClientProviders
  };

  const setProvider$1 = (blockchain, provider)=> {
    if(getAllProviders()[blockchain] === undefined) { getAllProviders()[blockchain] = []; }
    const index = getAllProviders()[blockchain].indexOf(provider);
    if(index > -1) {
      getAllProviders()[blockchain].splice(index, 1);
    }
    getAllProviders()[blockchain].unshift(provider);
  };

  const setProviderEndpoints$1 = async (blockchain, endpoints, detectFastest = true)=> {
    
    getAllProviders()[blockchain] = endpoints.map((endpoint, index)=>
      new StaticJsonRpcSequentialProvider(endpoint, blockchain, endpoints, ()=>{
        if(getAllProviders()[blockchain].length === 1) {
          setProviderEndpoints$1(blockchain, endpoints, detectFastest);
        } else {
          getAllProviders()[blockchain].splice(index, 1);
        }
      })
    );

    let provider;
    let window = getWindow();

    if(
      window.fetch == undefined ||
      (typeof process != 'undefined' && process['env'] && process['env']['NODE_ENV'] == 'test') ||
      (typeof window.cy != 'undefined') ||
      detectFastest === false
    ) {
      provider = getAllProviders()[blockchain][0];
    } else {
      
      let responseTimes = await Promise.all(endpoints.map((endpoint)=>{
        return new Promise(async (resolve)=>{
          let timeout = 900;
          let before = new Date().getTime();
          setTimeout(()=>resolve(timeout), timeout);
          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({ method: 'getIdentity', id: 1, jsonrpc: '2.0' })
          });
          if(!response.ok) { return resolve(999) }
          let after = new Date().getTime();
          resolve(after-before);
        })
      }));

      const fastestResponse = Math.min(...responseTimes);
      const fastestIndex = responseTimes.indexOf(fastestResponse);
      provider = getAllProviders()[blockchain][fastestIndex];
    }
    
    setProvider$1(blockchain, provider);
  };

  const getProvider$1 = async (blockchain)=> {

    let providers = getAllProviders();
    if(providers && providers[blockchain]){ return providers[blockchain][0] }
    
    let window = getWindow();
    if(window._Web3ClientGetProviderPromise && window._Web3ClientGetProviderPromise[blockchain]) { return await window._Web3ClientGetProviderPromise[blockchain] }

    if(!window._Web3ClientGetProviderPromise){ window._Web3ClientGetProviderPromise = {}; }
    window._Web3ClientGetProviderPromise[blockchain] = new Promise(async(resolve)=> {
      await setProviderEndpoints$1(blockchain, Blockchains__default['default'][blockchain].endpoints);
      resolve(getWindow()._Web3ClientProviders[blockchain][0]);
    });

    return await window._Web3ClientGetProviderPromise[blockchain]
  };

  const getProviders$1 = async(blockchain)=>{

    let providers = getAllProviders();
    if(providers && providers[blockchain]){ return providers[blockchain] }
    
    let window = getWindow();
    if(window._Web3ClientGetProvidersPromise && window._Web3ClientGetProvidersPromise[blockchain]) { return await window._Web3ClientGetProvidersPromise[blockchain] }

    if(!window._Web3ClientGetProvidersPromise){ window._Web3ClientGetProvidersPromise = {}; }
    window._Web3ClientGetProvidersPromise[blockchain] = new Promise(async(resolve)=> {
      await setProviderEndpoints$1(blockchain, Blockchains__default['default'][blockchain].endpoints);
      resolve(getWindow()._Web3ClientProviders[blockchain]);
    });

    return await window._Web3ClientGetProvidersPromise[blockchain]
  };

  var Solana = {
    getProvider: getProvider$1,
    getProviders: getProviders$1,
    setProviderEndpoints: setProviderEndpoints$1,
    setProvider: setProvider$1,
  };

  let supported$1 = ['ethereum', 'bsc', 'polygon', 'solana', 'fantom', 'velas'];
  supported$1.evm = ['ethereum', 'bsc', 'polygon', 'fantom', 'velas'];
  supported$1.solana = ['solana'];

  function _optionalChain$1$1(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  let getCacheStore = () => {
    if (getWindow()._Web3ClientCacheStore == undefined) {
      getWindow()._Web3ClientCacheStore = {};
    }
    return getWindow()._Web3ClientCacheStore
  };

  let getPromiseStore = () => {
    if (getWindow()._Web3ClientPromiseStore == undefined) {
      getWindow()._Web3ClientPromiseStore = {};
    }
    return getWindow()._Web3ClientPromiseStore
  };

  let set = function ({ key, value, expires }) {
    getCacheStore()[key] = {
      expiresAt: Date.now() + expires,
      value,
    };
  };

  let get = function ({ key, expires }) {
    let cachedEntry = getCacheStore()[key];
    if (_optionalChain$1$1([cachedEntry, 'optionalAccess', _ => _.expiresAt]) > Date.now()) {
      return cachedEntry.value
    }
  };

  let getPromise = function({ key }) {
    return getPromiseStore()[key]
  };

  let setPromise = function({ key, promise }) {
    getPromiseStore()[key] = promise;
    return promise
  };

  let deletePromise = function({ key }) {
    getPromiseStore()[key] = undefined; 
  };

  let cache = function ({ call, key, expires = 0 }) {
    return new Promise((resolve, reject)=>{
      let value;
      key = JSON.stringify(key);
      
      // get existing promise (of a previous pending request asking for the exact same thing)
      let existingPromise = getPromise({ key });
      if(existingPromise) { 
        return existingPromise
          .then(resolve)
          .catch(reject)
      }

      setPromise({ key, promise: new Promise((resolveQueue, rejectQueue)=>{
        if (expires === 0) {
          return call()
            .then((value)=>{
              resolve(value);
              resolveQueue(value);
            })
            .catch((error)=>{
              reject(error);
              rejectQueue(error);
            })
        }
        
        // get cached value
        value = get({ key, expires });
        if (value) {
          resolve(value);
          resolveQueue(value);
          return value
        }

        // set new cache value
        call()
          .then((value)=>{
            if (value) {
              set({ key, value, expires });
            }
            resolve(value);
            resolveQueue(value);
          })
          .catch((error)=>{
            reject(error);
            rejectQueue(error);
          });
        })
      }).then(()=>{
        deletePromise({ key });
      }).catch(()=>{
        deletePromise({ key });
      });
    })
  };

  let paramsToContractArgs = ({ contract, method, params }) => {
    let fragment = contract.interface.fragments.find((fragment) => {
      return fragment.name == method
    });

    return fragment.inputs.map((input, index) => {
      if (Array.isArray(params)) {
        return params[index]
      } else {
        return params[input.name]
      }
    })
  };

  const contractCall = ({ address, api, method, params, provider, block }) => {
    let contract = new ethers.ethers.Contract(address, api, provider);
    let args = paramsToContractArgs({ contract, method, params });
    return contract[method](...args, { blockTag: block })
  };

  const balance$1 = ({ address, provider }) => {
    return provider.getBalance(address)
  };

  const transactionCount = ({ address, provider }) => {
    return provider.getTransactionCount(address)
  };

  const singleRequest$1 = ({ blockchain, address, api, method, params, block, provider }) =>{
    if (api) {
      return contractCall({ address, api, method, params, provider, block })
    } else if (method === 'latestBlockNumber') {
      return provider.getBlockNumber()
    } else if (method === 'balance') {
      return balance$1({ address, provider })
    } else if (method === 'transactionCount') {
      return transactionCount({ address, provider })
    }
  };

  var requestEVM = async ({ blockchain, address, api, method, params, block, timeout, strategy }) => {

    strategy = strategy ? strategy : (getConfiguration().strategy || 'failover');
    timeout = timeout ? timeout : (getConfiguration().timeout || undefined);

    if(strategy === 'fastest') {

      return Promise.race((await EVM.getProviders(blockchain)).map((provider)=>{

        const request = singleRequest$1({ blockchain, address, api, method, params, block, provider });
      
        if(timeout) {
          const timeoutPromise = new Promise((_, reject)=>setTimeout(()=>{ reject(new Error("Web3ClientTimeout")); }, timeout));
          return Promise.race([request, timeoutPromise])
        } else {
          return request
        }
      }))

    } else { // failover

      const provider = await EVM.getProvider(blockchain);
      const request = singleRequest$1({ blockchain, address, api, method, params, block, provider });
      
      if(timeout) {
        timeout = new Promise((_, reject)=>setTimeout(()=>{ reject(new Error("Web3ClientTimeout")); }, timeout));
        return Promise.race([request, timeout])
      } else {
        return request
      }
    }
  };

  const accountInfo = async ({ address, api, method, params, provider, block }) => {
    const info = await provider.getAccountInfo(new PublicKey(address));
    return api.decode(info.data)
  };

  const balance = ({ address, provider }) => {
    return provider.getBalance(new PublicKey(address))
  };

  const singleRequest = async({ blockchain, address, api, method, params, block, provider, providers })=> {

    try {

      if(method == undefined || method === 'getAccountInfo') {
        if(api == undefined) {
          api = ACCOUNT_LAYOUT; 
        }
        return await accountInfo({ address, api, method, params, provider, block })
      } else if(method === 'getProgramAccounts') {
        return await provider.getProgramAccounts(new PublicKey(address), params).then((accounts)=>{
          if(api){
            return accounts.map((account)=>{
              account.data = api.decode(account.account.data);
              return account
            })
          } else {
            return accounts
          }
        })
      } else if(method === 'getTokenAccountBalance') {
        return await provider.getTokenAccountBalance(new PublicKey(address))
      } else if (method === 'latestBlockNumber') {
        return await provider.getBlockHeight()  
      } else if (method === 'balance') {
        return await balance({ address, provider })
      }

    } catch (error){
      if(providers && error && [
        'Failed to fetch', '504', '503', '502', '500', '429', '426', '422', '413', '409', '408', '406', '405', '404', '403', '402', '401', '400'
      ].some((errorType)=>error.toString().match(errorType))) {
        let nextProvider = providers[providers.indexOf(provider)+1] || providers[0];
        return singleRequest({ blockchain, address, api, method, params, block, provider: nextProvider, providers })
      } else {
        throw error
      }
    }
  };

  var requestSolana = async ({ blockchain, address, api, method, params, block, timeout, strategy }) => {

    strategy = strategy ? strategy : (getConfiguration().strategy || 'failover');
    timeout = timeout ? timeout : (getConfiguration().timeout || undefined);

    const providers = await Solana.getProviders(blockchain);

    if(strategy === 'fastest') {

      return Promise.race(providers.map((provider)=>{

        const succeedingRequest = new Promise((resolve)=>{
          singleRequest({ blockchain, address, api, method, params, block, provider }).then(resolve);
        }); // failing requests are ignored during race/fastest
      
        const timeoutPromise = new Promise((_, reject)=>setTimeout(()=>{ reject(new Error("Web3ClientTimeout")); }, timeout || 10000));
          
        return Promise.race([succeedingRequest, timeoutPromise])
      }))
      
    } else { // failover

      const provider = await Solana.getProvider(blockchain);
      const request = singleRequest({ blockchain, address, api, method, params, block, provider, providers });

      if(timeout) {
        timeout = new Promise((_, reject)=>setTimeout(()=>{ reject(new Error("Web3ClientTimeout")); }, timeout));
        return Promise.race([request, timeout])
      } else {
        return request
      }
    }
  };

  var parseUrl = (url) => {
    if (typeof url == 'object') {
      return url
    }
    let deconstructed = url.match(/(?<blockchain>\w+):\/\/(?<part1>[\w\d]+)(\/(?<part2>[\w\d]+)*)?/);

    if(deconstructed.groups.part2 == undefined) {
      if(deconstructed.groups.part1.match(/\d/)) {
        return {
          blockchain: deconstructed.groups.blockchain,
          address: deconstructed.groups.part1
        }
      } else {
        return {
          blockchain: deconstructed.groups.blockchain,
          method: deconstructed.groups.part1
        }
      }
    } else {
      return {
        blockchain: deconstructed.groups.blockchain,
        address: deconstructed.groups.part1,
        method: deconstructed.groups.part2
      }
    }
  };

  const request = async function (url, options) {
    
    const { blockchain, address, method } = parseUrl(url);
    const { api, params, cache: cache$1, block, timeout, strategy } = (typeof(url) == 'object' ? url : options) || {};

    return await cache({
      expires: cache$1 || 0,
      key: [blockchain, address, method, params, block],
      call: async()=>{
        if(supported$1.evm.includes(blockchain)) {


          return await requestEVM({ blockchain, address, api, method, params, block, strategy, timeout })


        } else if(supported$1.solana.includes(blockchain)) {


          return await requestSolana({ blockchain, address, api, method, params, block, strategy, timeout })


        } else {
          throw 'Unknown blockchain: ' + blockchain
        }  
      }
    })
  };

  function _optionalChain$g(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class Transaction {

    constructor({
      blockchain,
      from,
      to,
      value,
      api,
      method,
      params,
      instructions,
      signers,
      alts,
      sent,
      succeeded,
      failed
    }) {

      // required
      this.blockchain = blockchain;
      this.from = (from && from.match('0x')) ? ethers.ethers.utils.getAddress(from) : from;
      this.to = (to && to.match('0x')) ? ethers.ethers.utils.getAddress(to) : to;

      // optional
      this.value = _optionalChain$g([Transaction, 'access', _ => _.bigNumberify, 'call', _2 => _2(value, blockchain), 'optionalAccess', _3 => _3.toString, 'call', _4 => _4()]);
      this.api = api;
      this.method = method;
      this.params = params;
      this.sent = sent;
      this.succeeded = succeeded;
      this.failed = failed;
      this.instructions = instructions;
      this.signers = signers;
      this.alts = alts;

      // internal
      this._succeeded = false;
      this._failed = false;
    }

    async prepare({ wallet }) {
      this.from = await wallet.account(this.blockchain);
    }

    static bigNumberify(value, blockchain) {
      if (typeof value === 'number') {
        return ethers.ethers.utils.parseUnits(value.toString(), Blockchains__default['default'][blockchain].currency.decimals)
      } else if (value && value.toString) {
        return ethers.ethers.BigNumber.from(value.toString())
      } else {
        return value
      }
    }

    getContractArguments() {
      let fragment = this.getContract().interface.fragments.find((fragment) => {
        return fragment.name == this.method
      });

      if(this.params instanceof Array) {
        return this.params
      } else if (this.params instanceof Object) {
        return fragment.inputs.map((input) => {
          return this.params[input.name]
        })
      }
    }

    getContract() {
      return new ethers.ethers.Contract(this.to, this.api)
    }

    async getData() {
      let contractArguments = this.getContractArguments();
      let populatedTransaction;
      if(contractArguments) {
        populatedTransaction = await this.getContract().populateTransaction[this.method].apply(
          null, contractArguments
        );
      } else {
        populatedTransaction = await this.getContract().populateTransaction[this.method].apply(null);
      }
       
      return populatedTransaction.data
    }

    success() {
      if (this._succeeded) {
        return Promise.resolve(this)
      }
      return new Promise((resolve, reject) => {
        let originalSucceeded = this.succeeded;
        this.succeeded = (transaction) => {
          if (originalSucceeded) originalSucceeded(transaction);
          resolve(transaction);
        };
      })
    }

    failure() {
      if (this._failed) {
        return Promise.resolve(this)
      }
      return new Promise((resolve, reject) => {
        let originalFailed = this.failed;
        this.failed = (transaction, reason) => {
          if (originalFailed) originalFailed(transaction, reason);
          resolve(transaction, reason);
        };
      })
    }
  }

  const sendTransaction$3 = async ({ transaction, wallet })=> {
    transaction = new Transaction(transaction);
    if((await wallet.connectedTo(transaction.blockchain)) == false) {
      await wallet.switchTo(transaction.blockchain);
    }
    if((await wallet.connectedTo(transaction.blockchain)) == false) {
      throw({ code: 'WRONG_NETWORK' })
    }
    await transaction.prepare({ wallet });
    let transactionCount = await web3ClientEvm.request({ blockchain: transaction.blockchain, method: 'transactionCount', address: transaction.from });
    transaction.nonce = transactionCount;
    let provider = new ethers.ethers.providers.Web3Provider(wallet.getProvider(), 'any');
    let signer = provider.getSigner(0);
    await submit$3({ transaction, provider, signer }).then((sentTransaction)=>{
      if (sentTransaction) {
        transaction.id = sentTransaction.hash;
        transaction.nonce = sentTransaction.nonce || transactionCount;
        transaction.url = Blockchains__default['default'].findByName(transaction.blockchain).explorerUrlFor({ transaction });
        if (transaction.sent) transaction.sent(transaction);
        sentTransaction.wait(1).then(() => {
          transaction._succeeded = true;
          if (transaction.succeeded) transaction.succeeded(transaction);
        }).catch((error)=>{
          if(error && error.code && error.code == 'TRANSACTION_REPLACED') {
            if(error.replacement && error.replacement.hash) {
              transaction.id = error.replacement.hash;
              transaction.url = Blockchains__default['default'].findByName(transaction.blockchain).explorerUrlFor({ transaction });
            }
            if(error.replacement && error.replacement.hash && error.receipt && error.receipt.status == 1) {
              transaction._succeeded = true;
              if (transaction.succeeded) transaction.succeeded(transaction);
            } else if(error.replacement && error.replacement.hash && error.receipt && error.receipt.status == 0) {
              transaction._failed = true;
              if(transaction.failed) transaction.failed(transaction, error);  
            }
          } else {
            transaction._failed = true;
            if(transaction.failed) transaction.failed(transaction, error);
          }
        });
      } else {
        throw('Submitting transaction failed!')
      }
    });
    return transaction
  };

  const submit$3 = ({ transaction, provider, signer }) => {
    if(transaction.method) {
      return submitContractInteraction$2({ transaction, signer, provider })
    } else {
      return submitSimpleTransfer$3({ transaction, signer })
    }
  };

  const submitContractInteraction$2 = ({ transaction, signer, provider })=>{
    let contract = new ethers.ethers.Contract(transaction.to, transaction.api, provider);
    let contractArguments = transaction.getContractArguments({ contract });
    let method = contract.connect(signer)[transaction.method];
    if(contractArguments) {
      return method(...contractArguments, {
        value: Transaction.bigNumberify(transaction.value, transaction.blockchain)
      })
    } else {
      return method({
        value: Transaction.bigNumberify(transaction.value, transaction.blockchain)
      })
    }
  };

  const submitSimpleTransfer$3 = ({ transaction, signer })=>{
    return signer.sendTransaction({
      to: transaction.to,
      value: Transaction.bigNumberify(transaction.value, transaction.blockchain)
    })
  };

  function _optionalChain$f(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class WindowEthereum {

    static __initStatic() {this.info = {
      name: 'Wallet (Ethereum)',
      logo: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA0NDYuNCAzNzYuOCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDQ2LjQgMzc2Ljg7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojODI4NDg3O30KCS5zdDF7ZmlsbDojMzQzNDM0O30KCS5zdDJ7ZmlsbDojOEM4QzhDO30KCS5zdDN7ZmlsbDojM0MzQzNCO30KCS5zdDR7ZmlsbDojMTQxNDE0O30KCS5zdDV7ZmlsbDojMzkzOTM5O30KPC9zdHlsZT4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTM4MS43LDExMC4yaDY0LjdWNDYuNWMwLTI1LjctMjAuOC00Ni41LTQ2LjUtNDYuNUg0Ni41QzIwLjgsMCwwLDIwLjgsMCw0Ni41djY1LjFoMzUuN2wyNi45LTI2LjkKCWMxLjUtMS41LDMuNi0yLjUsNS43LTIuN2wwLDBoMC40aDc4LjZjNS4zLTI1LjUsMzAuMi00Miw1NS43LTM2LjdjMjUuNSw1LjMsNDIsMzAuMiwzNi43LDU1LjdjLTEuNiw3LjUtNC45LDE0LjYtOS44LDIwLjUKCWMtMC45LDEuMS0xLjksMi4yLTMsMy4zYy0xLjEsMS4xLTIuMiwyLjEtMy4zLDNjLTIwLjEsMTYuNi00OS45LDEzLjgtNjYuNS02LjNjLTQuOS01LjktOC4zLTEzLTkuOC0yMC42SDczLjJsLTI2LjksMjYuOAoJYy0xLjUsMS41LTMuNiwyLjUtNS43LDIuN2wwLDBoLTAuNGgtMC4xaC0wLjVIMHY3NGgyOC44bDE4LjItMTguMmMxLjUtMS42LDMuNi0yLjUsNS43LTIuN2wwLDBoMC40aDI5LjkKCWM1LjItMjUuNSwzMC4yLTQxLjksNTUuNy0zNi43czQxLjksMzAuMiwzNi43LDU1LjdzLTMwLjIsNDEuOS01NS43LDM2LjdjLTE4LjUtMy44LTMyLjktMTguMi0zNi43LTM2LjdINTcuN2wtMTguMiwxOC4zCgljLTEuNSwxLjUtMy42LDIuNS01LjcsMi43bDAsMGgtMC40SDB2MzQuMmg1Ni4zYzAuMiwwLDAuMywwLDAuNSwwaDAuMWgwLjRsMCwwYzIuMiwwLjIsNC4yLDEuMiw1LjgsMi44bDI4LDI4aDU3LjcKCWM1LjMtMjUuNSwzMC4yLTQyLDU1LjctMzYuN3M0MiwzMC4yLDM2LjcsNTUuN2MtMS43LDguMS01LjUsMTUuNy0xMSwyMS45Yy0wLjYsMC43LTEuMiwxLjMtMS45LDJzLTEuMywxLjMtMiwxLjkKCWMtMTkuNSwxNy4zLTQ5LjMsMTUuNi02Ni43LTMuOWMtNS41LTYuMi05LjMtMTMuNy0xMS0yMS45SDg3LjFjLTEuMSwwLTIuMS0wLjItMy4xLTAuNWgtMC4xbC0wLjMtMC4xbC0wLjItMC4xbC0wLjItMC4xbC0wLjMtMC4xCgloLTAuMWMtMC45LTAuNS0xLjgtMS4xLTIuNi0xLjhsLTI4LTI4SDB2NTMuNWMwLjEsMjUuNywyMC45LDQ2LjQsNDYuNSw0Ni40aDM1My4zYzI1LjcsMCw0Ni41LTIwLjgsNDYuNS00Ni41di02My42aC02NC43CgljLTQzLjIsMC03OC4yLTM1LTc4LjItNzguMmwwLDBDMzAzLjUsMTQ1LjIsMzM4LjUsMTEwLjIsMzgxLjcsMTEwLjJ6Ii8+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yMjAuOSwyOTguMWMwLTE0LjQtMTEuNi0yNi0yNi0yNnMtMjYsMTEuNi0yNiwyNnMxMS42LDI2LDI2LDI2UzIyMC45LDMxMi40LDIyMC45LDI5OC4xTDIyMC45LDI5OC4xeiIvPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMjE5LjYsOTEuNWMwLTE0LjQtMTEuNi0yNi0yNi0yNnMtMjYsMTEuNi0yNiwyNnMxMS42LDI2LDI2LDI2UzIxOS42LDEwNS44LDIxOS42LDkxLjV6Ii8+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0zODIuMiwxMjguOGgtMC41Yy0zMi45LDAtNTkuNiwyNi43LTU5LjYsNTkuNmwwLDBsMCwwYzAsMzIuOSwyNi43LDU5LjYsNTkuNiw1OS42bDAsMGgwLjUKCWMzMi45LDAsNTkuNi0yNi43LDU5LjYtNTkuNmwwLDBDNDQxLjgsMTU1LjQsNDE1LjEsMTI4LjgsMzgyLjIsMTI4Ljh6IE0zOTYuNiwyMTkuNGgtMzFsOC45LTMyLjVjLTcuNy0zLjctMTEtMTIuOS03LjQtMjAuNgoJYzMuNy03LjcsMTIuOS0xMSwyMC42LTcuNGM3LjcsMy43LDExLDEyLjksNy40LDIwLjZjLTEuNSwzLjItNC4xLDUuOC03LjQsNy40TDM5Ni42LDIxOS40eiIvPgo8ZyBpZD0iTGF5ZXJfeDAwMjBfMSI+Cgk8ZyBpZD0iXzE0MjEzOTQzNDI0MDAiPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjEyOSwxNjYuMiAxMjguNywxNjcuMyAxMjguNywyMDEuNCAxMjksMjAxLjcgMTQ0LjgsMTkyLjQgCQkJIi8+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDIiIHBvaW50cz0iMTI5LDE2Ni4yIDExMy4yLDE5Mi40IDEyOSwyMDEuNyAxMjksMTg1LjIgCQkJIi8+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iMTI5LDIwNC43IDEyOC44LDIwNC45IDEyOC44LDIxNyAxMjksMjE3LjYgMTQ0LjgsMTk1LjQgCQkJIi8+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDIiIHBvaW50cz0iMTI5LDIxNy42IDEyOSwyMDQuNyAxMTMuMiwxOTUuNCAJCQkiLz4KCQkJPHBvbHlnb24gY2xhc3M9InN0NCIgcG9pbnRzPSIxMjksMjAxLjcgMTQ0LjgsMTkyLjQgMTI5LDE4NS4yIAkJCSIvPgoJCQk8cG9seWdvbiBjbGFzcz0ic3Q1IiBwb2ludHM9IjExMy4yLDE5Mi40IDEyOSwyMDEuNyAxMjksMTg1LjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ 
      return (
        _optionalChain$f([window, 'optionalAccess', _23 => _23.ethereum]) &&
        Object.keys(window.ethereum).filter((key)=>key.match(/^is(?!Connected)(?!PocketUniverse)(?!RevokeCash)/)).length != 1 && // MetaMask
        !_optionalChain$f([window, 'optionalAccess', _24 => _24.coin98]) && // Coin98
        !(_optionalChain$f([window, 'optionalAccess', _25 => _25.ethereum, 'optionalAccess', _26 => _26.isTrust]) || _optionalChain$f([window, 'optionalAccess', _27 => _27.ethereum, 'optionalAccess', _28 => _28.isTrustWallet])) && // Trust Wallet
        !_optionalChain$f([window, 'optionalAccess', _29 => _29.ethereum, 'optionalAccess', _30 => _30.isDeficonnectProvider]) && // crypto.com
        !_optionalChain$f([window, 'optionalAccess', _31 => _31.ethereum, 'optionalAccess', _32 => _32.isHyperPay]) && // isHyperPay
        !_optionalChain$f([window, 'optionalAccess', _33 => _33.ethereum, 'optionalAccess', _34 => _34.isPhantom]) && // Phantom
        !_optionalChain$f([window, 'optionalAccess', _35 => _35.solana, 'optionalAccess', _36 => _36.isPhantom]) && // Phantom
        !_optionalChain$f([window, 'optionalAccess', _37 => _37.ethereum, 'optionalAccess', _38 => _38.isRabby]) && // Rabby
        !_optionalChain$f([window, 'optionalAccess', _39 => _39.backpack, 'optionalAccess', _40 => _40.isBackpack]) && // Backpack
        !(_optionalChain$f([window, 'optionalAccess', _41 => _41.ethereum, 'optionalAccess', _42 => _42.isCoinbaseWallet]) || _optionalChain$f([window, 'optionalAccess', _43 => _43.ethereum, 'optionalAccess', _44 => _44.isWalletLink]))
      )
    };}
    
    constructor () {
      this.name = this.constructor.info.name;
      this.logo = this.constructor.info.logo;
      this.blockchains = this.constructor.info.blockchains;
      this.sendTransaction = (transaction)=>{
        return sendTransaction$3({
          wallet: this,
          transaction
        })
      };
    }

    getProvider() { return window.ethereum }

    async account() {
      if(!this.getProvider()) { return undefined }
      const accounts = (await this.getProvider().request({ method: 'eth_accounts' })).map((address)=>ethers.ethers.utils.getAddress(address));
      return accounts[0]
    }

    async connect() {
      if(!this.getProvider()) { return undefined }
      const accounts = (await this.getProvider().request({ method: 'eth_requestAccounts' })).map((address)=>ethers.ethers.utils.getAddress(address));
      return accounts[0]
    }

    on(event, callback) {
      let internalCallback;
      switch (event) {
        case 'account':
          internalCallback = (accounts) => callback(ethers.ethers.utils.getAddress(accounts[0]));
          this.getProvider().on('accountsChanged', internalCallback);
          break
      }
      return internalCallback
    }

    off(event, internalCallback) {
      switch (event) {
        case 'account':
          this.getProvider().removeListener('accountsChanged', internalCallback);
          break
      }
      return internalCallback
    }

    async connectedTo(input) {
      const blockchain = Blockchains__default['default'].findById(await this.getProvider().request({ method: 'eth_chainId' }));
      if(input) {
        return input === blockchain.name
      } else {
        return blockchain.name
      }
    }

    addNetwork(blockchainName) {
      return new Promise((resolve, reject)=>{
        const blockchain = Blockchains__default['default'].findByName(blockchainName);
        this.getProvider().request({
          method: 'wallet_addEthereumChain',
          params: [{
            chainId: blockchain.id,
            chainName: blockchain.fullName,
            nativeCurrency: {
              name: blockchain.currency.name,
              symbol: blockchain.currency.symbol,
              decimals: blockchain.currency.decimals
            },
            rpcUrls: [blockchain.rpc],
            blockExplorerUrls: [blockchain.explorer],
            iconUrls: [blockchain.logo]
          }],
        }).then(resolve).catch(reject);
      })
    }

    switchTo(blockchainName) {
      return new Promise((resolve, reject)=>{
        const blockchain = Blockchains__default['default'].findByName(blockchainName);
        this.getProvider().request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: blockchain.id }],
        }).then(resolve).catch((error)=> {
          if(error.code === 4902){ // chain not yet added
            this.addNetwork(blockchainName)
              .then(()=>this.switchTo(blockchainName).then(resolve))
              .catch(reject);
          } else {
            reject(error);
          }
        });
      })
    }

    transactionCount({ blockchain, address }) {
      return request({ blockchain, method: 'transactionCount', address })
    }

    async sign(message) {
      await this.account();
      let provider = new ethers.ethers.providers.Web3Provider(this.getProvider(), 'any');
      let signer = provider.getSigner(0);
      let signature = await signer.signMessage(message);
      return signature
    }
  } WindowEthereum.__initStatic(); WindowEthereum.__initStatic2();

  function _optionalChain$e(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class Binance extends WindowEthereum {

    static __initStatic() {this.info = {
      name: 'Binance Wallet',
      logo: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxOTIgMTkzLjY4Ij48cmVjdCB3aWR0aD0iMTkyIiBoZWlnaHQ9IjE5My42OCIgZmlsbD0iIzFlMjAyNCIvPjxwYXRoIGQ9Im01Ni45Miw0Ni41M2wzOS4wOC0yMi41NCwzOS4wOCwyMi41NC0xNC4zNSw4LjM2LTI0LjczLTE0LjE4LTI0LjczLDE0LjE4LTE0LjM1LTguMzZabTc4LjE3LDI4LjUzbC0xNC4zNS04LjM2LTI0LjczLDE0LjI3LTI0LjczLTE0LjI3LTE0LjM1LDguMzZ2MTYuNzFsMjQuNzMsMTQuMTh2MjguNDVsMTQuMzUsOC4zNiwxNC4zNS04LjM2di0yOC40NWwyNC43My0xNC4yN3YtMTYuNjNabTAsNDUuMTZ2LTE2LjcxbC0xNC4zNSw4LjM2djE2LjcxbDE0LjM1LTguMzZabTEwLjIxLDUuODJsLTI0LjczLDE0LjI3djE2LjcxbDM5LjA4LTIyLjU0di00NS4yNWwtMTQuMzUsOC4zNnYyOC40NVptLTE0LjM1LTY1LjI1bDE0LjM1LDguMzZ2MTYuNzFsMTQuMzUtOC4zNnYtMTYuNzFsLTE0LjM1LTguMzYtMTQuMzUsOC4zNlptLTQ5LjMsODUuNnYxNi43MWwxNC4zNSw4LjM2LDE0LjM1LTguMzZ2LTE2LjcxbC0xNC4zNSw4LjM2LTE0LjM1LTguMzZabS0yNC43My0yNi4xN2wxNC4zNSw4LjM2di0xNi43MWwtMTQuMzUtOC4zNnYxNi43MVptMjQuNzMtNTkuNDNsMTQuMzUsOC4zNiwxNC4zNS04LjM2LTE0LjM1LTguMzYtMTQuMzUsOC4zNlptLTM0Ljk1LDguMzZsMTQuMzUtOC4zNi0xNC4zNS04LjM2LTE0LjM1LDguMzZ2MTYuNzFsMTQuMzUsOC4zNnYtMTYuNzFabTAsMjguNDVsLTE0LjM1LTguMzZ2NDUuMTZsMzkuMDgsMjIuNTR2LTE2LjcxbC0yNC43My0xNC4yN3MwLTI4LjM2LDAtMjguMzZaIiBmaWxsPSIjZjBiOTBiIi8+PC9zdmc+",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{
      return _optionalChain$e([window, 'optionalAccess', _2 => _2.BinanceChain]) &&
        !window.coin98
    };}

    getProvider() { return window.BinanceChain }

  } Binance.__initStatic(); Binance.__initStatic2();

  function _optionalChain$d(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class Brave extends WindowEthereum {

    static __initStatic() {this.info = {
      name: 'Brave',
      logo: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCAyNTYgMzAxIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAyNTYgMzAxIiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgoKCTxwYXRoIGZpbGw9IiNGMTVBMjIiIGQ9Im0yMzYgMTA1LjQtNy44LTIxLjIgNS40LTEyLjJjMC43LTEuNiAwLjMtMy40LTAuOC00LjZsLTE0LjgtMTQuOWMtNi41LTYuNS0xNi4xLTguOC0yNC44LTUuN2wtNC4xIDEuNC0yMi42LTI0LjUtMzguMi0wLjNoLTAuM2wtMzguNSAwLjMtMjIuNiAyNC43LTQtMS40Yy04LjgtMy4xLTE4LjUtMC44LTI1IDUuOGwtMTUgMTUuMmMtMSAxLTEuMyAyLjQtMC44IDMuN2w1LjcgMTIuNy03LjggMjEuMiA1LjEgMTkuMiAyMyA4Ny4yYzIuNiAxMCA4LjcgMTguOCAxNy4yIDI0LjkgMCAwIDI3LjggMTkuNyA1NS4zIDM3LjUgMi40IDEuNiA1IDIuNyA3LjcgMi43czUuMi0xLjEgNy43LTIuN2MzMC45LTIwLjIgNTUuMy0zNy41IDU1LjMtMzcuNSA4LjQtNi4xIDE0LjUtMTQuOCAxNy4xLTI0LjlsMjIuOC04Ny4yIDQuOC0xOS40eiIvPgoJPHBhdGggZmlsbD0iI0ZGRkZGRiIgZD0ibTEzMy4xIDE3OS40Yy0xLTAuNC0yLjEtMC44LTIuNC0wLjhoLTIuN2MtMC4zIDAtMS40IDAuMy0yLjQgMC44bC0xMSA0LjZjLTEgMC40LTIuNyAxLjItMy43IDEuN2wtMTYuNSA4LjZjLTEgMC41LTEuMSAxLjQtMC4yIDIuMWwxNC42IDEwLjNjMC45IDAuNyAyLjQgMS44IDMuMiAyLjVsNi41IDUuNmMwLjggMC44IDIuMiAxLjkgMyAyLjdsNi4yIDUuNmMwLjggMC44IDIuMiAwLjggMyAwbDYuNC01LjZjMC44LTAuOCAyLjItMS45IDMtMi43bDYuNS01LjdjMC44LTAuOCAyLjMtMS45IDMuMi0yLjVsMTQuNi0xMC40YzAuOS0wLjcgMC44LTEuNi0wLjItMi4xbC0xNi41LTguNGMtMS0wLjUtMi43LTEuMy0zLjctMS43bC0xMC45LTQuNnoiLz4KCTxwYXRoIGZpbGw9IiNGRkZGRkYiIGQ9Im0yMTIuMiAxMDkuMmMwLjMtMS4xIDAuMy0xLjUgMC4zLTEuNSAwLTEuMS0wLjEtMy0wLjMtNGwtMC44LTIuNGMtMC41LTEtMS40LTIuNi0yLTMuNWwtOS41LTE0LjFjLTAuNi0wLjktMS43LTIuNC0yLjQtMy4zbC0xMi4zLTE1LjRjLTAuNy0wLjgtMS40LTEuNi0xLjQtMS41aC0wLjJzLTAuOSAwLjItMiAwLjNsLTE4LjggMy43Yy0xLjEgMC4zLTIuOSAwLjYtNCAwLjhsLTAuMyAwLjFjLTEuMSAwLjItMi45IDAuMS00LTAuM2wtMTUuOC01LjFjLTEuMS0wLjMtMi45LTAuOC0zLjktMS4xIDAgMC0zLjItMC44LTUuOC0wLjctMi42IDAtNS44IDAuNy01LjggMC43LTEuMSAwLjMtMi45IDAuOC0zLjkgMS4xbC0xNS44IDUuMWMtMS4xIDAuMy0yLjkgMC40LTQgMC4zbC0wLjMtMC4xYy0xLjEtMC4yLTIuOS0wLjYtNC0wLjhsLTE5LTMuNWMtMS4xLTAuMy0yLTAuMy0yLTAuM2gtMC4yYy0wLjEgMC0wLjggMC43LTEuNCAxLjVsLTEyLjMgMTUuMmMtMC43IDAuOC0xLjggMi40LTIuNCAzLjNsLTkuNSAxNC4xYy0wLjYgMC45LTEuNSAyLjUtMiAzLjVsLTAuOCAyLjRjLTAuMiAxLjEtMC4zIDMtMC4zIDQuMSAwIDAgMCAwLjMgMC4zIDEuNSAwLjYgMiAyIDMuOSAyIDMuOSAwLjcgMC44IDEuOSAyLjMgMi43IDNsMjcuOSAyOS43YzAuOCAwLjggMSAyLjQgMC42IDMuNGwtNS44IDEzLjhjLTAuNCAxLTAuNSAyLjctMC4xIDMuOGwxLjYgNC4zYzEuMyAzLjYgMy42IDYuOCA2LjcgOS4zbDUuNyA0LjZjMC44IDAuNyAyLjQgMC45IDMuNCAwLjRsMTcuOS04LjVjMS0wLjUgMi41LTEuNSAzLjQtMi4zbDEyLjgtMTEuNmMxLjktMS43IDEuOS00LjYgMC4zLTYuNGwtMjYuOS0xOC4xYy0wLjktMC42LTEuMy0xLjktMC44LTNsMTEuOC0yMi4zYzAuNS0xIDAuNi0yLjYgMC4yLTMuNmwtMS40LTMuM2MtMC40LTEtMS43LTIuMi0yLjctMi42bC0zNC45LTEzYy0xLTAuNC0xLTAuOCAwLjEtMC45bDIyLjQtMi4xYzEuMS0wLjEgMi45IDAuMSA0IDAuM2wxOS45IDUuNmMxLjEgMC4zIDEuOCAxLjQgMS42IDIuNWwtNyAzNy44Yy0wLjIgMS4xLTAuMiAyLjYgMC4xIDMuNXMxLjMgMS42IDIuNCAxLjlsMTMuOCAzYzEuMSAwLjMgMi45IDAuMyA0IDBsMTIuOS0zYzEuMS0wLjMgMi4yLTEuMSAyLjQtMS45IDAuMy0wLjggMC4zLTIuNCAwLjEtMy41bC02LjgtMzcuOWMtMC4yLTEuMSAwLjUtMi4zIDEuNi0yLjVsMTkuOS01LjZjMS4xLTAuMyAyLjktMC40IDQtMC4zbDIyLjQgMi4xYzEuMSAwLjEgMS4yIDAuNSAwLjEgMC45bC0zNC43IDEzLjJjLTEgMC40LTIuMyAxLjUtMi43IDIuNmwtMS40IDMuM2MtMC40IDEtMC40IDIuNyAwLjIgMy42bDExLjkgMjIuM2MwLjUgMSAwLjIgMi4zLTAuOCAzbC0yNi45IDE4LjJjLTEuOCAxLjgtMS42IDQuNyAwLjMgNi40bDEyLjggMTEuNmMwLjggMC44IDIuNCAxLjggMy40IDIuMmwxOCA4LjVjMSAwLjUgMi41IDAuMyAzLjQtMC40bDUuNy00LjZjMy0yLjQgNS4zLTUuNyA2LjYtOS4zbDEuNi00LjNjMC40LTEgMC4zLTIuOC0wLjEtMy44bC01LjgtMTMuOGMtMC40LTEtMC4yLTIuNSAwLjYtMy40bDI3LjktMjkuN2MwLjgtMC44IDEuOS0yLjIgMi43LTMtMC40LTAuMyAxLjEtMi4xIDEuNi00LjF6Ii8+Cgo8L3N2Zz4K",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ return _optionalChain$d([window, 'optionalAccess', _3 => _3.ethereum, 'optionalAccess', _4 => _4.isBraveWallet]) };}
  } Brave.__initStatic(); Brave.__initStatic2();

  function _optionalChain$c(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class Coin98 extends WindowEthereum {

    static __initStatic() {this.info = {
      name: 'Coin98',
      logo: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA0MC43IDQwIiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA0MC43IDQwIiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBmaWxsPSIjRDlCNDMyIiBkPSJtMzMuMyAwaC0yNS45Yy00LjEgMC03LjQgMy4zLTcuNCA3LjN2MjUuNGMwIDQgMy4zIDcuMyA3LjQgNy4zaDI1LjljNC4xIDAgNy40LTMuMyA3LjQtNy4zdi0yNS40YzAtNC0zLjMtNy4zLTcuNC03LjN6Ii8+CjxwYXRoIGZpbGw9IiMyNTI1MjUiIGQ9Im0zMy4zIDBoLTI1LjljLTQuMSAwLTcuNCAzLjMtNy40IDcuM3YyNS40YzAgNCAzLjMgNy4zIDcuNCA3LjNoMjUuOWM0LjEgMCA3LjQtMy4zIDcuNC03LjN2LTI1LjRjMC00LTMuMy03LjMtNy40LTcuM3ptLTYuMyAxMGMzIDAgNS41IDIuNCA1LjUgNS40IDAgMC45LTAuMiAxLjgtMC42IDIuNi0wLjctMC41LTEuNS0xLTIuMy0xLjMgMC4yLTAuNCAwLjMtMC45IDAuMy0xLjMgMC0xLjUtMS4zLTIuOC0yLjgtMi44LTEuNiAwLTIuOCAxLjMtMi44IDIuOCAwIDAuNSAwLjEgMC45IDAuMyAxLjMtMC44IDAuMy0xLjYgMC43LTIuMyAxLjMtMC41LTAuOC0wLjYtMS43LTAuNi0yLjYtMC4xLTMgMi4zLTUuNCA1LjMtNS40em0tMTMuMyAyMGMtMyAwLTUuNS0yLjQtNS41LTUuNGgyLjZjMCAxLjUgMS4zIDIuOCAyLjggMi44czIuOC0xLjMgMi44LTIuOGgyLjZjMC4yIDMtMi4zIDUuNC01LjMgNS40em0wLTcuNWMtMy41IDAtNi4zLTIuOC02LjMtNi4yczIuOC02LjMgNi4zLTYuMyA2LjQgMi44IDYuNCA2LjNjMCAzLjQtMi45IDYuMi02LjQgNi4yem0xMy4zIDcuNWMtMy41IDAtNi40LTIuOC02LjQtNi4yIDAtMy41IDIuOC02LjMgNi40LTYuMyAzLjUgMCA2LjMgMi44IDYuMyA2LjMgMC4xIDMuNC0yLjggNi4yLTYuMyA2LjJ6bTMuOC02LjNjMCAyLjEtMS43IDMuNy0zLjggMy43cy0zLjgtMS43LTMuOC0zLjdjMC0yLjEgMS43LTMuNyAzLjgtMy43IDIuMSAwLjEgMy44IDEuNyAzLjggMy43em0tMTMuNC03LjRjMCAyLjEtMS43IDMuNy0zLjggMy43cy0zLjgtMS43LTMuOC0zLjdjMC0yLjEgMS43LTMuNyAzLjgtMy43IDIuMiAwIDMuOCAxLjYgMy44IDMuN3oiLz4KPC9zdmc+Cg==",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ return _optionalChain$c([window, 'optionalAccess', _2 => _2.coin98]) };}
  } Coin98.__initStatic(); Coin98.__initStatic2();

  function _optionalChain$b(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class Coinbase extends WindowEthereum {

    static __initStatic() {this.info = {
      name: 'Coinbase',
      logo: "data:image/svg+xml;base64,PHN2ZyBpZD0nTGF5ZXJfMScgZGF0YS1uYW1lPSdMYXllciAxJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHhtbG5zOnhsaW5rPSdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyB2aWV3Qm94PScwIDAgNDg4Ljk2IDQ4OC45Nic+PGRlZnM+PHN0eWxlPi5jbHMtMXtmaWxsOnVybCgjbGluZWFyLWdyYWRpZW50KTt9LmNscy0ye2ZpbGw6IzQzNjFhZDt9PC9zdHlsZT48bGluZWFyR3JhZGllbnQgaWQ9J2xpbmVhci1ncmFkaWVudCcgeDE9JzI1MCcgeTE9JzcuMzUnIHgyPScyNTAnIHkyPSc0OTYuMzInIGdyYWRpZW50VHJhbnNmb3JtPSdtYXRyaXgoMSwgMCwgMCwgLTEsIDAsIDUwMiknIGdyYWRpZW50VW5pdHM9J3VzZXJTcGFjZU9uVXNlJz48c3RvcCBvZmZzZXQ9JzAnIHN0b3AtY29sb3I9JyMzZDViYTknLz48c3RvcCBvZmZzZXQ9JzEnIHN0b3AtY29sb3I9JyM0ODY4YjEnLz48L2xpbmVhckdyYWRpZW50PjwvZGVmcz48cGF0aCBjbGFzcz0nY2xzLTEnIGQ9J00yNTAsNS42OEMxMTQuODcsNS42OCw1LjUyLDExNSw1LjUyLDI1MC4xN1MxMTQuODcsNDk0LjY1LDI1MCw0OTQuNjUsNDk0LjQ4LDM4NS4yOSw0OTQuNDgsMjUwLjE3LDM4NS4xMyw1LjY4LDI1MCw1LjY4Wm0wLDM4Ny41NEExNDMuMDYsMTQzLjA2LDAsMSwxLDM5My4wNSwyNTAuMTcsMTQzLjExLDE0My4xMSwwLDAsMSwyNTAsMzkzLjIyWicgdHJhbnNmb3JtPSd0cmFuc2xhdGUoLTUuNTIgLTUuNjgpJy8+PHBhdGggY2xhc3M9J2Nscy0yJyBkPSdNMjg0LjY5LDI5Ni4wOUgyMTUuMzFhMTEsMTEsMCwwLDEtMTAuOS0xMC45VjIxNS40OGExMSwxMSwwLDAsMSwxMC45LTEwLjkxSDI4NWExMSwxMSwwLDAsMSwxMC45LDEwLjkxdjY5LjcxQTExLjA3LDExLjA3LDAsMCwxLDI4NC42OSwyOTYuMDlaJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNS41MiAtNS42OCknLz48L3N2Zz4=",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ return (_optionalChain$b([window, 'optionalAccess', _5 => _5.ethereum, 'optionalAccess', _6 => _6.isCoinbaseWallet]) || _optionalChain$b([window, 'optionalAccess', _7 => _7.ethereum, 'optionalAccess', _8 => _8.isWalletLink])) };}
  } Coinbase.__initStatic(); Coinbase.__initStatic2();

  function _optionalChain$a(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class CryptoCom extends WindowEthereum {

    static __initStatic() {this.info = {
      name: 'Crypto.com | DeFi Wallet',
      logo: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA4OS45IDEwMi44IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA4OS45IDEwMi44IiB4bWw6c3BhY2U9InByZXNlcnZlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOiNGRkZGRkY7fQoJLnN0MXtmaWxsOiMwMzMxNkM7fQo8L3N0eWxlPgoKPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTUuMzc1MSAtMTEzLjYxKSI+Cgk8ZyB0cmFuc2Zvcm09Im1hdHJpeCguMzE3OTQgMCAwIC4zMTQ2NSAtMS4wNDczIDMwLjQ0NykiPgoJCTxwYXRoIGNsYXNzPSJzdDAiIGQ9Im0xNjEuNiAyNjQuMy0xNDEuNCA4MS42djE2My4zbDE0MS40IDgxLjYgMTQxLjQtODEuNnYtMTYzLjNsLTE0MS40LTgxLjZ6bTAgMC0xNDEuNCA4MS42djE2My4zbDE0MS40IDgxLjYgMTQxLjQtODEuNnYtMTYzLjNsLTE0MS40LTgxLjZ6Ii8+CgkJPHBhdGggY2xhc3M9InN0MSIgZD0ibTIxNy41IDUyNy4xaC0yMC4xbC0yNC4xLTIyLjF2LTExLjNsMjQuOS0yMy44di0zNy43bDMyLjYtMjEuMyAzNy4xIDI4LjEtNTAuNCA4OC4xem0tODMuMy01OS42IDMuNy0zNS40LTEyLjItMzEuN2g3MmwtMTEuOSAzMS43IDMuNCAzNS40aC01NXptMTYuNCAzNy41LTI0LjEgMjIuNGgtMjAuNGwtNTAuNy04OC40IDM3LjQtMjcuOCAzMi45IDIxdjM3LjdsMjQuOSAyMy44djExLjN6bS00NC44LTE3MC4xaDExMS40bDEzLjMgNTYuN2gtMTM3LjdsMTMtNTYuN3ptNTUuOC03MC42LTE0MS40IDgxLjZ2MTYzLjNsMTQxLjQgODEuNiAxNDEuNC04MS42di0xNjMuM2wtMTQxLjQtODEuNnoiLz4KCTwvZz4KPC9nPgo8L3N2Zz4K",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ return _optionalChain$a([window, 'optionalAccess', _3 => _3.ethereum, 'optionalAccess', _4 => _4.isDeficonnectProvider]) };}
  } CryptoCom.__initStatic(); CryptoCom.__initStatic2();

  function _optionalChain$9(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class HyperPay extends WindowEthereum {

    static __initStatic() {this.info = {
      name: 'HyperPay',
      logo: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIGlkPSJMYXllcl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgMjA0LjcgMjAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAyMDQuNyAyMDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHBhdGggZmlsbD0iIzFBNzJGRSIgZD0iTTEwMi41LDUuMkM1MC44LDUuMiw4LjgsNDcuMiw4LjgsOTlzNDIsOTMuNSw5My44LDkzLjVzOTMuOC00Miw5My44LTkzLjhTMTU0LjIsNS4yLDEwMi41LDUuMnogTTEyNy4yLDExOS4yCgljLTYuMiwwLTIxLjcsMC4zLTIxLjcsMC4zbC03LDI3aC0yOWw2LjgtMjYuNUgzMWw3LjItMjEuOGMwLDAsNzguOCwwLjIsODUuMiwwYzYuNS0wLjIsMTYuNS0xLjgsMTYuOC0xNC44YzAuMy0xNy44LTI3LTE2LjgtMjkuMi0xCgljLTEuNSwxMC0xLjUsMTIuNS0xLjUsMTIuNUg4My44bDUtMjMuNUg0N2w2LjMtMjJjMCwwLDYxLjIsMC4yLDcyLjgsMC4yczQyLjIsMyw0Mi4yLDMxLjJDMTY4LjIsMTEyLDEzOC41LDExOS4zLDEyNy4yLDExOS4yCglMMTI3LjIsMTE5LjJ6Ii8+Cjwvc3ZnPgo=",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ return _optionalChain$9([window, 'optionalAccess', _3 => _3.ethereum, 'optionalAccess', _4 => _4.isHyperPay]) };}
  } HyperPay.__initStatic(); HyperPay.__initStatic2();

  function _optionalChain$8(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class MetaMask extends WindowEthereum {

    static __initStatic() {this.info = {
      name: 'MetaMask',
      logo: "data:image/svg+xml;base64,PHN2ZyBpZD0nTGF5ZXJfMScgZGF0YS1uYW1lPSdMYXllciAxJyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHZpZXdCb3g9JzAgMCA0ODUuOTMgNDUwLjU2Jz48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6IzgyODQ4Nzt9LmNscy0ye2ZpbGw6I2UyNzcyNjtzdHJva2U6I2UyNzcyNjt9LmNscy0xMCwuY2xzLTExLC5jbHMtMiwuY2xzLTMsLmNscy00LC5jbHMtNSwuY2xzLTYsLmNscy03LC5jbHMtOCwuY2xzLTl7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO30uY2xzLTN7ZmlsbDojZTM3NzI1O3N0cm9rZTojZTM3NzI1O30uY2xzLTR7ZmlsbDojZDZjMGIzO3N0cm9rZTojZDZjMGIzO30uY2xzLTV7ZmlsbDojMjQzNDQ3O3N0cm9rZTojMjQzNDQ3O30uY2xzLTZ7ZmlsbDojY2Q2MzI4O3N0cm9rZTojY2Q2MzI4O30uY2xzLTd7ZmlsbDojZTM3NTI1O3N0cm9rZTojZTM3NTI1O30uY2xzLTh7ZmlsbDojZjY4NTFmO3N0cm9rZTojZjY4NTFmO30uY2xzLTl7ZmlsbDojYzFhZTllO3N0cm9rZTojYzFhZTllO30uY2xzLTEwe2ZpbGw6IzE3MTcxNztzdHJva2U6IzE3MTcxNzt9LmNscy0xMXtmaWxsOiM3NjNlMWE7c3Ryb2tlOiM3NjNlMWE7fTwvc3R5bGU+PC9kZWZzPjxwYXRoIGNsYXNzPSdjbHMtMScgZD0nTTI0Ny45MSwzNTYuMjlhMjYsMjYsMCwxLDAtMjYsMjZBMjYsMjYsMCwwLDAsMjQ3LjkxLDM1Ni4yOVonIHRyYW5zZm9ybT0ndHJhbnNsYXRlKC03Ljk3IC0yMS4zMyknLz48cGF0aCBjbGFzcz0nY2xzLTEnIGQ9J00yNDYuNTUsMTQ5LjcxYTI2LDI2LDAsMSwwLTI2LDI2QTI2LDI2LDAsMCwwLDI0Ni41NSwxNDkuNzFaJyB0cmFuc2Zvcm09J3RyYW5zbGF0ZSgtNy45NyAtMjEuMzMpJy8+PGNpcmNsZSBjbGFzcz0nY2xzLTEnIGN4PScxNDguNCcgY3k9JzIzMC4wNScgcj0nMjUuOTknLz48cG9seWdvbiBjbGFzcz0nY2xzLTInIHBvaW50cz0nNDYxLjI4IDAuNSAyNzIuMDYgMTQxLjAzIDMwNy4wNSA1OC4xMiA0NjEuMjggMC41Jy8+PHBvbHlnb24gY2xhc3M9J2Nscy0zJyBwb2ludHM9JzI0LjQ2IDAuNSAyMTIuMTYgMTQyLjM3IDE3OC44OCA1OC4xMiAyNC40NiAwLjUnLz48cG9seWdvbiBjbGFzcz0nY2xzLTMnIHBvaW50cz0nMzkzLjIgMzI2LjI2IDM0Mi44MSA0MDMuNDcgNDUwLjYzIDQzMy4xNCA0ODEuNjMgMzI3Ljk3IDM5My4yIDMyNi4yNicvPjxwb2x5Z29uIGNsYXNzPSdjbHMtMycgcG9pbnRzPSc0LjQ5IDMyNy45NyAzNS4zIDQzMy4xNCAxNDMuMTMgNDAzLjQ3IDkyLjczIDMyNi4yNiA0LjQ5IDMyNy45NycvPjxwb2x5Z29uIGNsYXNzPSdjbHMtMycgcG9pbnRzPScxMzcuMDQgMTk1LjggMTA3IDI0MS4yNSAyMTQuMDYgMjQ2LjAxIDIxMC4yNiAxMzAuOTYgMTM3LjA0IDE5NS44Jy8+PHBvbHlnb24gY2xhc3M9J2Nscy0zJyBwb2ludHM9JzM0OC43IDE5NS44IDI3NC41MyAxMjkuNjMgMjcyLjA2IDI0Ni4wMSAzNzguOTQgMjQxLjI1IDM0OC43IDE5NS44Jy8+PHBvbHlnb24gY2xhc3M9J2Nscy0zJyBwb2ludHM9JzE0My4xMyA0MDMuNDcgMjA3LjQxIDM3Mi4wOSAxNTEuODggMzI4LjczIDE0My4xMyA0MDMuNDcnLz48cG9seWdvbiBjbGFzcz0nY2xzLTMnIHBvaW50cz0nMjc4LjM0IDM3Mi4wOSAzNDIuODEgNDAzLjQ3IDMzMy44NyAzMjguNzMgMjc4LjM0IDM3Mi4wOScvPjxwb2x5Z29uIGNsYXNzPSdjbHMtNCcgcG9pbnRzPSczNDIuODEgNDAzLjQ3IDI3OC4zNCAzNzIuMDkgMjgzLjQ3IDQxNC4xMiAyODIuOSA0MzEuODEgMzQyLjgxIDQwMy40NycvPjxwb2x5Z29uIGNsYXNzPSdjbHMtNCcgcG9pbnRzPScxNDMuMTMgNDAzLjQ3IDIwMy4wMyA0MzEuODEgMjAyLjY1IDQxNC4xMiAyMDcuNDEgMzcyLjA5IDE0My4xMyA0MDMuNDcnLz48cG9seWdvbiBjbGFzcz0nY2xzLTUnIHBvaW50cz0nMjAzLjk4IDMwMC45NyAxNTAuMzUgMjg1LjE4IDE4OC4yIDI2Ny44OCAyMDMuOTggMzAwLjk3Jy8+PHBvbHlnb24gY2xhc3M9J2Nscy01JyBwb2ludHM9JzI4MS43NiAzMDAuOTcgMjk3LjU1IDI2Ny44OCAzMzUuNTggMjg1LjE4IDI4MS43NiAzMDAuOTcnLz48cG9seWdvbiBjbGFzcz0nY2xzLTYnIHBvaW50cz0nMTQzLjEzIDQwMy40NyAxNTIuMjUgMzI2LjI2IDkyLjczIDMyNy45NyAxNDMuMTMgNDAzLjQ3Jy8+PHBvbHlnb24gY2xhc3M9J2Nscy02JyBwb2ludHM9JzMzMy42OCAzMjYuMjYgMzQyLjgxIDQwMy40NyAzOTMuMiAzMjcuOTcgMzMzLjY4IDMyNi4yNicvPjxwb2x5Z29uIGNsYXNzPSdjbHMtNicgcG9pbnRzPSczNzguOTQgMjQxLjI1IDI3Mi4wNiAyNDYuMDEgMjgxLjk1IDMwMC45NyAyOTcuNzQgMjY3Ljg4IDMzNS43NyAyODUuMTggMzc4Ljk0IDI0MS4yNScvPjxwb2x5Z29uIGNsYXNzPSdjbHMtNicgcG9pbnRzPScxNTAuMzUgMjg1LjE4IDE4OC4zOSAyNjcuODggMjAzLjk4IDMwMC45NyAyMTQuMDYgMjQ2LjAxIDEwNyAyNDEuMjUgMTUwLjM1IDI4NS4xOCcvPjxwb2x5Z29uIGNsYXNzPSdjbHMtNycgcG9pbnRzPScxMDcgMjQxLjI1IDE1MS44OCAzMjguNzMgMTUwLjM1IDI4NS4xOCAxMDcgMjQxLjI1Jy8+PHBvbHlnb24gY2xhc3M9J2Nscy03JyBwb2ludHM9JzMzNS43NyAyODUuMTggMzMzLjg3IDMyOC43MyAzNzguOTQgMjQxLjI1IDMzNS43NyAyODUuMTgnLz48cG9seWdvbiBjbGFzcz0nY2xzLTcnIHBvaW50cz0nMjE0LjA2IDI0Ni4wMSAyMDMuOTggMzAwLjk3IDIxNi41MyAzNjUuODIgMjE5LjM4IDI4MC40MyAyMTQuMDYgMjQ2LjAxJy8+PHBvbHlnb24gY2xhc3M9J2Nscy03JyBwb2ludHM9JzI3Mi4wNiAyNDYuMDEgMjY2LjkzIDI4MC4yNCAyNjkuMjEgMzY1LjgyIDI4MS45NSAzMDAuOTcgMjcyLjA2IDI0Ni4wMScvPjxwb2x5Z29uIGNsYXNzPSdjbHMtOCcgcG9pbnRzPScyODEuOTUgMzAwLjk3IDI2OS4yMSAzNjUuODIgMjc4LjM0IDM3Mi4wOSAzMzMuODcgMzI4LjczIDMzNS43NyAyODUuMTggMjgxLjk1IDMwMC45NycvPjxwb2x5Z29uIGNsYXNzPSdjbHMtOCcgcG9pbnRzPScxNTAuMzUgMjg1LjE4IDE1MS44OCAzMjguNzMgMjA3LjQxIDM3Mi4wOSAyMTYuNTMgMzY1LjgyIDIwMy45OCAzMDAuOTcgMTUwLjM1IDI4NS4xOCcvPjxwb2x5Z29uIGNsYXNzPSdjbHMtOScgcG9pbnRzPScyODIuOSA0MzEuODEgMjgzLjQ3IDQxNC4xMiAyNzguNzIgNDA5Ljk0IDIwNy4wMiA0MDkuOTQgMjAyLjY1IDQxNC4xMiAyMDMuMDMgNDMxLjgxIDE0My4xMyA0MDMuNDcgMTY0LjA1IDQyMC41OCAyMDYuNDUgNDUwLjA2IDI3OS4yOSA0NTAuMDYgMzIxLjg5IDQyMC41OCAzNDIuODEgNDAzLjQ3IDI4Mi45IDQzMS44MScvPjxwb2x5Z29uIGNsYXNzPSdjbHMtMTAnIHBvaW50cz0nMjc4LjM0IDM3Mi4wOSAyNjkuMjEgMzY1LjgyIDIxNi41MyAzNjUuODIgMjA3LjQxIDM3Mi4wOSAyMDIuNjUgNDE0LjEyIDIwNy4wMiA0MDkuOTQgMjc4LjcyIDQwOS45NCAyODMuNDcgNDE0LjEyIDI3OC4zNCAzNzIuMDknLz48cG9seWdvbiBjbGFzcz0nY2xzLTExJyBwb2ludHM9JzQ2OS4yNyAxNTAuMTYgNDg1LjQzIDcyLjU3IDQ2MS4yOCAwLjUgMjc4LjM0IDEzNi4yOCAzNDguNyAxOTUuOCA0NDguMTYgMjI0LjkgNDcwLjIyIDE5OS4yMyA0NjAuNzEgMTkyLjM4IDQ3NS45MiAxNzguNSA0NjQuMTMgMTY5LjM3IDQ3OS4zNSAxNTcuNzcgNDY5LjI3IDE1MC4xNicvPjxwb2x5Z29uIGNsYXNzPSdjbHMtMTEnIHBvaW50cz0nMC41IDcyLjU3IDE2LjY2IDE1MC4xNiA2LjM5IDE1Ny43NyAyMS42MSAxNjkuMzcgMTAuMDEgMTc4LjUgMjUuMjIgMTkyLjM4IDE1LjcxIDE5OS4yMyAzNy41OCAyMjQuOSAxMzcuMDQgMTk1LjggMjA3LjQxIDEzNi4yOCAyNC40NiAwLjUgMC41IDcyLjU3Jy8+PHBvbHlnb24gY2xhc3M9J2Nscy04JyBwb2ludHM9JzQ0OC4xNiAyMjQuOSAzNDguNyAxOTUuOCAzNzguOTQgMjQxLjI1IDMzMy44NyAzMjguNzMgMzkzLjIgMzI3Ljk3IDQ4MS42MyAzMjcuOTcgNDQ4LjE2IDIyNC45Jy8+PHBvbHlnb24gY2xhc3M9J2Nscy04JyBwb2ludHM9JzEzNy4wNCAxOTUuOCAzNy41OCAyMjQuOSA0LjQ5IDMyNy45NyA5Mi43MyAzMjcuOTcgMTUxLjg4IDMyOC43MyAxMDcgMjQxLjI1IDEzNy4wNCAxOTUuOCcvPjxwb2x5Z29uIGNsYXNzPSdjbHMtOCcgcG9pbnRzPScyNzIuMDYgMjQ2LjAxIDI3OC4zNCAxMzYuMjggMzA3LjI0IDU4LjEyIDE3OC44OCA1OC4xMiAyMDcuNDEgMTM2LjI4IDIxNC4wNiAyNDYuMDEgMjE2LjM0IDI4MC42MiAyMTYuNTMgMzY1LjgyIDI2OS4yMSAzNjUuODIgMjY5LjU5IDI4MC42MiAyNzIuMDYgMjQ2LjAxJy8+PC9zdmc+",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ 
      return(
        _optionalChain$8([window, 'optionalAccess', _3 => _3.ethereum, 'optionalAccess', _4 => _4.isMetaMask]) &&
        Object.keys(window.ethereum).filter((key)=>key.match(/^is(?!Connected)(?!PocketUniverse)(?!RevokeCash)/)).length == 1
      )
    };}
  } MetaMask.__initStatic(); MetaMask.__initStatic2();

  function _optionalChain$7(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class Opera extends WindowEthereum {

    static __initStatic() {this.info = {
      name: 'Opera',
      logo: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCA3NS42IDc1LjYiIHhtbDpzcGFjZT0icHJlc2VydmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIHRyYW5zZm9ybT0ibWF0cml4KDEuMzMzMyAwIDAgLTEuMzMzMyAwIDEwNy4yKSI+CiAgCiAgPGxpbmVhckdyYWRpZW50IGlkPSJvcGVyYUxvZ28wMDAwMDAxMjM1MTEiIHgxPSItMTA3LjM0IiB4Mj0iLTEwNi4zNCIgeTE9Ii0xMzcuODUiIHkyPSItMTM3Ljg1IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDAgLTczLjI1NyAtNzMuMjU3IDAgLTEwMDc1IC03Nzg0LjEpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICA8c3RvcCBzdG9wLWNvbG9yPSIjRkYxQjJEIiBvZmZzZXQ9IjAiLz4KICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGRjFCMkQiIG9mZnNldD0iLjMiLz4KICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGRjFCMkQiIG9mZnNldD0iLjYxNCIvPgogICAgPHN0b3Agc3RvcC1jb2xvcj0iI0E3MDAxNCIgb2Zmc2V0PSIxIi8+CiAgPC9saW5lYXJHcmFkaWVudD4KICAKICA8cGF0aCBmaWxsPSJ1cmwoI29wZXJhTG9nbzAwMDAwMDEyMzUxMSkiIGQ9Im0yOC4zIDgwLjRjLTE1LjYgMC0yOC4zLTEyLjctMjguMy0yOC4zIDAtMTUuMiAxMi0yNy42IDI3LTI4LjNoMS40YzcuMyAwIDEzLjkgMi43IDE4LjkgNy4yLTMuMy0yLjItNy4yLTMuNS0xMS40LTMuNS02LjggMC0xMi44IDMuMy0xNi45IDguNi0zLjEgMy43LTUuMiA5LjItNS4zIDE1LjN2MS4zYzAuMSA2LjEgMi4yIDExLjYgNS4zIDE1LjMgNC4xIDUuMyAxMC4xIDguNiAxNi45IDguNiA0LjIgMCA4LTEuMyAxMS40LTMuNS01IDQuNS0xMS42IDcuMi0xOC44IDcuMi0wLjEgMC4xLTAuMSAwLjEtMC4yIDAuMXoiLz4KICAKICAgIDxsaW5lYXJHcmFkaWVudCBpZD0iYiIgeDE9Ii0xMDcuMDYiIHgyPSItMTA2LjA2IiB5MT0iLTEzOC4wNCIgeTI9Ii0xMzguMDQiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMCAtNjQuNzkyIC02NC43OTIgMCAtODkwNi4yIC02ODYwLjQpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICA8c3RvcCBzdG9wLWNvbG9yPSIjOUMwMDAwIiBvZmZzZXQ9IjAiLz4KICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGRjRCNEIiIG9mZnNldD0iLjciLz4KICAgIDxzdG9wIHN0b3AtY29sb3I9IiNGRjRCNEIiIG9mZnNldD0iMSIvPgogIDwvbGluZWFyR3JhZGllbnQ+CiAgPHBhdGggZD0ibTE5IDY4YzIuNiAzLjEgNiA0LjkgOS42IDQuOSA4LjMgMCAxNC45LTkuNCAxNC45LTIwLjlzLTYuNy0yMC45LTE0LjktMjAuOWMtMy43IDAtNyAxLjktOS42IDQuOSA0LjEtNS4zIDEwLjEtOC42IDE2LjktOC42IDQuMiAwIDggMS4zIDExLjQgMy41IDUuOCA1LjIgOS41IDEyLjcgOS41IDIxLjFzLTMuNyAxNS45LTkuNSAyMS4xYy0zLjMgMi4yLTcuMiAzLjUtMTEuNCAzLjUtNi44IDAuMS0xMi44LTMuMy0xNi45LTguNiIgZmlsbD0idXJsKCNiKSIvPgo8L2c+Cjwvc3ZnPgo=",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ return _optionalChain$7([window, 'optionalAccess', _3 => _3.ethereum, 'optionalAccess', _4 => _4.isOpera]) };}
  } Opera.__initStatic(); Opera.__initStatic2();

  function _optionalChain$6(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

  const POLL_SPEED = 500; // 0.5 seconds
  const MAX_POLLS = 240; // 120 seconds

  const sendTransaction$2 = async ({ transaction, wallet })=> {
    transaction = new Transaction(transaction);
    await transaction.prepare({ wallet });
    await submit$2({ transaction, wallet }).then((signature)=>{
      if(signature) {
        transaction.id = signature;
        transaction.url = Blockchains__default['default'].findByName(transaction.blockchain).explorerUrlFor({ transaction });
        if (transaction.sent) transaction.sent(transaction);

        let count = 0;
        const interval = setInterval(async ()=> {
          count++;
          if(count >= MAX_POLLS) { return clearInterval(interval) }

          const provider = await web3ClientEvm.getProvider(transaction.blockchain);
          const { value } = await provider.getSignatureStatus(signature);
          const confirmationStatus = _optionalChain$6([value, 'optionalAccess', _ => _.confirmationStatus]);
          if(confirmationStatus) {
            const hasReachedSufficientCommitment = confirmationStatus === 'confirmed' || confirmationStatus === 'finalized';
            if (hasReachedSufficientCommitment) {
              if(value.err) {
                transaction._failed = true;
                const confirmedTransaction = await provider.getConfirmedTransaction(signature);
                const failedReason = _optionalChain$6([confirmedTransaction, 'optionalAccess', _2 => _2.meta, 'optionalAccess', _3 => _3.logMessages]) ? confirmedTransaction.meta.logMessages[confirmedTransaction.meta.logMessages.length - 1] : null;
                if(transaction.failed) transaction.failed(transaction, failedReason);
              } else {
                transaction._succeeded = true;
                if (transaction.succeeded) transaction.succeeded(transaction);
              }
              return clearInterval(interval)
            }
          }
        }, POLL_SPEED);
      } else {
        throw('Submitting transaction failed!')
      }
    });
    return transaction
  };

  const submit$2 = async({ transaction, wallet })=> {

    let result = await submitThroughWallet({ transaction, wallet });

    let signature;

    if(typeof result === 'object' && result.signatures && result.message) {
      signature = await submitDirectly(result, await wallet.account());
    } else if (typeof result === 'object' && result.signature && result.signature.length) {
      signature = result.signature;
    } else if (typeof result === 'string' && result.length) {
      signature = result;
    }
    
    return signature
  };

  const submitDirectly = async(tx, from) =>{
    let provider = await web3ClientEvm.getProvider('solana');
    return await provider.sendRawTransaction(tx.serialize())
  };

  const submitThroughWallet = async({ transaction, wallet })=> {
    if(transaction.instructions) {
      return submitInstructions({ transaction, wallet })
    } else {
      return submitSimpleTransfer$2({ transaction, wallet })
    }
  };

  const submitSimpleTransfer$2 = async ({ transaction, wallet })=> {
    let fromPubkey = new PublicKey(await wallet.account());
    let toPubkey = new PublicKey(transaction.to);
    const provider = await web3ClientEvm.getProvider(transaction.blockchain);
    let recentBlockhash = (await provider.getLatestBlockhash()).blockhash;
    const instructions = [
      SystemProgram.transfer({
        fromPubkey,
        toPubkey,
        lamports: parseInt(Transaction.bigNumberify(transaction.value, transaction.blockchain), 10)
      })
    ];
    const messageV0 = new TransactionMessage({
      payerKey: fromPubkey,
      recentBlockhash,
      instructions,
    }).compileToV0Message();
    const transactionV0 = new VersionedTransaction(messageV0);
    return wallet._sendTransaction(transactionV0)
  };

  const submitInstructions = async ({ transaction, wallet })=> {
    let fromPubkey = new PublicKey(await wallet.account());
    const provider = await web3ClientEvm.getProvider(transaction.blockchain);
    let recentBlockhash = (await provider.getLatestBlockhash()).blockhash;
    const messageV0 = new TransactionMessage({
      payerKey: fromPubkey,
      recentBlockhash,
      instructions: transaction.instructions,
    }).compileToV0Message(
      transaction.alts ? await Promise.all(transaction.alts.map(async(alt)=>{
        return (await web3ClientEvm.getProvider('solana')).getAddressLookupTable(new PublicKey(alt)).then((res) => res.value)
      })) : undefined);
    const transactionV0 = new VersionedTransaction(messageV0);
    if(transaction.signers && transaction.signers.length) {
      transactionV0.sign(Array.from(new Set(transaction.signers)));
    }
    return wallet._sendTransaction(transactionV0)
  };

  function _optionalChain$5(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class WindowSolana {

    static __initStatic() {this.info = {
      name: 'Wallet (Solana)',
      logo: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI2LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA0NDYuNCAzNzYuOCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDQ2LjQgMzc2Ljg7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojODI4NDg3O30KCS5zdDF7ZmlsbDp1cmwoI1NWR0lEXzFfKTt9Cgkuc3Qye2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDE2NTIzNDE5NTQ5NTc2MDU4MDgwMDAwMDAwNjMwMzAwNDA2OTM1MjExODk1MV8pO30KCS5zdDN7ZmlsbDp1cmwoI1NWR0lEXzAwMDAwMDkyNDIyMzgxNjc5OTg1OTI5MTcwMDAwMDA2ODU0NzIyMTYxOTE4MTIzNjUzXyk7fQo8L3N0eWxlPgo8cGF0aCBjbGFzcz0ic3QwIiBkPSJNMzgxLjcsMTEwLjJoNjQuN1Y0Ni41YzAtMjUuNy0yMC44LTQ2LjUtNDYuNS00Ni41SDQ2LjVDMjAuOCwwLDAsMjAuOCwwLDQ2LjV2NjUuMWgzNS43bDI2LjktMjYuOQoJYzEuNS0xLjUsMy42LTIuNSw1LjctMi43bDAsMGgwLjRoNzguNmM1LjMtMjUuNSwzMC4yLTQyLDU1LjctMzYuN2MyNS41LDUuMyw0MiwzMC4yLDM2LjcsNTUuN2MtMS42LDcuNS00LjksMTQuNi05LjgsMjAuNQoJYy0wLjksMS4xLTEuOSwyLjItMywzLjNjLTEuMSwxLjEtMi4yLDIuMS0zLjMsM2MtMjAuMSwxNi42LTQ5LjksMTMuOC02Ni41LTYuM2MtNC45LTUuOS04LjMtMTMtOS44LTIwLjZINzMuMmwtMjYuOSwyNi44CgljLTEuNSwxLjUtMy42LDIuNS01LjcsMi43bDAsMGgtMC40aC0wLjFoLTAuNUgwdjc0aDI4LjhsMTguMi0xOC4yYzEuNS0xLjYsMy42LTIuNSw1LjctMi43bDAsMGgwLjRoMjkuOQoJYzUuMi0yNS41LDMwLjItNDEuOSw1NS43LTM2LjdzNDEuOSwzMC4yLDM2LjcsNTUuN3MtMzAuMiw0MS45LTU1LjcsMzYuN2MtMTguNS0zLjgtMzIuOS0xOC4yLTM2LjctMzYuN0g1Ny43bC0xOC4yLDE4LjMKCWMtMS41LDEuNS0zLjYsMi41LTUuNywyLjdsMCwwaC0wLjRIMHYzNC4yaDU2LjNjMC4yLDAsMC4zLDAsMC41LDBoMC4xaDAuNGwwLDBjMi4yLDAuMiw0LjIsMS4yLDUuOCwyLjhsMjgsMjhoNTcuNwoJYzUuMy0yNS41LDMwLjItNDIsNTUuNy0zNi43czQyLDMwLjIsMzYuNyw1NS43Yy0xLjcsOC4xLTUuNSwxNS43LTExLDIxLjljLTAuNiwwLjctMS4yLDEuMy0xLjksMnMtMS4zLDEuMy0yLDEuOQoJYy0xOS41LDE3LjMtNDkuMywxNS42LTY2LjctMy45Yy01LjUtNi4yLTkuMy0xMy43LTExLTIxLjlIODcuMWMtMS4xLDAtMi4xLTAuMi0zLjEtMC41aC0wLjFsLTAuMy0wLjFsLTAuMi0wLjFsLTAuMi0wLjFsLTAuMy0wLjEKCWgtMC4xYy0wLjktMC41LTEuOC0xLjEtMi42LTEuOGwtMjgtMjhIMHY1My41YzAuMSwyNS43LDIwLjksNDYuNCw0Ni41LDQ2LjRoMzUzLjNjMjUuNywwLDQ2LjUtMjAuOCw0Ni41LTQ2LjV2LTYzLjZoLTY0LjcKCWMtNDMuMiwwLTc4LjItMzUtNzguMi03OC4ybDAsMEMzMDMuNSwxNDUuMiwzMzguNSwxMTAuMiwzODEuNywxMTAuMnoiLz4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTIyMC45LDI5OC4xYzAtMTQuNC0xMS42LTI2LTI2LTI2cy0yNiwxMS42LTI2LDI2czExLjYsMjYsMjYsMjZTMjIwLjksMzEyLjQsMjIwLjksMjk4LjFMMjIwLjksMjk4LjF6Ii8+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0yMTkuNiw5MS41YzAtMTQuNC0xMS42LTI2LTI2LTI2cy0yNiwxMS42LTI2LDI2czExLjYsMjYsMjYsMjZTMjE5LjYsMTA1LjgsMjE5LjYsOTEuNXoiLz4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTM4Mi4yLDEyOC44aC0wLjVjLTMyLjksMC01OS42LDI2LjctNTkuNiw1OS42bDAsMGwwLDBjMCwzMi45LDI2LjcsNTkuNiw1OS42LDU5LjZsMCwwaDAuNQoJYzMyLjksMCw1OS42LTI2LjcsNTkuNi01OS42bDAsMEM0NDEuOCwxNTUuNCw0MTUuMSwxMjguOCwzODIuMiwxMjguOHogTTM5Ni42LDIxOS40aC0zMWw4LjktMzIuNWMtNy43LTMuNy0xMS0xMi45LTcuNC0yMC42CgljMy43LTcuNywxMi45LTExLDIwLjYtNy40YzcuNywzLjcsMTEsMTIuOSw3LjQsMjAuNmMtMS41LDMuMi00LjEsNS44LTcuNCw3LjRMMzk2LjYsMjE5LjR6Ii8+CjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTQ5LjAwNzciIHkxPSIxMzkuMzA5MyIgeDI9IjEyMi4xMjMxIiB5Mj0iMTkwLjgwNDIiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAwIDMwLjUzNTQpIj4KCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMwMEZGQTMiLz4KCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNEQzFGRkYiLz4KPC9saW5lYXJHcmFkaWVudD4KPHBhdGggY2xhc3M9InN0MSIgZD0iTTExMi43LDIwMy41YzAuMy0wLjMsMC43LTAuNSwxLjEtMC41aDM4LjhjMC43LDAsMS4xLDAuOSwwLjYsMS40bC03LjcsNy43Yy0wLjMsMC4zLTAuNywwLjUtMS4xLDAuNWgtMzguOAoJYy0wLjcsMC0xLjEtMC45LTAuNi0xLjRMMTEyLjcsMjAzLjV6Ii8+CjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAxNzUzMTAwMjIwMDgyNTMzODQyNTAwMDAwMTEwOTY3OTQyODQ4NDUzNDEzNTVfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjEzNy4yNTMzIiB5MT0iMTMzLjE3MjUiIHgyPSIxMTAuMzY4NyIgeTI9IjE4NC42Njc0IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMCAzMC41MzU0KSI+Cgk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojMDBGRkEzIi8+Cgk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojREMxRkZGIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxwYXRoIHN0eWxlPSJmaWxsOnVybCgjU1ZHSURfMDAwMDAxNzUzMTAwMjIwMDgyNTMzODQyNTAwMDAwMTEwOTY3OTQyODQ4NDUzNDEzNTVfKTsiIGQ9Ik0xMTIuNywxNzQuOWMwLjMtMC4zLDAuNy0wLjUsMS4xLTAuNWgzOC44CgljMC43LDAsMS4xLDAuOSwwLjYsMS40bC03LjcsNy43Yy0wLjMsMC4zLTAuNywwLjUtMS4xLDAuNWgtMzguOGMtMC43LDAtMS4xLTAuOS0wLjYtMS40TDExMi43LDE3NC45eiIvPgo8bGluZWFyR3JhZGllbnQgaWQ9IlNWR0lEXzAwMDAwMDIyNTU3MTYwNTg5MTY1MTU3NTIwMDAwMDE1NDYyNjI0Mjk4Nzk4NTYzMjYxXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxNDMuMDkyOSIgeTE9IjEzNi4yMjEyIiB4Mj0iMTE2LjIwODIiIHkyPSIxODcuNzE2MiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDAgMzAuNTM1NCkiPgoJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzAwRkZBMyIvPgoJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0RDMUZGRiIvPgo8L2xpbmVhckdyYWRpZW50Pgo8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMDIyNTU3MTYwNTg5MTY1MTU3NTIwMDAwMDE1NDYyNjI0Mjk4Nzk4NTYzMjYxXyk7IiBkPSJNMTQ1LjYsMTg5LjFjLTAuMy0wLjMtMC43LTAuNS0xLjEtMC41CgloLTM4LjhjLTAuNywwLTEuMSwwLjktMC42LDEuNGw3LjcsNy43YzAuMywwLjMsMC43LDAuNSwxLjEsMC41aDM4LjhjMC43LDAsMS4xLTAuOSwwLjYtMS40TDE0NS42LDE4OS4xeiIvPgo8L3N2Zz4K',
      blockchains: supported$2.solana
    };}

    static __initStatic2() {this.isAvailable = async()=>{ 
      return (
        _optionalChain$5([window, 'optionalAccess', _2 => _2.solana]) &&
        !(window.isPhantomInstalled) &&
        !window.coin98 &&
        !window.solana.isGlow
      )
    };}
    
    constructor () {
      this.name = this.constructor.info.name;
      this.logo = this.constructor.info.logo;
      this.blockchains = this.constructor.info.blockchains;
      this.sendTransaction = (transaction)=>{ 
        return sendTransaction$2({
          wallet: this,
          transaction
        })
      };
    }

    getProvider() { return window.solana }

    async account() {
      const provider = this.getProvider();
      if(provider == undefined){ return }
      if(provider.publicKey) { return provider.publicKey.toString() }
      if(provider.isBraveWallet != true) {
        let publicKey;
        try { ({ publicKey } = await window.solana.connect({ onlyIfTrusted: true })); } catch (e2) {}
        if(publicKey){ return publicKey.toString() }
      }
    }

    async connect() {
      const provider = this.getProvider();
      if(!provider) { return undefined }

      let result;
      try { result = await provider.connect(); } catch (e3) {}

      if(result && result.publicKey) {
        return result.publicKey.toString()
      } else {
        return provider.publicKey.toString()
      }
    }

    on(event, callback) {
      let internalCallback;
      switch (event) {
        case 'account':
          internalCallback = (publicKey) => callback(_optionalChain$5([publicKey, 'optionalAccess', _3 => _3.toString, 'call', _4 => _4()]));
          this.getProvider().on('accountChanged', internalCallback);
          break
      }
      return internalCallback
    }

    off(event, internalCallback) {
      switch (event) {
        case 'account':
          this.getProvider().removeListener('accountChanged', internalCallback);
          break
      }
      return internalCallback
    }

    async connectedTo(input) {
      if(input) {
        return input == 'solana'
      } else {
        return 'solana'
      }
    }

    switchTo(blockchainName) {
      return new Promise((resolve, reject)=>{
        reject({ code: 'NOT_SUPPORTED' });
      })
    }

    addNetwork(blockchainName) {
      return new Promise((resolve, reject)=>{
        reject({ code: 'NOT_SUPPORTED' });
      })
    }

    async sign(message) {
      const encodedMessage = new TextEncoder().encode(message);
      const signedMessage = await this.getProvider().signMessage(encodedMessage);
      if(signedMessage && signedMessage.signature) {
        return Array.from(signedMessage.signature)
      }
    }

    _sendTransaction(transaction) { 
      try {
        return this.getProvider().signAndSendTransaction(transaction)
      } catch (e){
        alert(e);
      }
    }
  } WindowSolana.__initStatic(); WindowSolana.__initStatic2();

  class Phantom extends WindowSolana {

    static __initStatic() {this.info = {
      name: 'Phantom',
      logo: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMjggMTI4IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAxMjggMTI4OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2ZpbGw6dXJsKCNTVkdJRF8xXyk7fQoJLnN0MXtmaWxsOnVybCgjU1ZHSURfMDAwMDAwMjU0MzQ3Mjk4MTg1NjMwMDE0MzAwMDAwMDA4MDkyOTcxNTA5NTE0Njc2NTdfKTt9Cjwvc3R5bGU+CjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iNjQiIHkxPSIxMTguNTk1NCIgeDI9IjY0IiB5Mj0iMTMuNDA0NiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDEzMCkiPgoJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzUzNEJCMSIvPgoJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzU1MUJGOSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8Y2lyY2xlIGNsYXNzPSJzdDAiIGN4PSI2NCIgY3k9IjY0IiByPSI1Mi42Ii8+CjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAxODAzNTkzNjMzODg0OTQyMDMyNTAwMDAwMDQyNDUxODUwMjI4NDM0OTI3NDlfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjY1LjIzMjYiIHkxPSI5OS42OTQiIHgyPSI2NS4yMzI2IiB5Mj0iMjkuODQwNiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAtMSAwIDEzMCkiPgoJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6I0ZGRkZGRiIvPgoJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6I0ZGRkZGRjtzdG9wLW9wYWNpdHk6MC44MiIvPgo8L2xpbmVhckdyYWRpZW50Pgo8cGF0aCBzdHlsZT0iZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTgwMzU5MzYzMzg4NDk0MjAzMjUwMDAwMDA0MjQ1MTg1MDIyODQzNDkyNzQ5Xyk7IiBkPSJNMTAyLjMsNjQuOGgtOS40YzAtMTktMTUuNi0zNC40LTM0LjgtMzQuNAoJYy0xOSwwLTM0LjQsMTUtMzQuOCwzMy43Yy0wLjQsMTkuMywxNy45LDM2LjEsMzcuNSwzNi4xaDIuNWMxNy4yLDAsNDAuMy0xMy4zLDQzLjktMjkuNkMxMDcuOCw2Ny42LDEwNS40LDY0LjgsMTAyLjMsNjQuOHoKCSBNNDQuMSw2NS42YzAsMi41LTIuMSw0LjYtNC43LDQuNnMtNC43LTIuMS00LjctNC42di03LjVjMC0yLjUsMi4xLTQuNiw0LjctNC42czQuNywyLjEsNC43LDQuNlY2NS42eiBNNjAuMyw2NS42CgljMCwyLjUtMi4xLDQuNi00LjcsNC42Yy0yLjYsMC00LjctMi4xLTQuNy00LjZ2LTcuNWMwLTIuNSwyLjEtNC42LDQuNy00LjZjMi42LDAsNC43LDIuMSw0LjcsNC42VjY1LjZ6Ii8+Cjwvc3ZnPgo=',
      blockchains: ['solana']
    };}

    static __initStatic2() {this.isAvailable = async()=>{
      return (
        window.isPhantomInstalled
      )
    };}
  } Phantom.__initStatic(); Phantom.__initStatic2();

  function _optionalChain$4(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class Trust extends WindowEthereum {

    static __initStatic() {this.info = {
      name: 'Trust Wallet',
      logo: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPHN2ZyBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMCA5Ni41IDk2LjUiIHZlcnNpb249IjEuMSIgdmlld0JveD0iMCAwIDk2LjUgOTYuNSIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgZmlsbD0iI0ZGRkZGRiIgd2lkdGg9Ijk2LjUiIGhlaWdodD0iOTYuNSIvPgo8cGF0aCBzdHJva2U9IiMzMzc1QkIiIHN0cm9rZS13aWR0aD0iNi4wNjMiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLW1pdGVybGltaXQgPSIxMCIgZmlsbD0ibm9uZSIgZD0ibTQ4LjUgMjAuMWM5LjYgOCAyMC42IDcuNSAyMy43IDcuNS0wLjcgNDUuNS01LjkgMzYuNS0yMy43IDQ5LjMtMTcuOC0xMi44LTIzLTMuNy0yMy43LTQ5LjMgMy4yIDAgMTQuMSAwLjUgMjMuNy03LjV6Ii8+Cjwvc3ZnPgo=",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ return (_optionalChain$4([window, 'optionalAccess', _5 => _5.ethereum, 'optionalAccess', _6 => _6.isTrust]) || _optionalChain$4([window, 'optionalAccess', _7 => _7.ethereum, 'optionalAccess', _8 => _8.isTrustWallet])) };}
  } Trust.__initStatic(); Trust.__initStatic2();

  class Glow extends WindowSolana {

    static __initStatic() {this.info = {
      name: 'Glow',
      logo: 'data:image/webp;base64,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',
      blockchains: ['solana']
    };}

    static __initStatic2() {this.isAvailable = async()=>{
      return (
        window.solana &&
        window.solana.isGlow
      )
    };}
  } Glow.__initStatic(); Glow.__initStatic2();

  function _optionalChain$3(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class Solflare extends WindowSolana {

    static __initStatic() {this.info = {
      name: 'Solflare',
      logo: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCA1MCA1MCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNTAgNTA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDp1cmwoI1NWR0lEXzFfKTt9Cgkuc3Qxe2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDA0MTI1OTU5ODg4MjM0NDgzNTI5MDAwMDAxMjg1ODg4NTIyOTkwNzM1MjI0MF8pO30KPC9zdHlsZT4KPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSIxMC43OTg4IiB5MT0iMzkuOTEwOCIgeDI9IjMyLjM5NzYiIHkyPSIyMC4zNTc4IiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIC0xIDAgNTIpIj4KCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiNGRkMxMEIiLz4KCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiNGQjNGMkUiLz4KPC9saW5lYXJHcmFkaWVudD4KPHBhdGggY2xhc3M9InN0MCIgZD0iTTI1LjEsNDIuNGMwLjQsMCwwLjcsMC4zLDAuNywwLjdjMCwwLjQtMC4zLDAuNy0wLjcsMC43cy0wLjctMC4zLTAuNy0wLjdDMjQuNCw0Mi43LDI0LjcsNDIuNCwyNS4xLDQyLjR6CgkgTTI0LjMsOC4zYzAuNCwwLDAuNiwwLjMsMC43LDAuNmwwLjksNi4yYzAuMywyLjEsMi44LDMsNC4zLDEuNmw4LjYtNy44YzAuMi0wLjIsMC41LTAuMiwwLjcsMGMwLjIsMC4yLDAuMiwwLjUsMCwwLjdMMzIsMTguMgoJYy0xLjQsMS42LTAuNCw0LjEsMS43LDQuM2w2LjYsMC42YzAuMywwLDAuNiwwLjMsMC41LDAuNmMwLDAuMy0wLjIsMC41LTAuNSwwLjVsLTcsMS4xYy0yLDAuMy0yLjksMi43LTEuNiw0LjJsMi40LDIuOQoJYzAuMiwwLjIsMC4yLDAuNi0wLjEsMC44Yy0wLjIsMC4yLTAuNSwwLjItMC43LDBsLTMtMi4zYy0xLjYtMS4yLTQtMC4yLTQuMSwxLjhsLTAuNyw3LjljMCwwLjMtMC4zLDAuNi0wLjYsMC41CgljLTAuMywwLTAuNS0wLjItMC41LTAuNWwtMS4xLTcuNmMtMC4zLTIuMS0yLjgtMy00LjMtMS42TDEwLDM5LjljLTAuMiwwLjItMC41LDAuMi0wLjcsMGMtMC4yLTAuMi0wLjItMC40LDAtMC42bDgtOS4yCgljMS40LTEuNiwwLjQtNC4xLTEuNy00LjNsLTYuNi0wLjZjLTAuMywwLTAuNi0wLjMtMC41LTAuNmMwLTAuMywwLjItMC41LDAuNS0wLjVsNy0xLjFjMi0wLjMsMi45LTIuNywxLjYtNC4ybC0xLjctMgoJYy0wLjItMC4zLTAuMi0wLjcsMC4xLTFjMC4yLTAuMiwwLjYtMC4yLDAuOSwwbDIsMS41YzEuNiwxLjIsNCwwLjIsNC4xLTEuOGwwLjYtNi41QzIzLjUsOC41LDIzLjksOC4yLDI0LjMsOC4zeiBNNi43LDIzLjgKCWMwLjQsMCwwLjcsMC4zLDAuNywwLjdzLTAuMywwLjctMC43LDAuN2MtMC40LDAtMC43LTAuMy0wLjctMC43UzYuMywyMy44LDYuNywyMy44eiBNNDIuOSwyMy4xYzAuNCwwLDAuNywwLjMsMC43LDAuNwoJYzAsMC40LTAuMywwLjctMC43LDAuN2MtMC40LDAtMC43LTAuMy0wLjctMC43QzQyLjIsMjMuNCw0Mi41LDIzLjEsNDIuOSwyMy4xeiBNMjQuMiw2YzAuNCwwLDAuNywwLjMsMC43LDAuNwoJYzAsMC40LTAuMywwLjctMC43LDAuN2MtMC40LDAtMC43LTAuMy0wLjctMC43QzIzLjUsNi4zLDIzLjgsNiwyNC4yLDZ6Ii8+CjxyYWRpYWxHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAxMDAzNTM3NjAxMTAwMjExMTQ0NDAwMDAwMDg4MDc5Mzk1MzE2NjY5Njc5MzhfIiBjeD0iLTIwMS40OTc5IiBjeT0iMjg1LjIxMTkiIHI9IjAuNzU5NyIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCg0Ljk5MjIgMTIuMDYzOSAxMi4xODExIC01LjA0MDcgLTI0NDUuMjIzNCAzODkwLjE2MzYpIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+Cgk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojRkZDMTBCIi8+Cgk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojRkIzRjJFIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxwYXRoIHN0eWxlPSJmaWxsOnVybCgjU1ZHSURfMDAwMDAxMDAzNTM3NjAxMTAwMjExMTQ0NDAwMDAwMDg4MDc5Mzk1MzE2NjY5Njc5MzhfKTsiIGQ9Ik0yNC42LDMwLjljMy44LDAsNi44LTMsNi44LTYuNwoJYzAtMy43LTMuMS02LjctNi44LTYuN3MtNi44LDMtNi44LDYuN0MxNy44LDI3LjksMjAuOSwzMC45LDI0LjYsMzAuOXoiLz4KPC9zdmc+Cg==',
      blockchains: ['solana']
    };}

    static __initStatic2() {this.isAvailable = async()=>{
      return (
        _optionalChain$3([window, 'optionalAccess', _2 => _2.solflare]) &&
        window.solflare.isSolflare
      )
    };}

    getProvider() { return window.solflare }

    _sendTransaction(transaction) { return this.getProvider().signTransaction(transaction) }
  } Solflare.__initStatic(); Solflare.__initStatic2();

  function _optionalChain$2(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class Backpack extends WindowSolana {

    static __initStatic() {this.info = {
      name: 'Backpack',
      logo: 'data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkxheWVyXzEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiIHg9IjBweCIgeT0iMHB4IgoJIHZpZXdCb3g9IjAgMCAxMDAgMTAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCAxMDAgMTAwOyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+CjxzdHlsZSB0eXBlPSJ0ZXh0L2NzcyI+Cgkuc3Qwe2NsaXAtcGF0aDp1cmwoI1NWR0lEXzAwMDAwMTA2ODQwODY0OTg0NTM1NTU0MzQwMDAwMDAwNDc2MjMzMDgyNzcwODcyOTcxXyk7fQoJLnN0MXtmaWxsLXJ1bGU6ZXZlbm9kZDtjbGlwLXJ1bGU6ZXZlbm9kZDtmaWxsOiNFMzNFM0Y7fQo8L3N0eWxlPgo8Zz4KCTxkZWZzPgoJCTxyZWN0IGlkPSJTVkdJRF8xXyIgeD0iMjMuOCIgeT0iMTAuNCIgd2lkdGg9IjUyLjQiIGhlaWdodD0iNzYuMiIvPgoJPC9kZWZzPgoJPGNsaXBQYXRoIGlkPSJTVkdJRF8wMDAwMDE3ODE5NTUzMTM2ODQxNzQ3MDkwMDAwMDAxNDk2Njk4MDAxOTUxNjc4MTk3MF8iPgoJCTx1c2UgeGxpbms6aHJlZj0iI1NWR0lEXzFfIiAgc3R5bGU9Im92ZXJmbG93OnZpc2libGU7Ii8+Cgk8L2NsaXBQYXRoPgoJPGcgc3R5bGU9ImNsaXAtcGF0aDp1cmwoI1NWR0lEXzAwMDAwMTc4MTk1NTMxMzY4NDE3NDcwOTAwMDAwMDE0OTY2OTgwMDE5NTE2NzgxOTcwXyk7Ij4KCQk8cGF0aCBjbGFzcz0ic3QxIiBkPSJNNTUsMTYuNGMyLjgsMCw1LjQsMC40LDcuOCwxLjFjLTIuNC01LjUtNy4yLTcuMS0xMi43LTcuMWMtNS41LDAtMTAuNCwxLjYtMTIuNyw3LjFjMi40LTAuNyw1LTEuMSw3LjctMS4xCgkJCUg1NXogTTQ0LjQsMjEuOWMtMTMuMiwwLTIwLjcsMTAuNC0yMC43LDIzLjF2MTMuMWMwLDEuMywxLjEsMi4zLDIuNCwyLjNoNDcuNmMxLjMsMCwyLjQtMSwyLjQtMi4zVjQ1YzAtMTIuOC04LjctMjMuMS0yMS45LTIzLjEKCQkJSDQ0LjR6IE01MCw0NS4xYzQuNiwwLDguMy0zLjcsOC4zLTguM3MtMy43LTguMy04LjMtOC4zcy04LjMsMy43LTguMyw4LjNTNDUuNCw0NS4xLDUwLDQ1LjF6IE0yMy44LDY4LjFjMC0xLjMsMS4xLTIuMywyLjQtMi4zCgkJCWg0Ny42YzEuMywwLDIuNCwxLDIuNCwyLjNWODJjMCwyLjYtMi4xLDQuNi00LjgsNC42SDI4LjZjLTIuNiwwLTQuOC0yLjEtNC44LTQuNlY2OC4xeiIvPgoJPC9nPgo8L2c+Cjwvc3ZnPgo=',
      blockchains: ['solana']
    };}

    static __initStatic2() {this.isAvailable = async()=>{
      return (
        _optionalChain$2([window, 'optionalAccess', _2 => _2.backpack]) &&
        window.backpack.isBackpack
      )
    };}

    getProvider() { return window.backpack }

    async sign(message) {
      const encodedMessage = new TextEncoder().encode(message);
      const signature = await this.getProvider().signMessage(encodedMessage);
      return Object.values(signature)
    }

    _sendTransaction(transaction) {
      return this.getProvider().sendAndConfirm(transaction)
    }
  } Backpack.__initStatic(); Backpack.__initStatic2();

  function _optionalChain$1(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
  class Rabby extends WindowEthereum {

    static __initStatic() {this.info = {
      name: 'Rabby',
      logo: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI3LjIuMCwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9ImthdG1hbl8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIKCSB2aWV3Qm94PSIwIDAgMjA0IDE1MiIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjA0IDE1MjsiIHhtbDpzcGFjZT0icHJlc2VydmUiPgo8c3R5bGUgdHlwZT0idGV4dC9jc3MiPgoJLnN0MHtmaWxsOnVybCgjU1ZHSURfMV8pO30KCS5zdDF7ZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7ZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTE4MzY5MTkwNjY5MjcyNDcwNjgwMDAwMDE1NjE0NDY3MTMxNjE1Mjc5NDkxXyk7fQoJLnN0MntmaWxsLXJ1bGU6ZXZlbm9kZDtjbGlwLXJ1bGU6ZXZlbm9kZDtmaWxsOnVybCgjU1ZHSURfMDAwMDAwNjU3Nzc0NTQ3NDc4MDEzNzcwNTAwMDAwMDcwMDM5OTUyODQ2NDY5NTk3NzVfKTt9Cgkuc3Qze2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDA5MTY5NjU3NTkzMjA0MzQxNTM5MDAwMDAwMTAyMTU2NDM5MjA1MDA3ODg1Nl8pO30KPC9zdHlsZT4KPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8xXyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI3MS4zNDE4IiB5MT0iNDE5LjA4NjkiIHgyPSIxNzUuMjg4MSIgeTI9IjQ0OC41NjQxIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDEgMCAwIDEgMCAtMzQ2KSI+Cgk8c3RvcCAgb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjojODc5N0ZGIi8+Cgk8c3RvcCAgb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjojQUFBOEZGIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik0xNzYuNCw4NS40YzUuOS0xMy4yLTIzLjMtNTAuMS01MS4yLTY1LjNDMTA3LjUsOC4xLDg5LjMsOS43LDg1LjUsMTVjLTguMSwxMS40LDI3LDIxLjMsNTAuNCwzMi41CgljLTUuMSwyLjItOS44LDYuMi0xMi41LDExLjFDMTE0LjcsNDksOTUuNSw0MC44LDczLDQ3LjVjLTE1LjIsNC40LTI3LjgsMTUuMS0zMi43LDMwLjljLTEuMS0wLjUtMi41LTAuOC0zLjgtMC44CgljLTUuMiwwLTkuNSw0LjMtOS41LDkuNWMwLDUuMiw0LjMsOS41LDkuNSw5LjVjMSwwLDQtMC42LDQtMC42bDQ4LjgsMC4zYy0xOS41LDMxLjEtMzUsMzUuNS0zNSw0MC45czE0LjcsNCwyMC4zLDEuOQoJYzI2LjYtOS41LDU1LjItMzkuNSw2MC4xLTQ4LjFDMTU1LjMsOTMuOCwxNzIuNSw5My45LDE3Ni40LDg1LjR6Ii8+CjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAwMzg0MDY0NTAzNDY5MjQ4NjkzNTAwMDAwMDA5NDQzOTczMDQwMTQ3OTk1NDdfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjE1My45OTAyIiB5MT0iNDIxLjM0NzQiIHgyPSI3OC45ODgzIiB5Mj0iMzQ2LjE2MTgiIGdyYWRpZW50VHJhbnNmb3JtPSJtYXRyaXgoMSAwIDAgMSAwIC0zNDYpIj4KCTxzdG9wICBvZmZzZXQ9IjAiIHN0eWxlPSJzdG9wLWNvbG9yOiMzQjIyQTAiLz4KCTxzdG9wICBvZmZzZXQ9IjEiIHN0eWxlPSJzdG9wLWNvbG9yOiM1MTU2RDg7c3RvcC1vcGFjaXR5OjAiLz4KPC9saW5lYXJHcmFkaWVudD4KPHBhdGggc3R5bGU9ImZpbGwtcnVsZTpldmVub2RkO2NsaXAtcnVsZTpldmVub2RkO2ZpbGw6dXJsKCNTVkdJRF8wMDAwMDAzODQwNjQ1MDM0NjkyNDg2OTM1MDAwMDAwMDk0NDM5NzMwNDAxNDc5OTU0N18pOyIgZD0iCglNMTM2LjEsNDcuNUwxMzYuMSw0Ny41YzEuMS0wLjUsMS0yLjEsMC42LTMuM2MtMC42LTIuOS0xMi41LTE0LjYtMjMuNi0xOS44Yy0xNS4yLTcuMS0yNi4zLTYuOC0yNy45LTMuNWMzLDYuMywxNy40LDEyLjIsMzIuNCwxOC42CglDMTIzLjcsNDEuOSwxMzAuMiw0NC42LDEzNi4xLDQ3LjVMMTM2LjEsNDcuNXoiLz4KPGxpbmVhckdyYWRpZW50IGlkPSJTVkdJRF8wMDAwMDE0NzIyMDY3MjYxNTU0Nzk0MjI0MDAwMDAxMTg5NDM0ODEwNDAwNzM1NDA0NF8iIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiB4MT0iMTE4Ljc4NjUiIHkxPSI0NTkuOTQ1OSIgeDI9IjQ2LjczODgiIHkyPSI0MTguNTIzNiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDAgLTM0NikiPgoJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6IzNCMUU4RiIvPgoJPHN0b3AgIG9mZnNldD0iMSIgc3R5bGU9InN0b3AtY29sb3I6IzZBNkZGQjtzdG9wLW9wYWNpdHk6MCIvPgo8L2xpbmVhckdyYWRpZW50Pgo8cGF0aCBzdHlsZT0iZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7ZmlsbDp1cmwoI1NWR0lEXzAwMDAwMTQ3MjIwNjcyNjE1NTQ3OTQyMjQwMDAwMDExODk0MzQ4MTA0MDA3MzU0MDQ0Xyk7IiBkPSIKCU0xMTYuNywxMTEuMmMtMy0xLjEtNi41LTIuMi0xMC41LTMuMmM0LjEtNy41LDUuMS0xOC43LDEuMS0yNS43Yy01LjYtOS44LTEyLjUtMTUuMS0yOC45LTE1LjFjLTguOSwwLTMzLDMtMzMuNSwyMy4yCgljMCwyLjEsMCw0LDAuMiw1LjlsNDQuMSwwYy01LjksOS40LTExLjQsMTYuMy0xNi4zLDIxLjZjNS45LDEuNCwxMC42LDIuNywxNS4xLDRjNC4xLDEuMSw4LjEsMi4xLDEyLjEsMy4yCglDMTA2LjEsMTIwLjYsMTExLjgsMTE1LjgsMTE2LjcsMTExLjJ6Ii8+CjxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMDAwMDAxMjg0NzQ1MTgwNjUxMjc5MDc2OTAwMDAwMDg3OTM1NDY5MjM0OTg1OTA4NjFfIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjY2LjM2MDQiIHkxPSI0MjcuNjAyIiB4Mj0iMTE1LjA1OTMiIHkyPSI0ODkuNDc5MiIgZ3JhZGllbnRUcmFuc2Zvcm09Im1hdHJpeCgxIDAgMCAxIDAgLTM0NikiPgoJPHN0b3AgIG9mZnNldD0iMCIgc3R5bGU9InN0b3AtY29sb3I6Izg4OThGRiIvPgoJPHN0b3AgIG9mZnNldD0iMC45ODM5IiBzdHlsZT0ic3RvcC1jb2xvcjojNUY0N0YxIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxwYXRoIHN0eWxlPSJmaWxsOnVybCgjU1ZHSURfMDAwMDAxMjg0NzQ1MTgwNjUxMjc5MDc2OTAwMDAwMDg3OTM1NDY5MjM0OTg1OTA4NjFfKTsiIGQ9Ik0zOS43LDkzLjljMS43LDE1LjIsMTAuNSwyMS4zLDI4LjIsMjMKCWMxNy44LDEuNywyNy45LDAuNiw0MS40LDEuN2MxMS4zLDEsMjEuNCw2LjgsMjUuMSw0LjhjMy4zLTEuNywxLjQtOC4yLTMtMTIuNGMtNS45LTUuNC0xNC05LTI4LjEtMTAuNWMyLjktNy44LDIuMS0xOC43LTIuNC0yNC42CgljLTYuMy04LjYtMTguMS0xMi40LTMzLTEwLjhDNTIuMyw2Ny4xLDM3LjQsNzQuOSwzOS43LDkzLjl6Ii8+Cjwvc3ZnPgo=",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ 
      return(
        _optionalChain$1([window, 'optionalAccess', _3 => _3.ethereum, 'optionalAccess', _4 => _4.isRabby])
      )
    };}
  } Rabby.__initStatic(); Rabby.__initStatic2();

  const transactionApiBlockchainNames = {
    'ethereum': 'mainnet',
    'bsc': 'bsc',
    'polygon': 'polygon',
  };

  const explorerBlockchainNames = {
    'ethereum': 'eth',
    'bsc': 'bnb',
    'polygon': 'matic',
  };

  class Safe {

    constructor ({ address, blockchain }) {
      this.address = address;
      this.blockchain = blockchain;
    }

    async transactionCount() {
      let transactionCount;
      let jsonResult = await fetch(`https://safe-transaction-${transactionApiBlockchainNames[this.blockchain]}.safe.global/api/v1/safes/${this.address}/all-transactions/`)
        .then((response) => response.json())
        .catch((error) => { console.error('Error:', error); });
      if(jsonResult && jsonResult.results && jsonResult.results.length) {
        transactionCount = jsonResult.results[0].nonce + 1;
      } else {
        transactionCount = parseInt((await web3ClientEvm.request({
          blockchain: this.blockchain,
          address: this.address,
          api: [{"inputs":[],"name":"nonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],
          method: 'nonce',
        })).toString(), 10);
      }
      return transactionCount
    }

    async retrieveTransaction({ blockchain, tx }) {
      const provider = await web3ClientEvm.getProvider(blockchain);
      let jsonResult = await fetch(`https://safe-transaction-${transactionApiBlockchainNames[blockchain]}.safe.global/api/v1/multisig-transactions/${tx}/`)
        .then((response) => response.json())
        .catch((error) => { console.error('Error:', error); });
      if(jsonResult && jsonResult.isExecuted && jsonResult.transactionHash) {
        return await provider.getTransaction(jsonResult.transactionHash)
      } else {
        return undefined
      }
    }

    explorerUrlFor({ transaction }) {
      if(transaction) {
        return `https://app.safe.global/${explorerBlockchainNames[transaction.blockchain]}:${transaction.from}/transactions/tx?id=multisig_${transaction.from}_${transaction.id}`
      }
    }
  }

  const isSmartContractWallet = async(blockchain, address)=>{
    const provider = await web3ClientEvm.getProvider(blockchain);
    const code = await provider.getCode(address);
    return (code != '0x')
  };

  const identifySmartContractWallet = async (blockchain, address)=>{
    let name; 
    try {
      name = await web3ClientEvm.request({
        blockchain,
        address,
        api: [{ "constant": true, "inputs": [], "name": "NAME", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "payable": false, "stateMutability": "view", "type": "function"}],
        method: 'NAME'
      });
    } catch (e) {}
    if(name == 'Default Callback Handler') { return 'Safe' }
    
  };

  const getSmartContractWallet = async(blockchain, address)=> {
    if(!await isSmartContractWallet(blockchain, address)){ return }

    const type = await identifySmartContractWallet(blockchain, address);
    if(type == 'Safe') {
      return new Safe({ blockchain, address })
    } else if(type == 'Argent') {
      return new Argent({ blockchain, address })
    } else {
      if(smartContractWallet){ throw({ message: 'Unrecognized smart contract wallet not supported!', code: "SMART_CONTRACT_WALLET_NOT_SUPPORTED" }) }
    }
  };

  const sendTransaction$1 = async ({ transaction, wallet })=> {
    transaction = new Transaction(transaction);
    if((await wallet.connectedTo(transaction.blockchain)) == false) {
      throw({ code: 'WRONG_NETWORK' })
    }
    await transaction.prepare({ wallet });
    const smartContractWallet = await getSmartContractWallet(transaction.blockchain, transaction.from);
    let transactionCount = await wallet.transactionCount({ blockchain: transaction.blockchain, address: transaction.from });
    transaction.nonce = transactionCount;
    await submit$1({ transaction, wallet }).then((tx)=>{
      if (tx) {
        let blockchain = Blockchains__default['default'].findByName(transaction.blockchain);
        transaction.id = tx;
        transaction.url = smartContractWallet && smartContractWallet.explorerUrlFor ? smartContractWallet.explorerUrlFor({ transaction }) : blockchain.explorerUrlFor({ transaction });
        if (transaction.sent) transaction.sent(transaction);
        retrieveTransaction({ blockchain: transaction.blockchain, tx, smartContractWallet }).then((sentTransaction)=>{
          transaction.id = sentTransaction.hash || transaction.id;
          transaction.url = blockchain.explorerUrlFor({ transaction });
          transaction.nonce = sentTransaction.nonce || transactionCount;
          sentTransaction.wait(1).then(() => {
            transaction._succeeded = true;
            if (transaction.succeeded) transaction.succeeded(transaction);
          }).catch((error)=>{
            if(error && error.code && error.code == 'TRANSACTION_REPLACED') {
              if(error.replacement && error.replacement.hash && error.receipt && error.receipt.status == 1) {
                transaction.id = error.replacement.hash;
                transaction._succeeded = true;
                if (transaction.succeeded) transaction.succeeded(transaction);
              } else if(error.replacement && error.replacement.hash && error.receipt && error.receipt.status == 0) {
                transaction.id = error.replacement.hash;
                transaction._failed = true;
                if(transaction.failed) transaction.failed(transaction, error);  
              }
            } else {
              transaction._failed = true;
              if(transaction.failed) transaction.failed(transaction, error);
            }
          });
        });
      } else {
        throw('Submitting transaction failed!')
      }
    });
    return transaction
  };

  const retrieveTransaction = async ({ blockchain, tx, smartContractWallet })=>{
    const provider = await web3ClientEvm.getProvider(blockchain);
    let retrieve = async()=>{
      try {
        if(smartContractWallet && smartContractWallet.retrieveTransaction) {
          return await smartContractWallet.retrieveTransaction({ blockchain, tx })
        } else {
          return await provider.getTransaction(tx)
        }
      } catch (e) {}
    };
    
    let sentTransaction;
    sentTransaction = await retrieve();
    while (!sentTransaction) {
      await (new Promise((resolve)=>setTimeout(resolve, 3000)));
      sentTransaction = await retrieve();
    }
    return sentTransaction
  };

  const submit$1 = ({ transaction, wallet }) => {
    if(transaction.method) {
      return submitContractInteraction$1({ transaction, wallet })
    } else {
      return submitSimpleTransfer$1({ transaction, wallet })
    }
  };

  const submitContractInteraction$1 = async ({ transaction, wallet })=>{
    const provider = await web3ClientEvm.getProvider(transaction.blockchain);
    const gasPrice = await provider.getGasPrice();
    let gas = await web3ClientEvm.estimate(transaction);
    const data = await transaction.getData();
    const value = transaction.value ? ethers.ethers.utils.hexlify(ethers.ethers.BigNumber.from(transaction.value)) : undefined;
    const nonce = ethers.ethers.utils.hexlify(transaction.nonce);
    gas = gas.add(gas.div(10));
    return wallet.connector.sendTransaction({
      from: transaction.from,
      to: transaction.to,
      value,
      data,
      gas: gas.toHexString(),
      gasPrice: gasPrice.toHexString(),
      nonce,
    })
  };

  const submitSimpleTransfer$1 = async ({ transaction, wallet })=>{
    const provider = await web3ClientEvm.getProvider(transaction.blockchain);
    const gasPrice = await provider.getGasPrice();
    const gas = await web3ClientEvm.estimate(transaction);
    const value = ethers.ethers.utils.hexlify(ethers.ethers.BigNumber.from(transaction.value));
    const nonce = ethers.ethers.utils.hexlify(transaction.nonce);
    return wallet.connector.sendTransaction({
      from: transaction.from,
      to: transaction.to,
      value,
      data: '0x',
      gas: gas.toHexString(),
      gasPrice: gasPrice.toHexString(),
      nonce,
    })
  };

  function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

  const KEY = '_DePayWeb3WalletsConnectedWalletConnectV1Instance';

  let currentPlainInstance;

  const getPlainInstance = ()=>{
    if(currentPlainInstance) { return currentPlainInstance }
    currentPlainInstance = getWalletConnectInstance(()=>{});
    return currentPlainInstance
  };

  const isConnected = ()=>{
    return new Promise(async(resolve, reject)=>{
      
      setTimeout(()=>{ 
        delete localStorage['walletconnect'];
        resolve(false);
      }, 5000);

      if(!localStorage['walletconnect'] || JSON.parse(localStorage['walletconnect']).handshakeTopic.length == 0) {
        delete localStorage['walletconnect'];
        return resolve(false)
      }

      let connector = getPlainInstance();
      let accounts;

      try {
        let blockNumber = await connector.sendCustomRequest({ method: 'eth_blockNumber' });
        if(blockNumber) {
          accounts = await connector.sendCustomRequest({ method: 'eth_accounts' }); 
        } else {
          delete localStorage['walletconnect'];
        }
      } catch (error) {
        delete localStorage['walletconnect'];
        resolve(false);
      }

      return resolve(accounts && accounts.length)
    })
  };

  const getConnectedInstance$1 = async()=>{
    if(window[KEY]) { return window[KEY] }
    if(await isConnected()) { return new WalletConnectV1() }
  };

  const setConnectedInstance$1 = (value)=>{
    window[KEY] = value;
  };

  const getWalletConnectInstance = (connect)=>{
    return new walletconnectV1.WalletConnectClient({
      bridge: "https://walletconnect.depay.com",
      qrcodeModal: { 
        open: async(uri)=>connect({ uri }),
        close: ()=>{},
      }
    })
  };

  class WalletConnectV1 {

    static __initStatic() {this.info = {
      name: 'WalletConnect',
      logo: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0nMS4wJyBlbmNvZGluZz0ndXRmLTgnPz48IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMjUuNC4xLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAtLT48c3ZnIHZlcnNpb249JzEuMScgaWQ9J0xheWVyXzEnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgeG1sbnM6eGxpbms9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnIHg9JzBweCcgeT0nMHB4JyB2aWV3Qm94PScwIDAgNTAwIDUwMCcgc3R5bGU9J2VuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNTAwIDUwMDsnIHhtbDpzcGFjZT0ncHJlc2VydmUnPjxzdHlsZSB0eXBlPSd0ZXh0L2Nzcyc+IC5zdDB7ZmlsbDojNTk5MUNEO30KPC9zdHlsZT48ZyBpZD0nUGFnZS0xJz48ZyBpZD0nd2FsbGV0Y29ubmVjdC1sb2dvLWFsdCc+PHBhdGggaWQ9J1dhbGxldENvbm5lY3QnIGNsYXNzPSdzdDAnIGQ9J00xMDIuNywxNjJjODEuNS03OS44LDIxMy42LTc5LjgsMjk1LjEsMGw5LjgsOS42YzQuMSw0LDQuMSwxMC41LDAsMTQuNEwzNzQsMjE4LjkgYy0yLDItNS4zLDItNy40LDBsLTEzLjUtMTMuMmMtNTYuOC01NS43LTE0OS01NS43LTIwNS44LDBsLTE0LjUsMTQuMWMtMiwyLTUuMywyLTcuNCwwTDkxLjksMTg3Yy00LjEtNC00LjEtMTAuNSwwLTE0LjQgTDEwMi43LDE2MnogTTQ2Ny4xLDIyOS45bDI5LjksMjkuMmM0LjEsNCw0LjEsMTAuNSwwLDE0LjRMMzYyLjMsNDA1LjRjLTQuMSw0LTEwLjcsNC0xNC44LDBjMCwwLDAsMCwwLDBMMjUyLDMxMS45IGMtMS0xLTIuNy0xLTMuNywwaDBsLTk1LjUsOTMuNWMtNC4xLDQtMTAuNyw0LTE0LjgsMGMwLDAsMCwwLDAsMEwzLjQsMjczLjZjLTQuMS00LTQuMS0xMC41LDAtMTQuNGwyOS45LTI5LjIgYzQuMS00LDEwLjctNCwxNC44LDBsOTUuNSw5My41YzEsMSwyLjcsMSwzLjcsMGMwLDAsMCwwLDAsMGw5NS41LTkzLjVjNC4xLTQsMTAuNy00LDE0LjgsMGMwLDAsMCwwLDAsMGw5NS41LDkzLjUgYzEsMSwyLjcsMSwzLjcsMGw5NS41LTkzLjVDNDU2LjQsMjI1LjksNDYzLDIyNS45LDQ2Ny4xLDIyOS45eicvPjwvZz48L2c+PC9zdmc+Cg==",
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{
      return (await getConnectedInstance$1()) != undefined
    };}

    constructor() {
      this.name = (localStorage[KEY+'_name'] && localStorage[KEY+'_name'] != 'undefined') ? localStorage[KEY+'_name'] : this.constructor.info.name;
      this.logo = (localStorage[KEY+'_logo'] && localStorage[KEY+'_logo'] != 'undefined') ? localStorage[KEY+'_logo'] : this.constructor.info.logo;
      this.blockchains = this.constructor.info.blockchains;
      this.sendTransaction = (transaction)=>{ 
        return sendTransaction$1({
          wallet: this,
          transaction
        })
      };
    }

    disconnect() {
      setConnectedInstance$1(undefined);
      localStorage[KEY+'_name'] = undefined;
      localStorage[KEY+'_logo'] = undefined;
      currentPlainInstance = undefined;
    }

    newWalletConnectInstance(connect) {
      let instance = getWalletConnectInstance(connect);

      instance.on("disconnect", (error, payload) => {
        this.disconnect();
        if (error) { throw error }
      });

      instance.on("modal_closed", ()=>{
        setConnectedInstance$1(undefined);
        this.connector = undefined;
      });

      return instance
    }

    async account() {
      if(!this.connector){ this.connector = getPlainInstance(); }
      let accounts;
      try{ accounts = await this.connector.sendCustomRequest({ method: 'eth_accounts' }); } catch (e) {}
      if(accounts && accounts.length) { return ethers.ethers.utils.getAddress(accounts[0]) }
    }

    async connect(options) {
      let connect = (options && options.connect) ? options.connect : ({uri})=>{};
      try {

        this.connector = WalletConnectV1.instance;

        if(this.connector == undefined){
          this.connector = this.newWalletConnectInstance(connect);
        }

        if(options && options.reconnect) {
          if(this.connector) {
            try{ await this.connector.killSession(); } catch (e2) {}
            this.disconnect();
          }
        }

        if((await isConnected())) {
          return await this.account()
        } else {

          let { accounts, chainId } = await this.connector.connect();

          if(_optionalChain([options, 'optionalAccess', _ => _.name])) { localStorage[KEY+'_name'] = this.name = options.name; }
          if(_optionalChain([options, 'optionalAccess', _2 => _2.logo])) { localStorage[KEY+'_logo'] = this.logo = options.logo; }

          if(accounts instanceof Array && accounts.length) {
            setConnectedInstance$1(this);
            accounts = accounts.map((account)=>ethers.ethers.utils.getAddress(account));

            return accounts[0]
          } else {
            return
          }
        }
        
      } catch (error) {
        console.log('WALLETCONNECT ERROR', error);
        return undefined
      }
    }

    async connectedTo(input) {
      let chainId = await this.connector.sendCustomRequest({ method: 'eth_chainId' });
      const blockchain = Blockchains__default['default'].findById(chainId);
      if(input) {
        return input === blockchain.name
      } else {
        return blockchain.name
      }
    }

    switchTo(blockchainName) {
      return new Promise((resolve, reject)=>{
        let resolved, rejected;
        const blockchain = Blockchains__default['default'].findByName(blockchainName);
        setTimeout(async()=>{
          if(!(await this.connectedTo(blockchainName)) && !resolved && !rejected){
            reject({ code: 'NOT_SUPPORTED' });
          } else {
            resolve();
          }
        }, 3000);
        this.connector.sendCustomRequest({ 
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: blockchain.id }],
        }).then(()=>{
          resolved = true;
          resolve();
        }).catch((error)=> {
          if(error && typeof error.message == 'string' && error.message.match('addEthereumChain')){ // chain not yet added
            this.addNetwork(blockchainName)
              .then(()=>this.switchTo(blockchainName).then(()=>{
                resolved = true;
                resolve();
              }))
              .catch(()=>{
                rejected = true;
                reject({ code: 'NOT_SUPPORTED' });
              });
          } else {
            rejected = true;
            reject({ code: 'NOT_SUPPORTED' });
          }
        });
      })
    }

    addNetwork(blockchainName) {
      return new Promise((resolve, reject)=>{
        const blockchain = Blockchains__default['default'].findByName(blockchainName);
        this.connector.sendCustomRequest({ 
          method: 'wallet_addEthereumChain',
          params: [{
            chainId: blockchain.id,
            chainName: blockchain.fullName,
            nativeCurrency: {
              name: blockchain.currency.name,
              symbol: blockchain.currency.symbol,
              decimals: blockchain.currency.decimals
            },
            rpcUrls: [blockchain.rpc],
            blockExplorerUrls: [blockchain.explorer],
            iconUrls: [blockchain.logo]
          }],
        }).then(resolve).catch(reject);
      })
    }

    on(event, callback) {
      let internalCallback;
      switch (event) {
        case 'account':
          internalCallback = (error, payload) => {
            if(payload && payload.params && payload.params[0].accounts && payload.params[0].accounts instanceof Array) {
              const accounts = payload.params[0].accounts.map((account)=>ethers.ethers.utils.getAddress(account));
              callback(accounts[0]);
            }
          };
          this.connector.on("session_update", internalCallback);
          break
      }
      return internalCallback
    }

    off(event, callback) {
      switch (event) {
        case 'account':
          this.connector.off("session_update");
          break
      }
    }

    async transactionCount({ blockchain, address }) {
      const smartContractWallet = await getSmartContractWallet(blockchain, address);
      if(smartContractWallet) {
        return await smartContractWallet.transactionCount()
      } else {
        return await web3ClientEvm.request({ blockchain, method: 'transactionCount', address })
      }
    }

    async sign(message) {
      let blockchain = await this.connectedTo();
      let address = await this.account();
      const smartContractWallet = await getSmartContractWallet(blockchain, address);
      if(smartContractWallet){ throw({ message: 'Smart contract wallets are not supported for signing!', code: "SMART_CONTRACT_WALLET_NOT_SUPPORTED" }) }
      var params = [ethers.ethers.utils.toUtf8Bytes(message), address];
      let signature = await this.connector.signPersonalMessage(params);
      return signature
    }
  } WalletConnectV1.__initStatic(); WalletConnectV1.__initStatic2();

  WalletConnectV1.getConnectedInstance = getConnectedInstance$1;
  WalletConnectV1.setConnectedInstance = setConnectedInstance$1;

  const sendTransaction = async ({ transaction, wallet })=> {
    transaction = new Transaction(transaction);
    if((await wallet.connectedTo(transaction.blockchain)) == false) {
      await wallet.switchTo(transaction.blockchain);
    }
    if((await wallet.connectedTo(transaction.blockchain)) == false) {
      throw({ code: 'WRONG_NETWORK' })
    }
    await transaction.prepare({ wallet });
    let provider = new ethers.ethers.providers.Web3Provider(wallet.connector, 'any');
    let signer = provider.getSigner(0);
    await submit({ transaction, provider, signer }).then((sentTransaction)=>{
      if (sentTransaction) {
        transaction.id = sentTransaction.hash;
        transaction.nonce = sentTransaction.nonce;
        transaction.url = Blockchains__default['default'].findByName(transaction.blockchain).explorerUrlFor({ transaction });
        if (transaction.sent) transaction.sent(transaction);
        sentTransaction.wait(1).then(() => {
          transaction._succeeded = true;
          if (transaction.succeeded) transaction.succeeded(transaction);
        }).catch((error)=>{
          if(error && error.code && error.code == 'TRANSACTION_REPLACED') {
            if(error.replacement && error.replacement.hash) {
              transaction.id = error.replacement.hash;
              transaction.url = Blockchains__default['default'].findByName(transaction.blockchain).explorerUrlFor({ transaction });
            }
            if(error.replacement && error.replacement.hash && error.receipt && error.receipt.status == 1) {
              transaction._succeeded = true;
              if (transaction.succeeded) transaction.succeeded(transaction);
            } else if(error.replacement && error.replacement.hash && error.receipt && error.receipt.status == 0) {
              transaction._failed = true;
              if(transaction.failed) transaction.failed(transaction, error);  
            }
          } else {
            transaction._failed = true;
            if(transaction.failed) transaction.failed(transaction, error);
          }
        });
      } else {
        throw('Submitting transaction failed!')
      }
    });
    return transaction
  };

  const submit = ({ transaction, provider, signer }) => {
    if(transaction.method) {
      return submitContractInteraction({ transaction, signer, provider })
    } else {
      return submitSimpleTransfer({ transaction, signer })
    }
  };

  const submitContractInteraction = ({ transaction, signer, provider })=>{
    let contract = new ethers.ethers.Contract(transaction.to, transaction.api, provider);
    let contractArguments = transaction.getContractArguments({ contract });
    let method = contract.connect(signer)[transaction.method];
    if(contractArguments) {
      return method(...contractArguments, {
        value: Transaction.bigNumberify(transaction.value, transaction.blockchain)
      })
    } else {
      return method({
        value: Transaction.bigNumberify(transaction.value, transaction.blockchain)
      })
    }
  };

  const submitSimpleTransfer = ({ transaction, signer })=>{
    return signer.sendTransaction({
      to: transaction.to,
      value: Transaction.bigNumberify(transaction.value, transaction.blockchain)
    })
  };

  const getConnectedInstance = ()=>{
    return window._connectedWalletLinkInstance
  };

  const setConnectedInstance = (value)=>{
    window._connectedWalletLinkInstance = value;
  };

  class WalletLink {

    static __initStatic() {this.info = {
      name: 'Coinbase',
      logo: Coinbase.info.logo,
      blockchains: supported$2.evm
    };}

    static __initStatic2() {this.isAvailable = async()=>{ return getConnectedInstance() != undefined };}

    constructor() {
      this.name = this.constructor.info.name;
      this.logo = this.constructor.info.logo;
      this.blockchains = this.constructor.info.blockchains;
      this.connector = WalletLink.instance || this.newWalletLinkInstance();
      this.sendTransaction = (transaction)=>{
        return sendTransaction({
          wallet: this,
          transaction
        })
      };
    }

    newWalletLinkInstance() {
      let instance = new coinbaseWalletSdk.CoinbaseWalletSDK({}).makeWeb3Provider();
      return instance
    }

    async account() {
      if(this.connectedAccounts == undefined) { return }
      return ethers.ethers.utils.getAddress(this.connectedAccounts[0])
    }

    async connect(options) {
      let relay = await this.connector._relayProvider();
      relay.setConnectDisabled(false);
      let accounts = await this.connector.enable();
      if(accounts instanceof Array && accounts.length) {
        setConnectedInstance(this);
      }
      accounts = accounts.map((account)=>ethers.ethers.utils.getAddress(account));
      this.connectedAccounts = accounts;
      this.connectedChainId = await this.connector.getChainId();
      return accounts[0]
    }

    async connectedTo(input) {
      let chainId = await this.connector.getChainId();
      const blockchain = Blockchains__default['default'].findByNetworkId(chainId);
      if(input) {
        return input === blockchain.name
      } else {
        return blockchain.name
      }
    }

    switchTo(blockchainName) {
      return new Promise((resolve, reject)=>{
        const blockchain = Blockchains__default['default'].findByName(blockchainName);
        this.connector.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: blockchain.id }],
        }).then(resolve).catch((error)=> {
          if(error.code === 4902){ // chain not yet added
            this.addNetwork(blockchainName)
              .then(()=>this.switchTo(blockchainName).then(resolve))
              .catch(reject);
          } else {
            reject(error);
          }
        });
      })
    }

    addNetwork(blockchainName) {
      return new Promise((resolve, reject)=>{
        const blockchain = Blockchains__default['default'].findByName(blockchainName);
        this.connector.request({
          method: 'wallet_addEthereumChain',
          params: [{
            chainId: blockchain.id,
            chainName: blockchain.fullName,
            nativeCurrency: {
              name: blockchain.currency.name,
              symbol: blockchain.currency.symbol,
              decimals: blockchain.currency.decimals
            },
            rpcUrls: [blockchain.rpc],
            blockExplorerUrls: [blockchain.explorer],
            iconUrls: [blockchain.logo]
          }],
        }).then(resolve).catch(reject);
      })
    }

    on(event, callback) {
      let internalCallback;
      switch (event) {
        case 'account':
          internalCallback = (accounts) => callback(ethers.ethers.utils.getAddress(accounts[0]));
          this.connector.on('accountsChanged', internalCallback);
          break
      }
      return internalCallback
    }

    off(event, internalCallback) {
      switch (event) {
        case 'account':
          this.connector.removeListener('accountsChanged', internalCallback);
          break
      }
      return internalCallback
    }

    transactionCount({ blockchain, address }) {
      return request({ blockchain, method: 'transactionCount', address })
    }

    async sign(message) {
      await this.account();
      let provider = new ethers.ethers.providers.Web3Provider(this.connector, 'any');
      let signer = provider.getSigner(0);
      let signature = await signer.signMessage(message);
      return signature
    }
  } WalletLink.__initStatic(); WalletLink.__initStatic2();

  WalletLink.getConnectedInstance = getConnectedInstance;
  WalletLink.setConnectedInstance = setConnectedInstance;

  var wallets = {
    MetaMask,
    Phantom,
    Coinbase,
    Binance,
    Trust,
    Backpack,
    Glow,
    Solflare,
    Rabby,
    Brave,
    Opera,
    Coin98,
    CryptoCom,
    HyperPay,
    WindowEthereum,
    WindowSolana,
    WalletConnectV1,
    WalletLink
  };

  const getWallets = async(args)=>{

    let drip = (args && typeof args.drip === 'function') ? args.drip : undefined;

    let availableWallets = await Promise.all(
      
      Object.keys(wallets).map(
        
        async(key)=>{
        
          let wallet = wallets[key];

          if(await wallet.isAvailable()) {
            let instance;
            
            if(wallet.getConnectedInstance) {
              instance = await wallet.getConnectedInstance();
              if(drip) { drip(instance); }
              return instance
            } else {
              if(drip) { drip(wallet); }
              return new wallet
            }
          }
        }
      )
    );

    return availableWallets.filter(Boolean)
  };

  const supported = [
    wallets.MetaMask,
    wallets.Coinbase,
    wallets.Binance,
    wallets.Trust,
    wallets.Rabby,
    wallets.Brave,
    wallets.Opera,
    wallets.Coin98,
    wallets.CryptoCom,
    wallets.HyperPay,
    wallets.WalletConnectV1,
    wallets.WalletLink,
    wallets.WindowEthereum,
  ];

  exports.getWallets = getWallets;
  exports.supported = supported;
  exports.wallets = wallets;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
